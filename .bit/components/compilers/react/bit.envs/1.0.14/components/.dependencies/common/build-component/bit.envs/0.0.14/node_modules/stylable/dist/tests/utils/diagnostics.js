"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var index_1 = require("../../src/index");
var stylable_processor_1 = require("../../src/stylable-processor");
var generate_test_util_1 = require("./generate-test-util");
var deindent = require('deindent');
function findTestLocations(css) {
    var line = 1;
    var column = 1;
    var inWord = false;
    var start;
    var end;
    var word = null;
    for (var i = 0; i < css.length; i++) {
        var ch = css.charAt(i);
        if (ch === '\n') {
            line += 1;
            column = 1;
        }
        else if (ch === '|') {
            if (!start) {
                start = { line: line, column: column };
            }
            else {
                end = { line: line, column: column };
            }
        }
        else if (ch === '$') {
            inWord = !inWord;
            if (inWord) {
                word = '';
            }
        }
        else if (inWord) {
            word += ch;
        }
        else {
            column++;
        }
    }
    return { start: start, end: end, word: word, css: css.replace(/[|$]/gm, '') };
}
exports.findTestLocations = findTestLocations;
function expectWarnings(css, warnings) {
    var source = findTestLocations(css);
    var root = index_1.safeParse(source.css);
    var res = stylable_processor_1.process(root);
    res.diagnostics.reports.forEach(function (report, i) {
        chai_1.expect(report.message).to.equal(warnings[i].message);
        chai_1.expect(report.node.source.start, 'start').to.eql(source.start);
        if (source.word !== null) {
            chai_1.expect(report.options.word).to.eql(source.word);
        }
    });
    chai_1.expect(res.diagnostics.reports.length, 'diagnostics reports match').to.equal(warnings.length);
}
exports.expectWarnings = expectWarnings;
function expectWarningsFromTransform(config, warnings) {
    config.trimWS = false;
    var locations = {};
    for (var path in config.files) {
        var source = findTestLocations(deindent(config.files[path].content).trim());
        config.files[path].content = source.css;
        locations[path] = source;
    }
    var diagnostics = new index_1.Diagnostics();
    var result = generate_test_util_1.generateFromMock(config, diagnostics);
    if (warnings.length === 0 && diagnostics.reports.length !== 0) {
        chai_1.expect(warnings.length, 'diagnostics reports match').to.equal(diagnostics.reports.length);
    }
    diagnostics.reports.forEach(function (report, i) {
        var path = warnings[i].file;
        chai_1.expect(report.message).to.equal(warnings[i].message);
        if (!warnings[i].skipLocationCheck) {
            chai_1.expect(report.node.source.start).to.eql(locations[path].start);
        }
        if (locations[path].word !== null) {
            chai_1.expect(report.options.word).to.eql(locations[path].word);
        }
    });
    chai_1.expect(warnings.length, 'diagnostics reports match').to.equal(diagnostics.reports.length);
    return result;
}
exports.expectWarningsFromTransform = expectWarningsFromTransform;
//# sourceMappingURL=diagnostics.js.map