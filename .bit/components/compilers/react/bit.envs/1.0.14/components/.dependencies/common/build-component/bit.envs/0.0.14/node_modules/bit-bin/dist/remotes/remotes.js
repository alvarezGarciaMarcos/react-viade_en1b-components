"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = require("ramda");

  _ramda = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _remote() {
  const data = _interopRequireDefault(require("./remote"));

  _remote = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _remoteResolver() {
  const data = _interopRequireDefault(require("./remote-resolver/remote-resolver"));

  _remoteResolver = function () {
    return data;
  };

  return data;
}

function _globalRemotes() {
  const data = _interopRequireDefault(require("../global-config/global-remotes"));

  _globalRemotes = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

class Remotes extends Map {
  constructor(remotes = []) {
    super(remotes);
  }

  validate() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    const primary = this.values.filter(remote => remote.primary);
    if (primary.length > 1) throw new (_exceptions().PrimaryOverloaded)();
    return this.forEach(remote => remote.validate());
  }

  resolve(scopeName, thisScope) {
    const remote = super.get(scopeName);
    if (remote) return Promise.resolve(remote); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return (0, _remoteResolver().default)(scopeName, thisScope).then(scopeHost => {
      return new (_remote().default)(scopeHost, scopeName);
    });
  }

  isHub(scope) {
    // if a scope is listed as a remote, it doesn't go to the hub
    return !this.get(scope);
  }

  fetch(ids, thisScope, withoutDeps = false, context) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      // TODO - Transfer the fetch logic into the ssh module,
      // in order to close the ssh connection in the end of the multifetch instead of one fetch
      const groupedIds = _this._groupByScopeName(ids);

      const promises = [];
      (0, _utils().forEach)(groupedIds, (scopeIds, scopeName) => {
        promises.push( // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        _this.resolve(scopeName, thisScope).then(remote => remote.fetch(_bitId().BitIds.fromArray(scopeIds), withoutDeps, context)));
      });

      _logger().default.debug(`[-] Running fetch (withoutDeps: ${withoutDeps.toString()}) on a remote`);

      const bits = yield Promise.all(promises);

      _logger().default.debug('[-] Returning from a remote');

      return (0, _utils().flatten)(bits);
    })();
  }

  latestVersions(ids, thisScope) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      const groupedIds = _this2._groupByScopeName(ids);

      const promises = [];
      (0, _utils().forEach)(groupedIds, (scopeIds, scopeName) => {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        promises.push(_this2.resolve(scopeName, thisScope).then(remote => remote.latestVersions(scopeIds)));
      });
      const components = yield Promise.all(promises);
      const flattenComponents = (0, _utils().flatten)(components);
      return flattenComponents.map(componentId => _bitId().BitId.parse(componentId, true));
    })();
  }
  /**
   * returns scope graphs of the given bit-ids.
   * it is possible to improve it by returning only the connected-graph of the given id and not the
   * entire scope graph. however, when asking for multiple ids in the same scope, which is more
   * likely to happen, it'll harm the performance.
   */


  scopeGraphs(ids, thisScope) {
    var _this3 = this;

    return (0, _bluebird().coroutine)(function* () {
      const groupedIds = _this3._groupByScopeName(ids);

      const graphsP = Object.keys(groupedIds).map(
      /*#__PURE__*/
      function () {
        var _ref = (0, _bluebird().coroutine)(function* (scopeName) {
          const remote = yield _this3.resolve(scopeName, thisScope);
          const dependencyGraph = yield remote.graph();
          dependencyGraph.setScopeName(scopeName);
          return dependencyGraph;
        });

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }());
      return Promise.all(graphsP);
    })();
  }

  _groupByScopeName(ids) {
    const byScope = (0, _ramda().groupBy)((0, _ramda().prop)('scope'));
    return byScope(ids);
  }

  toPlainObject() {
    const object = {};
    this.forEach(remote => {
      let name = remote.name;
      if (remote.primary) name = (0, _utils().prependBang)(remote.name);
      object[name] = remote.host;
    });
    return object;
  }

  static getScopeRemote(scopeName) {
    return Remotes.getGlobalRemotes().then(remotes => remotes.resolve(scopeName));
  }

  static getGlobalRemotes() {
    return _globalRemotes().default.load().then(globalRemotes => globalRemotes.toPlainObject()).then(remotes => Remotes.load(remotes));
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  static load(remotes) {
    const models = [];
    if (!remotes) return new Remotes();
    (0, _utils().forEach)(remotes, (name, host) => {
      const remote = _remote().default.load(name, host); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      models.push([remote.name, remote]);
    });
    return new Remotes(models);
  }

}

exports.default = Remotes;