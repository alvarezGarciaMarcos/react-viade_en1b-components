"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _chai() {
  const data = require("chai");

  _chai = function () {
    return data;
  };

  return data;
}

function _() {
  const data = _interopRequireDefault(require("./"));

  _ = function () {
    return data;
  };

  return data;
}

const fixtures = path().join(__dirname, '../../..', 'fixtures', 'jsdoc');
describe('JSDoc Parser', () => {
  describe('parse()', () => {
    describe('Function Declaration', function () {
      let doclet;
      before(
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        const functionDeclarationFile = path().join(fixtures, 'functionDeclaration.js');

        const functionDeclaration = _fsExtra().default.readFileSync(functionDeclarationFile).toString();

        const doclets = yield (0, _().default)(functionDeclaration);
        (0, _chai().expect)(doclets).to.be.a('array');
        (0, _chai().expect)(doclets).to.have.lengthOf(1);
        doclet = doclets[0];
      }));
      it('should have all the proper keys', () => {
        (0, _chai().expect)(doclet).to.include.keys('name', 'description', 'returns', 'args', 'access', 'examples', 'static');
      });
      it('should extract the correct name', () => {
        (0, _chai().expect)(doclet.name).to.equal('add');
      });
      it('should extract the correct description', () => {
        (0, _chai().expect)(doclet.description).to.equal('Adds two numbers.');
      });
      it('should extract the correct args', () => {
        const args = doclet.args;
        (0, _chai().expect)(args).to.be.a('array');
        (0, _chai().expect)(args).to.have.lengthOf(2);

        for (const arg of args) {
          (0, _chai().expect)(arg).to.include.keys('name', 'type', 'description');
        }

        (0, _chai().expect)(args[0].name).to.equal('a');
        (0, _chai().expect)(args[1].name).to.equal('b');
        (0, _chai().expect)(args[0].description).to.equal('The first number in an addition.');
        (0, _chai().expect)(args[1].description).to.equal('The second number in an addition.');
        (0, _chai().expect)(args[0].type).to.equal('number');
        (0, _chai().expect)(args[1].type).to.equal('number');
      });
      it('should extract the correct returns', () => {
        (0, _chai().expect)(doclet.returns).to.include.keys('type', 'description');
        (0, _chai().expect)(doclet.returns.description).to.equal('Returns the total.');
        (0, _chai().expect)(doclet.returns.type).to.equal('number');
      });
      it('should extract the correct access from the @public annotation', () => {
        (0, _chai().expect)(doclet.access).to.equal('public');
      });
      it('should extract the static attribute from the @static annotation', () => {
        (0, _chai().expect)(doclet.static).to.be.true;
      });
    });
    describe('Invalid code', () => {
      it('should returns an empty array',
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        const doclets = yield (0, _().default)('this is an invalid code');
        (0, _chai().expect)(doclets).to.be.a('array');
        (0, _chai().expect)(doclets).to.have.lengthOf(0);
      }));
    });
    describe('Doc ending with more than one star', () => {
      let doclets;
      before(
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        const file = path().join(fixtures, 'endWithTwoStars.js');
        doclets = yield (0, _().default)(_fsExtra().default.readFileSync(file).toString());
        (0, _chai().expect)(doclets).to.be.an('array');
      }));
      it('should parse the doc and not hang due to catastrophic backtracking', () => {
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('description').that.is.equal('Basic accordion component');
      });
    });
    describe('Method Declaration and Class Declaration', () => {
      let doclets;
      before(
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        const methodDeclarationFile = path().join(fixtures, 'methodDeclaration.js');

        const methodDeclaration = _fsExtra().default.readFileSync(methodDeclarationFile).toString();

        doclets = yield (0, _().default)(methodDeclaration);
      }));
      it('should be a populated array', () => {
        (0, _chai().expect)(doclets).to.be.an('array');
        (0, _chai().expect)(doclets).to.have.length.of.at.least(2);
      });
      xit('should recognize the Class Declaration first', () => {
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.all.keys('name', 'description');
        (0, _chai().expect)(doclet.name).to.equal('Point');
        (0, _chai().expect)(doclet.description).to.equal('Class representing a point.');
      });
      it('should recognize the constructor', () => {
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('name').that.equals('constructor');
        (0, _chai().expect)(doclet).to.have.property('description').that.equals('Create a point.');
        (0, _chai().expect)(doclet).to.have.property('access').that.equals('public');
        (0, _chai().expect)(doclet).to.have.property('static').that.is.false;
        (0, _chai().expect)(doclet).to.have.property('returns').that.is.an('object').that.is.empty;
        (0, _chai().expect)(doclet).to.have.property('examples').that.is.an('array').that.is.empty;
      });
      it("should extract the constructor's args correctly", () => {
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('args').that.is.an('array').with.lengthOf(2);
        const args = doclet.args;

        for (const arg of args) {
          (0, _chai().expect)(arg).to.include.keys('name', 'type', 'description');
          (0, _chai().expect)(arg.type).to.equal('number');
        }

        (0, _chai().expect)(args[0].name).to.equal('x');
        (0, _chai().expect)(args[1].name).to.equal('y');
        (0, _chai().expect)(args[0].description).to.equal('The x value.');
        (0, _chai().expect)(args[1].description).to.equal('The y value.');
      });
      it('should recognize the getX method', () => {
        const doclet = doclets[1];
        (0, _chai().expect)(doclet).to.have.property('name').that.equals('getX');
        (0, _chai().expect)(doclet).to.have.property('description').that.equals('Get the x value.');
        (0, _chai().expect)(doclet).to.have.property('access').that.equals('public');
        (0, _chai().expect)(doclet).to.have.property('static').that.is.false;
        (0, _chai().expect)(doclet).to.have.property('returns').that.is.an('object').that.is.not.empty;
        (0, _chai().expect)(doclet).to.have.property('examples').that.is.an('array').that.is.empty;
        (0, _chai().expect)(doclet).to.have.property('args').that.is.an('array').that.is.empty;
      });
      it('should recognize the getY method', () => {
        const doclet = doclets[2];
        (0, _chai().expect)(doclet).to.have.property('name').that.equals('getY');
        (0, _chai().expect)(doclet).to.have.property('description').that.equals('Get the y value.');
      });
      it('should recognize the fromString method as the last doclet', function () {
        this.timeout(0);
        const doclet = doclets[doclets.length - 1];
        (0, _chai().expect)(doclet).to.have.property('name').that.equals('fromString');
        (0, _chai().expect)(doclet).to.have.property('description').that.equals('Convert a string containing two comma-separated numbers into a point.');
      });
    });
    describe('Variable Declaration', () => {
      let doclets;
      before(
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        const variableDeclarationFile = path().join(fixtures, 'variableDeclaration.js');

        const variableDeclaration = _fsExtra().default.readFileSync(variableDeclarationFile).toString();

        doclets = yield (0, _().default)(variableDeclaration);
      }));
      it('should be an array of one Doclet', () => {
        (0, _chai().expect)(doclets).to.be.an('array').and.to.have.lengthOf(1);
      });
      it('should parse the doc correctly', () => {
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('name').that.equals('add');
        (0, _chai().expect)(doclet).to.have.property('description').that.equals('Adds two numbers.');
        (0, _chai().expect)(doclet).to.have.property('access').that.equals('public');
        (0, _chai().expect)(doclet).to.have.property('static').that.is.false;
        (0, _chai().expect)(doclet).to.have.property('returns').that.is.an('object').that.is.not.empty;
        (0, _chai().expect)(doclet).to.have.property('examples').that.is.an('array').that.is.not.empty;
        (0, _chai().expect)(doclet).to.have.property('args').that.is.an('array').that.have.lengthOf(2);
      });
    });
    describe('Various Param Types', () => {
      let args;
      before(
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        const file = path().join(fixtures, 'variousParamTypes.js');
        const doclets = yield (0, _().default)(_fsExtra().default.readFileSync(file).toString());
        (0, _chai().expect)(doclets).to.be.an('array').and.to.have.lengthOf(1);
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('args').that.is.an('array').that.is.not.empty;
        args = doclet.args;
      }));
      it('should recognize "*" as "*"', () => {
        const anyArg = args.find(arg => arg.name === 'anyType');
        (0, _chai().expect)(anyArg.type).to.equal('*');
      });
      it('should recognize "[]" as "[]"', () => {
        const anyArg = args.find(arg => arg.name === 'arrayType');
        (0, _chai().expect)(anyArg.type).to.equal('[]');
      });
      it('should recognize Union type correctly', () => {
        const anyArg = args.find(arg => arg.name === 'unionType');
        (0, _chai().expect)(anyArg.type).to.equal('(number | [])');
      });
      it('should recognize custom type correctly', () => {
        const anyArg = args.find(arg => arg.name === 'myCustomType');
        (0, _chai().expect)(anyArg.type).to.equal('CustomType');
      });
      it('should recognize Object type', () => {
        const anyArg = args.find(arg => arg.name === 'objectType');
        (0, _chai().expect)(anyArg.type).to.equal('Object');
      });
      it('should recognize Function type', () => {
        const anyArg = args.find(arg => arg.name === 'functionType');
        (0, _chai().expect)(anyArg.type).to.equal('Function');
      });
      it('should recognize Array of one type', () => {
        const anyArg = args.find(arg => arg.name === 'arrayOfType');
        (0, _chai().expect)(anyArg.type).to.equal('Array<string>');
      });
      it('should recognize Array of union', () => {
        const anyArg = args.find(arg => arg.name === 'arrayOfUnion');
        (0, _chai().expect)(anyArg.type).to.equal('Array<(number | Object)>');
      });
      it('should recognize Optional Parameter', () => {
        const anyArg = args.find(arg => arg.name === 'optionalParameter');
        (0, _chai().expect)(anyArg.type).to.equal('string?');
      });
      it('should recognize Optional Parameter with Default Value', () => {
        const anyArg = args.find(arg => arg.name === 'optionalParameterWithDefaultValue');
        (0, _chai().expect)(anyArg.type).to.equal('string?');
        (0, _chai().expect)(anyArg.default).to.equal('value');
      });
    });
    describe('Flow Type File', () => {
      it('should parse the file with no errors',
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        const file = path().join(fixtures, 'flowTypeFile.js');
        const doclets = yield (0, _().default)(_fsExtra().default.readFileSync(file).toString());
        (0, _chai().expect)(doclets).to.be.an('array').and.to.have.lengthOf(1);
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('name').that.equals('first');
        (0, _chai().expect)(doclet).to.have.property('description').that.equals('returns the first element of an array reference.');
        (0, _chai().expect)(doclet).to.have.property('access').that.equals('public');
        (0, _chai().expect)(doclet).to.have.property('static').that.is.false;
        (0, _chai().expect)(doclet).to.have.property('returns').that.is.an('object').that.is.not.empty;
        (0, _chai().expect)(doclet).to.have.property('examples').that.is.an('array').that.is.not.empty;
        (0, _chai().expect)(doclet).to.have.property('args').that.is.an('array').that.is.not.empty;
      }));
    });
    describe('Description Tag', () => {
      let doclets;
      before(
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        const file = path().join(fixtures, 'descriptionTag.js');
        doclets = yield (0, _().default)(_fsExtra().default.readFileSync(file).toString());
        (0, _chai().expect)(doclets).to.be.an('array').and.to.have.lengthOf(3);
      }));
      it('should ignore an invalid description', () => {
        const doclet = doclets[0];
        (0, _chai().expect)(doclet.name).to.equal('invalidDescription');
        (0, _chai().expect)(doclet.description).to.equal('');
      });
      it('should recognize the description tag', () => {
        const doclet = doclets[1];
        (0, _chai().expect)(doclet.name).to.equal('descriptionTag');
        (0, _chai().expect)(doclet.description).to.equal('Adds two numbers.');
      });
      it('should recognize the synonym "desc"', () => {
        const doclet = doclets[2];
        (0, _chai().expect)(doclet.name).to.equal('descTag');
        (0, _chai().expect)(doclet.description).to.equal('Adds two numbers.');
      });
    });
    describe('Access property', () => {
      let doclets;
      before(
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        const file = path().join(fixtures, 'misc.js');
        doclets = yield (0, _().default)(_fsExtra().default.readFileSync(file).toString());
        (0, _chai().expect)(doclets).to.be.an('array');
      }));
      it('should find only public functions', () => {
        (0, _chai().expect)(doclets.find(doclet => doclet.name === 'publicFunc')).not.to.be.undefined;
        (0, _chai().expect)(doclets.find(doclet => doclet.name === 'privateFunc')).to.be.undefined;
      });
    });
    describe('Properties property', () => {
      let doclets;
      before(
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        const file = path().join(fixtures, 'properties.js');
        doclets = yield (0, _().default)(_fsExtra().default.readFileSync(file).toString());
        (0, _chai().expect)(doclets).to.be.an('array');
      }));
      it('should parse the property tag correctly', () => {
        const doclet = doclets[0];
        (0, _chai().expect)(doclet).to.have.property('properties').that.is.an('array').that.have.lengthOf(5);
        (0, _chai().expect)(doclet.properties[0].name).to.equal('defaults');
        (0, _chai().expect)(doclet.properties[0].type).to.equal('object');
        (0, _chai().expect)(doclet.properties[0].description).to.equal('The default values for parties.');
      });
    });
  });
});