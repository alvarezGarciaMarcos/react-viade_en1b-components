"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _config() {
  const data = _interopRequireDefault(require("../config"));

  _config = function () {
    return data;
  };

  return data;
}

function _removeEmptyDir() {
  const data = _interopRequireDefault(require("../../utils/fs/remove-empty-dir"));

  _removeEmptyDir = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

/**
 * the opposite of 'eject-conf'.
 * delete configuration files on the fs.
 */
var _default =
/*#__PURE__*/
function () {
  var _injectConf = (0, _bluebird().coroutine)(function* (component, consumerPath, bitMap, configDir, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  force = false) {
    const componentMap = component.componentMap;

    if (!componentMap) {
      throw new (_showDoctorError().default)('could not find component in the .bitmap file');
    }

    const componentDir = componentMap.getComponentDir();

    if (!force && areEnvsModified(component, component.componentFromModel)) {
      throw new (_generalError().default)('unable to inject-conf, some or all configuration files are modified. please use "--force" flag to force removing the configuration files');
    } // Passing here the ENV_TYPE as well to make sure it's not removed since we need it later


    const resolvedConfigDir = configDir.getResolved({
      componentDir
    });
    const deleteCompilerFilesP = component.compiler ? component.compiler.removeFilesFromFs(component.compilerDependencies, configDir, _constants().COMPILER_ENV_TYPE, consumerPath) : Promise.resolve('');
    const deleteTesterFilesP = component.tester ? component.tester.removeFilesFromFs(component.testerDependencies, configDir, _constants().TESTER_ENV_TYPE, consumerPath) : Promise.resolve(''); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    yield Promise.all([deleteCompilerFilesP, deleteTesterFilesP]); // Delete bit.json and bit.json dir

    const bitJsonDir = resolvedConfigDir.getEnvTypeCleaned();
    const bitJsonDirFullPath = path().normalize(path().join(consumerPath, bitJsonDir.dirPath));
    yield _config().default.removeIfExist(bitJsonDirFullPath);
    yield (0, _removeEmptyDir().default)(bitJsonDirFullPath);
    return {
      id: component.id.toStringWithoutVersion()
    };
  });

  function injectConf(_x, _x2, _x3, _x4) {
    return _injectConf.apply(this, arguments);
  }

  return injectConf;
}();
/**
 * returns whether the envs configuration files were modified on the filesystem
 */


exports.default = _default;

function areEnvsModified(componentFromFs, componentFromModel) {
  if (!componentFromModel) return false;
  const envTypes = [_constants().COMPILER_ENV_TYPE, _constants().TESTER_ENV_TYPE];
  return envTypes.some(envType => {
    const fsHashes = // $FlowFixMe
    componentFromFs[envType] && componentFromFs[envType].files ? componentFromFs[envType].files.map(file => file.toSourceAsLinuxEOL().hash()).sort() : [];
    const modelHashes = // $FlowFixMe
    componentFromModel[envType] && componentFromModel[envType].files ? componentFromModel[envType].files.map(file => file.file.hash()).sort() : [];
    return !_ramda().default.equals(fsHashes, modelHashes);
  });
}