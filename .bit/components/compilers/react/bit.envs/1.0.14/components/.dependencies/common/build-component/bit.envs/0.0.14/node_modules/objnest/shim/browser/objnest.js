/**
 * @class Objnest
 * @param {object} config
 */
'use strict';

var _typeof2 = require('babel-runtime/helpers/typeof');

var _typeof3 = _interopRequireDefault(_typeof2);

var _keys = require('babel-runtime/core-js/object/keys');

var _keys2 = _interopRequireDefault(_keys);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var extend = require('extend');
var abind = require('abind');
var isArrayKey = require('./key/is_array_key');
var fromArrayKey = require('./key/from_array_key');
var toArrayKey = require('./key/to_array_key');

/** @lends Objnest */
function Objnest(config) {
  var s = this;
  extend(s, config || {});
  abind(s);
}

Objnest.prototype = {
  separator: '.',
  /**
   * @function expand
   * @param {object} object - Obj to flatten
   * @returns {object} Flatten obj.
   * @example
   *  let obj = objnest.expand({
   *      'foo.bar': 'baz'
   *  })
   *  console.log(obj) // => {foo: {bar: 'baz'}}
   */
  expand: function expand(object) {
    var s = this;
    if (Array.isArray(object)) {
      return object.map(function (object) {
        return s.expand(object);
      });
    }
    var separator = s.separator;
    var result = {};
    (0, _keys2.default)(object).forEach(function (key) {
      var val = object[key];
      var needsSeparate = !!~key.indexOf(separator);
      if (needsSeparate) {
        var subKeys = key.split(separator);
        var subObj = {};
        var thisKey = subKeys.shift();
        subObj[subKeys.join('.')] = val;
        var subExpandedObj = s.expand(subObj);
        var thisVal = result[thisKey];
        val = s._merge(thisVal, subExpandedObj);
        key = thisKey;
      }
      if (isArrayKey(key)) {
        var arrayKey = fromArrayKey(key);
        result[arrayKey.name] = result[arrayKey.name] || [];
        result[arrayKey.name][arrayKey.index] = s._merge(result[arrayKey.name][arrayKey.index], val);
      } else {
        result[key] = val;
      }
    });
    return result;
  },

  /**
   * Flatten nested object.
   * @param {object} nested - Object to flatten.
   * @returns {object} - Flattened object.
   * @example
   *  let flattened = objnest.flatten({
   *      'foo': {'bar': 'baz'}
   *  })
   *  console.log(flattened) // => {'foo.bar': 'baz'}
   */
  flatten: function flatten(nested) {
    var s = this;
    if (typeof nested === 'string') {
      return nested;
    }
    var separator = s.separator;
    var flattened = {};
    (0, _keys2.default)(nested || {}).forEach(function (key) {
      var value = nested[key];

      (function () {
        switch (typeof value === 'undefined' ? 'undefined' : (0, _typeof3.default)(value)) {
          case 'string':
          case 'number':
          case 'boolean':
          case 'function':
            flattened[key] = value;
            break;
          default:
            var subValues = s.flatten(value);
            (0, _keys2.default)(subValues).forEach(function (subKey) {
              var fullKey = void 0;
              if (Array.isArray(value)) {
                fullKey = key + toArrayKey(subKey);
              } else {
                fullKey = [key, subKey].join(separator);
              }
              flattened[fullKey] = subValues[subKey];
            });
            break;
        }
      })();
    });
    return flattened;
  },
  _merge: function _merge(v1, v2) {
    if (typeof v1 === 'undefined') {
      return v2;
    }
    if (typeof v2 === 'undefined') {
      return v1;
    }
    return extend(true, v1, v2 || {});
  }
};

module.exports = Objnest;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm9iam5lc3QuanMiXSwibmFtZXMiOlsiZXh0ZW5kIiwicmVxdWlyZSIsImFiaW5kIiwiaXNBcnJheUtleSIsImZyb21BcnJheUtleSIsInRvQXJyYXlLZXkiLCJPYmpuZXN0IiwiY29uZmlnIiwicyIsInByb3RvdHlwZSIsInNlcGFyYXRvciIsImV4cGFuZCIsIm9iamVjdCIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInJlc3VsdCIsImZvckVhY2giLCJrZXkiLCJ2YWwiLCJuZWVkc1NlcGFyYXRlIiwiaW5kZXhPZiIsInN1YktleXMiLCJzcGxpdCIsInN1Yk9iaiIsInRoaXNLZXkiLCJzaGlmdCIsImpvaW4iLCJzdWJFeHBhbmRlZE9iaiIsInRoaXNWYWwiLCJfbWVyZ2UiLCJhcnJheUtleSIsIm5hbWUiLCJpbmRleCIsImZsYXR0ZW4iLCJuZXN0ZWQiLCJmbGF0dGVuZWQiLCJ2YWx1ZSIsInN1YlZhbHVlcyIsInN1YktleSIsImZ1bGxLZXkiLCJ2MSIsInYyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFJQTs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTUEsU0FBU0MsUUFBUSxRQUFSLENBQWY7QUFDQSxJQUFNQyxRQUFRRCxRQUFRLE9BQVIsQ0FBZDtBQUNBLElBQU1FLGFBQWFGLFFBQVEsb0JBQVIsQ0FBbkI7QUFDQSxJQUFNRyxlQUFlSCxRQUFRLHNCQUFSLENBQXJCO0FBQ0EsSUFBTUksYUFBYUosUUFBUSxvQkFBUixDQUFuQjs7QUFFQTtBQUNBLFNBQVNLLE9BQVQsQ0FBa0JDLE1BQWxCLEVBQTBCO0FBQ3hCLE1BQUlDLElBQUksSUFBUjtBQUNBUixTQUFPUSxDQUFQLEVBQVVELFVBQVUsRUFBcEI7QUFDQUwsUUFBTU0sQ0FBTjtBQUNEOztBQUVERixRQUFRRyxTQUFSLEdBQW9CO0FBQ2xCQyxhQUFXLEdBRE87QUFFbEI7Ozs7Ozs7Ozs7QUFVQUMsUUFaa0Isa0JBWVZDLE1BWlUsRUFZRjtBQUNkLFFBQUlKLElBQUksSUFB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QUFsQko7QUFGeUM7QUFzQjFDLEtBdEJEO0FBdUJBLFdBQU9ILFNBQVA7QUFDRCxHQXRGaUI7QUF1RmxCTixRQXZGa0Isa0JBdUZWVyxFQXZGVSxFQXVGTkMsRUF2Rk0sRUF1RkY7QUFDZCxRQUFJLE9BQU9ELEVBQVAsS0FBYyxXQUFsQixFQUErQjtBQUM3QixhQUFPQyxFQUFQO0FBQ0Q7QUFDRCxRQUFJLE9BQU9BLEVBQVAsS0FBYyxXQUFsQixFQUErQjtBQUM3QixhQUFPRCxFQUFQO0FBQ0Q7QUFDRCxXQUFPekMsT0FBTyxJQUFQLEVBQWF5QyxFQUFiLEVBQWlCQyxNQUFNLEVBQXZCLENBQVA7QUFDRDtBQS9GaUIsQ0FBcEI7O0FBa0dBQyxPQUFPQyxPQUFQLEdBQWlCdEMsT0FBakIiLCJmaWxlIjoib2JqbmVzdC5qcyIsInNvdXJjZVJvb3QiOiJsaWIiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBjbGFzcyBPYmpuZXN0XG4gKiBAcGFyYW0ge29iamVjdH0gY29uZmlnXG4gKi9cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQnKVxuY29uc3QgYWJpbmQgPSByZXF1aXJlKCdhYmluZCcpXG5jb25zdCBpc0FycmF5S2V5ID0gcmVxdWlyZSgnLi9rZXkvaXNfYXJyYXlfa2V5JylcbmNvbnN0IGZyb21BcnJheUtleSA9IHJlcXVpcmUoJy4va2V5L2Zyb21fYXJyYXlfa2V5JylcbmNvbnN0IHRvQXJyYXlLZXkgPSByZXF1aXJlKCcuL2tleS90b19hcnJheV9rZXknKVxuXG4vKiogQGxlbmRzIE9iam5lc3QgKi9cbmZ1bmN0aW9uIE9iam5lc3QgKGNvbmZpZykge1xuICBsZXQgcyA9IHRoaXNcbiAgZXh0ZW5kKHMsIGNvbmZpZyB8fCB7fSlcbiAgYWJpbmQocylcbn1cblxuT2JqbmVzdC5wcm90b3R5cGUgPSB7XG4gIHNlcGFyYXRvcjogJy4nLFxuICAvKipcbiAgICogQGZ1bmN0aW9uIGV4cGFuZFxuICAgKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0IC0gT2JqIHRvIGZsYXR0ZW5cbiAgICogQHJldHVybnMge29iamVjdH0gRmxhdHRlbiBvYmouXG4gICAqIEBleGFtcGxlXG4gICAqICBsZXQgb2JqID0gb2JqbmVzdC5leHBhbmQoe1xuICAgKiAgICAgICdmb28uYmFyJzogJ2JheidcbiAgICogIH0pXG4gICAqICBjb25zb2xlLmxvZyhvYmopIC8vID0+IHtmb286IHtiYXI6ICdiYXonfX1cbiAgICovXG4gIGV4cGFuZCAob2JqZWN0KSB7XG4gICAgbGV0IHMgPSB0aGlzXG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgcmV0dXJuIG9iamVjdC5tYXAoKG9iamVjdCkgPT4gcy5leHBhbmQob2JqZWN0KSlcbiAgICB9XG4gICAgbGV0IHNlcGFyYXRvciA9IHMuc2VwYXJhdG9yXG4gICAgbGV0IHJlc3VsdCA9IHt9XG4gICAgT2JqZWN0LmtleXMob2JqZWN0KS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgIGxldCB2YWwgPSBvYmplY3RbIGtleSBdXG4gICAgICBsZXQgbmVlZHNTZXBhcmF0ZSA9ICEhfmtleS5pbmRleE9mKHNlcGFyYXRvcilcbiAgICAgIGlmIChuZWVkc1NlcGFyYXRlKSB7XG4gICAgICAgIGxldCBzdWJLZXlzID0ga2V5LnNwbGl0KHNlcGFyYXRvcilcbiAgICAgICAgbGV0IHN1Yk9iaiA9IHt9XG4gICAgICAgIGxldCB0aGlzS2V5ID0gc3ViS2V5cy5zaGlmdCgpXG4gICAgICAgIHN1Yk9ialsgc3ViS2V5cy5qb2luKCcuJykgXSA9IHZhbFxuICAgICAgICBsZXQgc3ViRXhwYW5kZWRPYmogPSBzLmV4cGFuZChzdWJPYmopXG4gICAgICAgIGxldCB0aGlzVmFsID0gcmVzdWx0WyB0aGlzS2V5IF1cbiAgICAgICAgdmFsID0gcy5fbWVyZ2UodGhpc1ZhbCwgc3ViRXhwYW5kZWRPYmopXG4gICAgICAgIGtleSA9IHRoaXNLZXlcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5S2V5KGtleSkpIHtcbiAgICAgICAgbGV0IGFycmF5S2V5ID0gZnJvbUFycmF5S2V5KGtleSlcbiAgICAgICAgcmVzdWx0WyBhcnJheUtleS5uYW1lIF0gPSByZXN1bHRbIGFycmF5S2V5Lm5hbWUgXSB8fCBbXVxuICAgICAgICByZXN1bHRbIGFycmF5S2V5Lm5hbWUgXVsgYXJyYXlLZXkuaW5kZXggXSA9IHMuX21lcmdlKFxuICAgICAgICAgIHJlc3VsdFsgYXJyYXlLZXkubmFtZSBdWyBhcnJheUtleS5pbmRleCBdLFxuICAgICAgICAgIHZhbFxuICAgICAgICApXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbIGtleSBdID0gdmFsXG4gICAgICB9XG4gICAgfSlcbiAgICByZXR1cm4gcmVzdWx0XG4gIH0sXG4gIC8qKlxuICAgKiBGbGF0dGVuIG5lc3RlZCBvYmplY3QuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXN0ZWQgLSBPYmplY3QgdG8gZmxhdHRlbi5cbiAgICogQHJldHVybnMge29iamVjdH0gLSBGbGF0dGVuZWQgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKiAgbGV0IGZsYXR0ZW5lZCA9IG9iam5lc3QuZmxhdHRlbih7XG4gICAqICAgICAgJ2Zvbyc6IHsnYmFyJzogJ2Jheid9XG4gICAqICB9KVxuICAgKiAgY29uc29sZS5sb2coZmxhdHRlbmVkKSAvLyA9PiB7J2Zvby5iYXInOiAnYmF6J31cbiAgICovXG4gIGZsYXR0ZW4gKG5lc3RlZCkge1xuICAgIGxldCBzID0gdGhpc1xuICAgIGlmICh0eXBlb2YgbmVzdGVkID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuIG5lc3RlZFxuICAgIH1cbiAgICBsZXQgc2VwYXJhdG9yID0gcy5zZXBhcmF0b3JcbiAgICBsZXQgZmxhdHRlbmVkID0ge31cbiAgICBPYmplY3Qua2V5cyhuZXN0ZWQgfHwge30pLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgbGV0IHZhbHVlID0gbmVzdGVkWyBrZXkgXVxuICAgICAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ2Z1bmN0aW9uJzpcbiAgICAgICAgICBmbGF0dGVuZWRbIGtleSBdID0gdmFsdWVcbiAgICAgICAgICBicmVha1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGxldCBzdWJWYWx1ZXMgPSBzLmZsYXR0ZW4odmFsdWUpXG4gICAgICAgICAgT2JqZWN0LmtleXMoc3ViVmFsdWVzKS5mb3JFYWNoKChzdWJLZXkpID0+IHtcbiAgICAgICAgICAgIGxldCBmdWxsS2V5XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgZnVsbEtleSA9IGtleSArIHRvQXJyYXlLZXkoc3ViS2V5KVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZnVsbEtleSA9IFsga2V5LCBzdWJLZXkgXS5qb2luKHNlcGFyYXRvcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZsYXR0ZW5lZFsgZnVsbEtleSBdID0gc3ViVmFsdWVzWyBzdWJLZXkgXVxuICAgICAgICAgIH0pXG4gICAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9KVxuICAgIHJldHVybiBmbGF0dGVuZWRcbiAgfSxcbiAgX21lcmdlICh2MSwgdjIpIHtcbiAgICBpZiAodHlwZW9mIHYxID09PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIHYyXG4gICAgfVxuICAgIGlmICh0eXBlb2YgdjIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdjFcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZCh0cnVlLCB2MSwgdjIgfHwge30pXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBPYmpuZXN0XG4iXX0=