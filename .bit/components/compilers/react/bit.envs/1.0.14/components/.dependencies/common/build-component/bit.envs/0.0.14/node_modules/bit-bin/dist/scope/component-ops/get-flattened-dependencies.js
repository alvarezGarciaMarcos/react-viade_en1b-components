"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getAllFlattenedDependencies = getAllFlattenedDependencies;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _graphlib() {
  const data = _interopRequireDefault(require("graphlib"));

  _graphlib = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("../exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _flattenDependencies() {
  const data = require("../flatten-dependencies");

  _flattenDependencies = function () {
    return data;
  };

  return data;
}

function _scopeComponentsImporter() {
  const data = _interopRequireDefault(require("./scope-components-importer"));

  _scopeComponentsImporter = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

// eslint-disable-next-line
function getAllFlattenedDependencies(_x, _x2, _x3, _x4, _x5) {
  return _getAllFlattenedDependencies.apply(this, arguments);
}

function _getAllFlattenedDependencies() {
  _getAllFlattenedDependencies = (0, _bluebird().coroutine)(function* (scope, componentId, allDependenciesGraphs, cache, notFoundDependencies) {
    const {
      graphDeps,
      graphDevDeps,
      graphCompilerDeps,
      graphTesterDeps
    } = allDependenciesGraphs;
    const params = {
      scope,
      componentId,
      cache,
      notFoundDependencies
    };
    const flattenedDependencies = yield getFlattenedDependencies(_objectSpread({}, params, {
      graph: graphDeps
    }));
    const flattenedDevDependencies = yield getFlattenedDependencies(_objectSpread({}, params, {
      graph: graphDevDeps,
      prodGraph: graphDeps
    }));
    const flattenedCompilerDependencies = yield getFlattenedDependencies(_objectSpread({}, params, {
      graph: graphCompilerDeps,
      prodGraph: graphDeps
    }));
    const flattenedTesterDependencies = yield getFlattenedDependencies(_objectSpread({}, params, {
      graph: graphTesterDeps,
      prodGraph: graphDeps
    }));
    return {
      flattenedDependencies,
      flattenedDevDependencies,
      flattenedCompilerDependencies,
      flattenedTesterDependencies
    };
  });
  return _getAllFlattenedDependencies.apply(this, arguments);
}

function getFlattenedDependencies(_x6) {
  return _getFlattenedDependencies.apply(this, arguments);
}

function _getFlattenedDependencies() {
  _getFlattenedDependencies = (0, _bluebird().coroutine)(function* ({
    scope,
    componentId,
    graph,
    cache,
    notFoundDependencies,
    prodGraph
  }) {
    const id = componentId.toString();
    const edges = getEdges(graph, id);
    if (!edges) return new (_bitId().BitIds)();
    const dependencies = getEdgesWithProdGraph(prodGraph, edges);
    if (!dependencies.length) return new (_bitId().BitIds)();

    const flattenDependency =
    /*#__PURE__*/
    function () {
      var _ref = (0, _bluebird().coroutine)(function* (dependency) {
        if (cache[dependency]) return cache[dependency]; // @ts-ignore if graph doesn't have the node, prodGraph must have it

        const dependencyBitId = graph.node(dependency) || prodGraph.node(dependency);
        let versionDependencies;
        if (notFoundDependencies.has(dependencyBitId)) return [dependencyBitId];

        const scopeComponentsImporter = _scopeComponentsImporter().default.getInstance(scope);

        try {
          versionDependencies = yield scopeComponentsImporter.importDependencies(_bitId().BitIds.fromArray([dependencyBitId]));
        } catch (err) {
          if (err instanceof _exceptions().DependencyNotFound) {
            notFoundDependencies.push(dependencyBitId);
            throwWhenDepNotIncluded(componentId, dependencyBitId);
            return [dependencyBitId];
          }

          throw err;
        }

        const flattenedDependencies = yield (0, _flattenDependencies().flattenDependencyIds)(versionDependencies, scope.objects); // Store the flatten dependencies in cache

        cache[dependency] = flattenedDependencies;
        return flattenedDependencies;
      });

      return function flattenDependency(_x7) {
        return _ref.apply(this, arguments);
      };
    }();

    const flattened = yield (0, _pMapSeries().default)(dependencies, flattenDependency);

    const flattenedUnique = _bitId().BitIds.uniqFromArray(_ramda().default.flatten(flattened)); // when a component has cycle dependencies, the flattenedDependencies contains the component itself. remove it.


    return flattenedUnique.removeIfExistWithoutVersion(componentId);
  });
  return _getFlattenedDependencies.apply(this, arguments);
}

function throwWhenDepNotIncluded(componentId, dependencyId) {
  if (!dependencyId.hasScope() && !dependencyId.hasVersion()) {
    throw new (_generalError().default)(`fatal: "${componentId.toString()}" has a dependency "${dependencyId.toString()}".
this dependency was not included in the tag command.`);
  }
}

function getEdges(graph, id) {
  if (!graph.hasNode(id)) return null; // @ts-ignore

  const edges = _graphlib().default.alg.preorder(graph, id);

  return _ramda().default.tail(edges); // the first item is the component itself
}
/**
 * for non-prod files, such as test files, we're interested also with its prod dependency.
 * for example, a test file foo.spec.js of component 'foo', requires bar.js from component
 * 'bar'. 'bar.js' requires 'baz.js' from component 'baz'.
 * when calculating the edges of foo.spec.js by devGraph only, we'll get bar.js but not
 * baz.js because the relationship between bar and baz are set on prodGraph only.
 * @see dev-dependencies.e2e, 'dev-dependency that requires prod-dependency' case.
 */


function getEdgesWithProdGraph(prodGraph, dependencies) {
  if (!prodGraph) return dependencies;

  const prodDependencies = _ramda().default.flatten(dependencies.map(dependency => getEdges(prodGraph, dependency))).filter(x => x);

  return _ramda().default.uniq([...dependencies, ...prodDependencies]);
}