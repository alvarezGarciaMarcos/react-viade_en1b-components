"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _tmp() {
  const data = _interopRequireDefault(require("../../../scope/repositories/tmp"));

  _tmp = function () {
    return data;
  };

  return data;
}

function _mergeFiles() {
  const data = _interopRequireDefault(require("../../../utils/merge-files"));

  _mergeFiles = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

var _default =
/*#__PURE__*/
function () {
  var _twoWayMergeVersions = (0, _bluebird().coroutine)(function* ({
    consumer,
    otherComponent,
    otherVersion,
    currentComponent,
    currentVersion
  }) {
    const otherFiles = otherComponent.files;
    const currentFiles = currentComponent.files;
    const results = {
      addFiles: [],
      modifiedFiles: [],
      unModifiedFiles: [],
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      overrideFiles: [],
      hasConflicts: false
    };

    const getFileResult = (otherFile, currentFile) => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const filePath = (0, _utils().pathNormalizeToLinux)(otherFile.relative);

      if (!currentFile) {
        results.addFiles.push({
          filePath,
          otherFile
        });
        return;
      } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      const otherFileHash = (0, _utils().sha1)(otherFile.contents); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const currentFileHash = (0, _utils().sha1)(currentFile.contents);

      if (otherFileHash === currentFileHash) {
        results.unModifiedFiles.push({
          filePath,
          currentFile
        });
        return;
      } // it was changed in both, there is a chance for conflict
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      currentFile.version = currentVersion; // $FlowFixMe it's a hack to pass the data, version is not a valid attribute.
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      otherFile.version = otherVersion;
      results.modifiedFiles.push({
        filePath,
        currentFile,
        otherFile,
        output: null,
        conflict: null
      });
    };

    otherFiles.forEach(otherFile => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const currentFile = currentFiles.find(file => file.relative === otherFile.relative);
      getFileResult(otherFile, currentFile);
    });
    if (_ramda().default.isEmpty(results.modifiedFiles)) return results;
    const conflictResults = yield getMergeResults(consumer, results.modifiedFiles);
    conflictResults.forEach(conflictResult => {
      const modifiedFile = results.modifiedFiles.find(file => file.filePath === conflictResult.filePath);
      if (!modifiedFile) throw new (_generalError().default)(`unable to find ${conflictResult.filePath} in modified files array`);
      modifiedFile.output = conflictResult.output;
      modifiedFile.conflict = conflictResult.conflict;
      if (conflictResult.conflict) results.hasConflicts = true;
    });
    return results;
  });

  function twoWayMergeVersions(_x) {
    return _twoWayMergeVersions.apply(this, arguments);
  }

  return twoWayMergeVersions;
}();

exports.default = _default;

function getMergeResults(_x2, _x3) {
  return _getMergeResults.apply(this, arguments);
}

function _getMergeResults() {
  _getMergeResults = (0, _bluebird().coroutine)(function* (consumer, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  modifiedFiles) {
    const tmp = new (_tmp().default)(consumer.scope);
    const conflictResultsP = modifiedFiles.map(
    /*#__PURE__*/
    function () {
      var _ref = (0, _bluebird().coroutine)(function* (modifiedFile) {
        const currentFilePathP = tmp.save(modifiedFile.currentFile.contents);

        const writeFile =
        /*#__PURE__*/
        function () {
          var _ref2 = (0, _bluebird().coroutine)(function* (file) {
            // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
            return tmp.save(file.contents);
          });

          return function writeFile(_x5) {
            return _ref2.apply(this, arguments);
          };
        }();

        const baseFilePathP = tmp.save('');
        const otherFilePathP = writeFile(modifiedFile.otherFile);
        const [otherFilePath, baseFilePath, currentFilePath] = yield Promise.all([otherFilePathP, baseFilePathP, currentFilePathP]);
        const mergeFilesParams = {
          filePath: modifiedFile.filePath,
          currentFile: {
            label: modifiedFile.currentFile.version,
            path: currentFilePath
          },
          baseFile: {
            path: baseFilePath
          },
          otherFile: {
            label: modifiedFile.otherFile.version,
            path: otherFilePath
          }
        };
        return (0, _mergeFiles().default)(mergeFilesParams);
      });

      return function (_x4) {
        return _ref.apply(this, arguments);
      };
    }());
    return Promise.all(conflictResultsP);
  });
  return _getMergeResults.apply(this, arguments);
}