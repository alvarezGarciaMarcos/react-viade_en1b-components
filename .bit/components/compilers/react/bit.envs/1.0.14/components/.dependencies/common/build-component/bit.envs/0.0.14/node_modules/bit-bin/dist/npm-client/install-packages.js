"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.installPackages = installPackages;
exports.installNpmPackagesForComponents = installNpmPackagesForComponents;
exports.getAllRootDirectoriesFor = getAllRootDirectoriesFor;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _() {
  const data = _interopRequireDefault(require("."));

  _ = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _filterAsync() {
  const data = _interopRequireDefault(require("../utils/array/filter-async"));

  _filterAsync = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function installPackages(_x, _x2, _x3) {
  return _installPackages.apply(this, arguments);
}

function _installPackages() {
  _installPackages = (0, _bluebird().coroutine)(function* (consumer, dirs, verbose, // true shows all messages, false shows only a successful message
  installRootPackageJson = false, silentPackageManagerResult = false, // don't shows packageManager results at all
  installPeerDependencies = false // also install peer dependencies
  ) {
    const dirsWithPkgJson = yield filterDirsWithoutPackageJson(dirs);
    const packageManager = consumer.config.packageManager;
    const packageManagerArgs = consumer.packageManagerArgs.length ? consumer.packageManagerArgs : consumer.config.packageManagerArgs;
    const packageManagerProcessOptions = consumer.config.packageManagerProcessOptions;
    const useWorkspaces = consumer.config.useWorkspaces;

    _loader().default.start(_loaderMessages().BEFORE_INSTALL_NPM_DEPENDENCIES); // don't pass the packages to npmClient.install function.
    // otherwise, it'll try to npm install the packages in one line 'npm install packageA packageB' and when
    // there are mix of public and private packages it fails with 404 error.
    // passing an empty array, results in installing packages from the package.json file


    let results = yield _().default.install({
      modules: [],
      packageManager,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManagerArgs,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManagerProcessOptions,
      useWorkspaces,
      dirs: dirsWithPkgJson,
      rootDir: consumer.getPath(),
      installRootPackageJson,
      installPeerDependencies,
      verbose
    });

    _loader().default.stop();

    if (!Array.isArray(results)) {
      results = [results];
    }

    if (!silentPackageManagerResult || verbose) {
      results.forEach(result => {
        if (result) _().default.printResults(result);
      });
    }
  });
  return _installPackages.apply(this, arguments);
}

function installNpmPackagesForComponents(_x4) {
  return _installNpmPackagesForComponents.apply(this, arguments);
}

function _installNpmPackagesForComponents() {
  _installNpmPackagesForComponents = (0, _bluebird().coroutine)(function* ({
    consumer,
    basePath,
    componentsWithDependencies,
    verbose = false,
    silentPackageManagerResult = false,
    installPeerDependencies = false
  }) {
    const componentDirsRelative = getAllRootDirectoriesFor(componentsWithDependencies);
    const componentDirs = componentDirsRelative.map(dir => basePath ? path().join(basePath, dir) : dir);
    return installPackages(consumer, componentDirs, verbose, false, silentPackageManagerResult, installPeerDependencies);
  });
  return _installNpmPackagesForComponents.apply(this, arguments);
}

function getAllRootDirectoriesFor(componentsWithDependencies) {
  // if dependencies are installed as bit-components, go to each one of the dependencies and install npm packages
  // otherwise, if the dependencies are installed as npm packages, npm already takes care of that
  const componentsWithDependenciesFlatten = _ramda().default.flatten(componentsWithDependencies.map(oneComponentWithDependencies => {
    return oneComponentWithDependencies.component.dependenciesSavedAsComponents ? [oneComponentWithDependencies.component, ...oneComponentWithDependencies.dependencies] : [oneComponentWithDependencies.component];
  }));

  const componentDirsRelative = componentsWithDependenciesFlatten.map(component => component.writtenPath);
  return _ramda().default.uniq(componentDirsRelative);
}

function filterDirsWithoutPackageJson(_x5) {
  return _filterDirsWithoutPackageJson.apply(this, arguments);
}

function _filterDirsWithoutPackageJson() {
  _filterDirsWithoutPackageJson = (0, _bluebird().coroutine)(function* (dirs) {
    return (0, _filterAsync().default)(dirs, dir => _fsExtra().default.pathExists(path().join(dir, _constants().PACKAGE_JSON)));
  });
  return _filterDirsWithoutPackageJson.apply(this, arguments);
}