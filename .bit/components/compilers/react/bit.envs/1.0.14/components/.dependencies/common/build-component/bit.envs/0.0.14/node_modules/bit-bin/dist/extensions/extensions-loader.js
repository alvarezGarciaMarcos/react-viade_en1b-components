"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _extension() {
  const data = _interopRequireDefault(require("./extension"));

  _extension = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

/**
 * Load the global bit.json file (in order to get the global extensions)
 * @param {boolean} throws - whether to throw an error if the file corrupted
 */
const _getGlobalBitJson =
/*#__PURE__*/
function () {
  var _ref = (0, _bluebird().coroutine)(function* (throws) {
    const globalBitJsonPath = path().join(_constants().GLOBAL_CONFIG, _constants().BIT_JSON);
    const exists = yield _fsExtra().default.pathExists(globalBitJsonPath);
    if (!exists) return null;
    return _fsExtra().default.readJson(globalBitJsonPath, {
      throws
    }) // Implementing the catch my self since the throws: false not really workging
    .catch(e => {
      if (throws) {
        throw e;
      }

      _logger().default.debug('error during loading global bit.json', e);

      return null;
    });
  });

  return function _getGlobalBitJson(_x) {
    return _ref.apply(this, arguments);
  };
}();
/**
 * Load specific extension
 * @param {string} consumerPath
 * @param {string} scopePath
 */


const _loadExtension = (consumerPath, scopePath) => (rawConfig = {}, name) => {
  const loadArgs = {
    name,
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    rawConfig: rawConfig.config,
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    options: rawConfig.options,
    consumerPath,
    scopePath
  };
  return _extension().default.load(loadArgs);
};
/**
 * Load all extensions
 * Regular, core, globals
 */


var _default =
/*#__PURE__*/
function () {
  var _loadExtensions = (0, _bluebird().coroutine)(function* () {
    try {
      _logger().default.debug('start loading extensions');

      const getConsumer =
      /*#__PURE__*/
      function () {
        var _ref2 = (0, _bluebird().coroutine)(function* () {
          try {
            const consumer = yield (0, _consumer().loadConsumer)();
            return consumer;
          } catch (err) {
            return null;
          }
        });

        return function getConsumer() {
          return _ref2.apply(this, arguments);
        };
      }();

      const consumer = yield getConsumer();
      let consumerPath = null;
      let scopePath = null;
      let rawExtensions = {};

      if (consumer) {
        rawExtensions = consumer.config.extensions || {}; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        consumerPath = consumer.getPath(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        scopePath = consumer.scope.path;
      } // Load global extensions


      const globalBitJson = yield _getGlobalBitJson(false);
      const globalRawExtensions = globalBitJson && globalBitJson.extensions; // Merge the global with the local extensions only if exists
      // The local extension is higher priority than the global ones since they are closer to the user
      // This mechanism is for internal use by bitsrc server and should not be used by the users

      if (globalRawExtensions) {
        rawExtensions = _ramda().default.mergeDeepLeft(rawExtensions, globalRawExtensions);
      }

      const extensions = _ramda().default.values(_ramda().default.mapObjIndexed(_loadExtension(consumerPath, scopePath), rawExtensions));

      return Promise.all(extensions);
    } catch (err) {
      _logger().default.error('loading extensions failed', err);

      return [];
    }
  });

  function loadExtensions() {
    return _loadExtensions.apply(this, arguments);
  }

  return loadExtensions;
}();

exports.default = _default;