"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _migrationHelper() {
  const data = _interopRequireDefault(require("../../migration/migration-helper"));

  _migrationHelper = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

let globalVerbose = false;
/**
 * Running migration process for consumer
 * (Currently support only bitmap migration, but might contain other stores in the future)
 * @param {string} bitmapVersion - The current bitmap version
 * @param {Object} migratonManifest - A manifest which define what migrations to run
 * @param {BitMap} bitMap - bit map object
 * @param {boolean} verbose - print logs
 */

var _default =
/*#__PURE__*/
function () {
  var _migrate = (0, _bluebird().coroutine)(function* (bitmapVersion, migratonManifest, bitMap, verbose = false) {
    globalVerbose = verbose; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const bitMapMigrations = (0, _migrationHelper().default)(_constants().BIT_VERSION, bitmapVersion, migratonManifest, verbose);

    const newBitMap = _runAllMigrationsForStore('bitmap', bitMap, bitMapMigrations); // Run more migration for other stores (like bit.json)


    const result = {
      bitMap: newBitMap
    };
    return result;
  });

  function migrate(_x, _x2, _x3) {
    return _migrate.apply(this, arguments);
  }

  return migrate;
}();
/**
 * Runs all the migrations for all the versions for store (bit map) file
 * @param {string} storeType - type of store (bitmap / bitjson etc)
 * @param {string} store - store data
 * @param {VersionMigrations[]} migrations
 */


exports.default = _default;

const _runAllMigrationsForStore = (storeType, store, migrations) => {
  // Make sure we got a store
  if (!store) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return null;
  }

  _logger().default.debug(`start updating store ${storeType}`);

  _ramda().default.forEach(_runAllVersionMigrationsForStore(storeType, store), migrations);

  return store;
};
/**
 * Runs all the the migration in specific version on store
 * @param {string} storeType - type of store (bitmap / bitjson etc)
 * @param {string} store - store data
 */


const _runAllVersionMigrationsForStore = (storeType, store) => migrations => {
  const versionNumber = Object.keys(migrations)[0];

  _logger().default.debug(`updating store ${storeType} to version ${versionNumber}`);

  const migrationForStoreType = migrations[versionNumber][storeType]; // There is no migration for this type of object for this version

  if (!migrationForStoreType) return store;

  _ramda().default.forEach(_runOneMigrationForStore(storeType, store), migrationForStoreType);

  return store;
};
/**
 * Run specific migration function on a store
 * @param {string} storeType - type of store (bitmap / bitjson etc)
 * @param {string} store - store data
 */


const _runOneMigrationForStore = (storeType, store) => migration => {
  _logger().default.debug(`running migration: ${migration.name} on ${storeType}`);

  if (globalVerbose) console.log(`running migration: ${migration.name} on ${storeType}`);

  try {
    const migratedStore = migration.migrate(store);
    return migratedStore;
  } catch (err) {
    _logger().default.error(`FAILED - running migration: ${migration.name} on ${storeType}`);

    throw err;
  }
};