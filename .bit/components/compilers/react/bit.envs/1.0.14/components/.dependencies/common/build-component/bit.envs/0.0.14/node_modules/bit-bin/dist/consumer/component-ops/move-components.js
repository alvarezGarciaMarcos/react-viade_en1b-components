"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.movePaths = movePaths;
exports.moveExistingComponent = moveExistingComponent;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _links() {
  const data = require("../../links");

  _links = function () {
    return data;
  };

  return data;
}

function packageJsonUtils() {
  const data = _interopRequireWildcard(require("../component/package-json-utils"));

  packageJsonUtils = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _moveSync() {
  const data = _interopRequireDefault(require("../../utils/fs/move-sync"));

  _moveSync = function () {
    return data;
  };

  return data;
}

function _removePath() {
  const data = _interopRequireDefault(require("../component/sources/remove-path"));

  _removePath = function () {
    return data;
  };

  return data;
}

function _bitIds() {
  const data = _interopRequireDefault(require("../../bit-id/bit-ids"));

  _bitIds = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function movePaths(_x, _x2) {
  return _movePaths.apply(this, arguments);
}

function _movePaths() {
  _movePaths = (0, _bluebird().coroutine)(function* (consumer, {
    from,
    to
  }) {
    const fromExists = _fsExtra().default.existsSync(from);

    const toExists = _fsExtra().default.existsSync(to);

    if (fromExists && toExists) {
      throw new (_generalError().default)(`unable to move because both paths from (${from}) and to (${to}) already exist`);
    }

    if (!fromExists && !toExists) throw new (_generalError().default)(`both paths from (${from}) and to (${to}) do not exist`);
    const fromRelative = consumer.getPathRelativeToConsumer(from);
    const toRelative = consumer.getPathRelativeToConsumer(to);
    const fromAbsolute = consumer.toAbsolutePath(fromRelative);
    const toAbsolute = consumer.toAbsolutePath(toRelative);
    const existingPath = fromExists ? fromAbsolute : toAbsolute;
    const changes = consumer.bitMap.updatePathLocation(fromRelative, toRelative, existingPath);

    if (fromExists && !toExists) {
      // user would like to physically move the file. Otherwise (!fromExists and toExists), user would like to only update bit.map
      (0, _moveSync().default)(fromAbsolute, toAbsolute);
    }

    if (!_ramda().default.isEmpty(changes)) {
      const componentsIds = changes.map(c => c.id);
      const {
        components
      } = yield consumer.loadComponents(_bitIds().default.fromArray(componentsIds));
      yield packageJsonUtils().addComponentsToRoot(consumer, components);
      const nodeModuleLinker = new (_links().NodeModuleLinker)(components, consumer, consumer.bitMap);
      yield nodeModuleLinker.link();
      yield (0, _links().reLinkDependents)(consumer, components);
    }

    return changes;
  });
  return _movePaths.apply(this, arguments);
}

function moveExistingComponent(consumer, component, oldPath, newPath) {
  if (_fsExtra().default.existsSync(newPath)) {
    throw new (_generalError().default)(`could not move the component ${component.id.toString()} from ${oldPath} to ${newPath} as the destination path already exists`);
  }

  const componentMap = consumer.bitMap.getComponent(component.id);
  const oldPathRelative = consumer.getPathRelativeToConsumer(oldPath);
  const newPathRelative = consumer.getPathRelativeToConsumer(newPath);
  componentMap.updateDirLocation(oldPathRelative, newPathRelative);
  consumer.bitMap.markAsChanged();

  if (componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED) {
    component.dataToPersist.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const newRelative = file.relative.replace(oldPathRelative, newPathRelative);
      file.updatePaths({
        newRelative
      });
    });
  } else {
    component.dataToPersist.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const newBase = file.base.replace(oldPathRelative, newPathRelative);
      file.updatePaths({
        newBase
      });
    });
  }

  component.dataToPersist.removePath(new (_removePath().default)(oldPathRelative));
  component.writtenPath = newPathRelative;
}