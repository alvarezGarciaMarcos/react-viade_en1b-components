"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

/**
 * schema for forking components
 */
function _default(bitIds, remote) {
  return {
    properties: {
      shouldFork: {
        required: true,
        description: `bit is about to fork the following components and export them to ${_chalk().default.bold(remote)}.
\t${bitIds.map(id => _chalk().default.bold(id.toStringWithoutVersion())).join('\n\t')}
also, if they're staged, bit will not change their status to exported unless '--set-current-scope' flag is used.

there are additional flags for the 'export' command to specifically handle forking components:
1. '--include-dependencies' exports all dependencies to the destination alongside the component.
2. '--set-current-scope' sets your workspace to use the destination scope as the main remote for the component.
3. '--rewire' changes all dependencies to point to the new destination.

would you like to proceed with forking the components? (yes/no)`,
        message: 'please type yes or no.',
        type: 'string',

        conform(value) {
          return value.toLowerCase() === 'y' || value.toLowerCase() === 'n' || value.toLowerCase() === 'yes' || value.toLowerCase() === 'no';
        }

      }
    }
  };
}