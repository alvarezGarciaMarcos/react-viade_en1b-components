"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.set = set;
exports.setSync = setSync;
exports.del = del;
exports.delSync = delSync;
exports.get = get;
exports.getSync = getSync;
exports.list = list;
exports.listSync = listSync;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _gitconfig() {
  const data = _interopRequireDefault(require("@teambit/gitconfig"));

  _gitconfig = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _config() {
  const data = _interopRequireDefault(require("../../../global-config/config"));

  _config = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function set(key, val) {
  if (!key || !val) {
    throw new (_generalError().default)(`missing a configuration key and value. https://${_constants().BASE_DOCS_DOMAIN}/docs/conf-config`);
  }

  return _config().default.load().then(config => {
    config.set(key, val);
    invalidateCache();
    return config.write().then(() => config);
  });
}

function setSync(key, val) {
  const config = _config().default.loadSync();

  config.set(key, val);
  invalidateCache();
  config.writeSync();
  return config;
}

function del(key) {
  return _config().default.load().then(config => {
    config.delete(key);
    invalidateCache();
    return config.write().then(() => config);
  });
}

function delSync(key) {
  const config = _config().default.loadSync();

  config.delete(key);
  config.writeSync();
  invalidateCache();
  return config;
}

function get(_x) {
  return _get.apply(this, arguments);
}

function _get() {
  _get = (0, _bluebird().coroutine)(function* (key) {
    const getConfigObject =
    /*#__PURE__*/
    function () {
      var _ref = (0, _bluebird().coroutine)(function* () {
        const configFromCache = cache().get();
        if (configFromCache) return configFromCache;
        const config = yield _config().default.load();
        cache().set(config);
        return config;
      });

      return function getConfigObject() {
        return _ref.apply(this, arguments);
      };
    }();

    const config = yield getConfigObject();
    const val = config ? config.get(key) : undefined;
    if (!_ramda().default.isNil(val)) return val;

    try {
      const gitVal = yield _gitconfig().default.get(key);
      return gitVal; // Ignore error from git config get
    } catch (err) {
      return undefined;
    }
  });
  return _get.apply(this, arguments);
}

function getSync(key) {
  const getConfigObject = () => {
    const configFromCache = cache().get();
    if (configFromCache) return configFromCache;

    const config = _config().default.loadSync();

    cache().set(config);
    return config;
  };

  const config = getConfigObject();
  const val = config ? config.get(key) : undefined;
  if (!_ramda().default.isNil(val)) return val;

  try {
    const gitVal = _gitconfig().default.get.sync(key);

    return gitVal; // Ignore error from git config get
  } catch (err) {
    return undefined;
  }
}

function list() {
  return _config().default.load().then(config => config.toPlainObject());
}

function listSync() {
  const config = _config().default.loadSync();

  return config.toPlainObject();
}

function cache() {
  return {
    get: () => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return cache.config;
    },
    set: config => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      cache.config = config;
    }
  };
}

function invalidateCache() {
  cache().set(null);
}