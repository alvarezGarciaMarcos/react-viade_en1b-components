"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _chai() {
  const data = require("chai");

  _chai = function () {
    return data;
  };

  return data;
}

function _version() {
  const data = _interopRequireDefault(require("../../scope/models/version"));

  _version = function () {
    return data;
  };

  return data;
}

function _versionModelObject() {
  const data = _interopRequireDefault(require("../../../fixtures/version-model-object.json"));

  _versionModelObject = function () {
    return data;
  };

  return data;
}

function _versionModelExtended() {
  const data = _interopRequireDefault(require("../../../fixtures/version-model-extended.json"));

  _versionModelExtended = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

const getVersionWithDepsFixture = () => {
  return _version().default.parse(JSON.stringify(_ramda().default.clone(_versionModelExtended().default)));
};

describe('Version', () => {
  describe('id()', () => {
    describe('simple version', () => {
      let version;
      let idRaw;
      let idParsed;
      before(() => {
        // @ts-ignore
        version = new (_version().default)(_versionModelObject().default);
        idRaw = version.id();
        idParsed = JSON.parse(idRaw);
      });
      it('should have mainFile property', () => {
        (0, _chai().expect)(idParsed).to.haveOwnProperty('mainFile');
      });
      it('should have files property', () => {
        (0, _chai().expect)(idParsed).to.haveOwnProperty('files');
      });
      it('should have compiler property', () => {
        (0, _chai().expect)(idParsed).to.haveOwnProperty('compiler');
      });
      it('should have tester property', () => {
        (0, _chai().expect)(idParsed).to.haveOwnProperty('tester');
      });
      it('should have log property', () => {
        (0, _chai().expect)(idParsed).to.haveOwnProperty('log');
      });
      it('should have dependencies property', () => {
        (0, _chai().expect)(idParsed).to.haveOwnProperty('dependencies');
      });
      it('should have packageDependencies property', () => {
        (0, _chai().expect)(idParsed).to.haveOwnProperty('packageDependencies');
      });
      it('should have bindingPrefix property', () => {
        (0, _chai().expect)(idParsed).to.haveOwnProperty('bindingPrefix');
      });
      it('should not have dists property', () => {
        (0, _chai().expect)(idParsed).to.not.haveOwnProperty('dists');
      });
      it('should not have ci property', () => {
        (0, _chai().expect)(idParsed).to.not.haveOwnProperty('ci');
      });
      it('should not have specsResults property', () => {
        (0, _chai().expect)(idParsed).to.not.haveOwnProperty('specsResults');
      });
      it('should not have docs property', () => {
        (0, _chai().expect)(idParsed).to.not.haveOwnProperty('docs');
      });
      it('should not have devDependencies property', () => {
        (0, _chai().expect)(idParsed).to.not.haveOwnProperty('devDependencies');
      });
      it('should not have compilerDependencies property', () => {
        (0, _chai().expect)(idParsed).to.not.haveOwnProperty('compilerDependencies');
      });
      it('should not have testerDependencies property', () => {
        (0, _chai().expect)(idParsed).to.not.haveOwnProperty('testerDependencies');
      });
      it('should not have flattenedDependencies property', () => {
        (0, _chai().expect)(idParsed).to.not.haveOwnProperty('flattenedDependencies');
      });
      it('should not have flattenedDevDependencies property', () => {
        (0, _chai().expect)(idParsed).to.not.haveOwnProperty('flattenedDevDependencies');
      });
      it('should not have flattenedCompilerDependencies property', () => {
        (0, _chai().expect)(idParsed).to.not.haveOwnProperty('flattenedCompilerDependencies');
      });
      it('should not have flattenedTesterDependencies property', () => {
        (0, _chai().expect)(idParsed).to.not.haveOwnProperty('flattenedTesterDependencies');
      });
      it('should not have devPackageDependencies property', () => {
        (0, _chai().expect)(idParsed).to.not.haveOwnProperty('devPackageDependencies');
      });
      it('should not have peerPackageDependencies property', () => {
        (0, _chai().expect)(idParsed).to.not.haveOwnProperty('peerPackageDependencies');
      });
    });
    describe('version with dependencies', () => {
      let dependencies;
      before(() => {
        const version = getVersionWithDepsFixture();
        const idRaw = version.id();
        const idParsed = JSON.parse(idRaw);
        dependencies = idParsed.dependencies;
      });
      it('dependencies should be an array', () => {
        (0, _chai().expect)(dependencies).to.be.an('array').and.have.lengthOf(1);
      });
      it('dependencies should have properties id and relativePaths only', () => {
        (0, _chai().expect)(dependencies[0]).to.haveOwnProperty('id');
        (0, _chai().expect)(dependencies[0]).to.haveOwnProperty('relativePaths');
        (0, _chai().expect)(dependencies[0]).to.not.haveOwnProperty('nonExistProperty');
        (0, _chai().expect)(Object.keys(dependencies[0])).to.have.lengthOf(2);
      });
      it('relativePaths should be an array', () => {
        (0, _chai().expect)(dependencies[0].relativePaths).to.be.an('array').and.have.lengthOf(1);
      });
      it('relativePaths should have properties sourceRelativePath and destinationRelativePath only', () => {
        (0, _chai().expect)(dependencies[0].relativePaths[0]).to.haveOwnProperty('sourceRelativePath');
        (0, _chai().expect)(dependencies[0].relativePaths[0]).to.haveOwnProperty('destinationRelativePath');
        (0, _chai().expect)(dependencies[0].relativePaths[0]).to.not.haveOwnProperty('nonExistProperty');
        (0, _chai().expect)(Object.keys(dependencies[0].relativePaths[0])).to.have.lengthOf(2);
      });
    });
  });
  describe('hash()', () => {
    let version;
    let hash;
    const versionFixtureHash = '693679c1c397ca3c42f6f3486ce1ed042787886a';
    before(() => {
      // @ts-ignore
      version = new (_version().default)(_versionModelObject().default);
      hash = version.hash();
    });
    it('should have a correct hash string', () => {
      (0, _chai().expect)(hash.toString()).to.equal(versionFixtureHash);
    });
    it('should have a the same hash string also when loading the version from contents', () => {
      const versionFromContent = _version().default.parse(JSON.stringify(_versionModelObject().default));

      (0, _chai().expect)(versionFromContent.hash().toString()).to.equal(versionFixtureHash);
    });
  });
  describe('validate()', () => {
    let version;
    let validateFunc;
    beforeEach(() => {
      version = getVersionWithDepsFixture();

      validateFunc = () => version.validate();
    });
    it('should not throw when it has a valid version', () => {
      (0, _chai().expect)(validateFunc).to.not.throw();
    });
    it('should throw when mainFile is empty', () => {
      const errMsg = 'mainFile is missing';
      version.mainFile = null;
      (0, _chai().expect)(validateFunc).to.throw(errMsg);
      version.mainFile = '';
      (0, _chai().expect)(validateFunc).to.throw(errMsg);
      version.mainFile = undefined;
      (0, _chai().expect)(validateFunc).to.throw(errMsg);
    });
    it('should throw when mainFile path is absolute', () => {
      version.mainFile = '/tmp/main.js';
      (0, _chai().expect)(validateFunc).to.throw(`mainFile ${version.mainFile} is invalid`);
    });
    it('should throw when mainFile path is Windows format', () => {
      version.mainFile = 'a\\tmp.js';
      (0, _chai().expect)(validateFunc).to.throw(`mainFile ${version.mainFile} is invalid`);
    });
    it('should throw when the files are missing', () => {
      version.files = undefined;
      (0, _chai().expect)(validateFunc).to.throw('files are missing');
      version.files = null;
      (0, _chai().expect)(validateFunc).to.throw('files are missing');
      version.files = [];
      (0, _chai().expect)(validateFunc).to.throw('files are missing');
    });
    it('should throw when the file has no hash', () => {
      version.files[0].file = '';
      (0, _chai().expect)(validateFunc).to.throw('missing the hash');
    });
    it('should throw when the file has no name', () => {
      version.files[0].name = '';
      (0, _chai().expect)(validateFunc).to.throw('missing the name');
    });
    it('should throw when the file.name is not a string', () => {
      version.files[0].name = true;
      (0, _chai().expect)(validateFunc).to.throw('to be string, got boolean');
    });
    it('should throw when the file hash is not a string', () => {
      version.files[0].file.hash = [];
      (0, _chai().expect)(validateFunc).to.throw('to be string, got object');
    });
    it('should throw when the main file is not in the file lists', () => {
      version.files[0].relativePath = 'anotherFile.js';
      (0, _chai().expect)(validateFunc).to.throw('unable to find the mainFile');
    });
    it('should throw when the two files have the same name but different letter cases', () => {
      version.files[1] = _ramda().default.clone(version.files[0]);
      version.files[1].relativePath = 'bar/Foo.ts';
      (0, _chai().expect)(validateFunc).to.throw('files are duplicated bar/foo.ts, bar/Foo.ts');
    });
    it('compiler should have name attribute', () => {
      version.compiler = {};
      (0, _chai().expect)(validateFunc).to.throw('missing the name attribute');
    });
    it('compiler.name should be a string', () => {
      version.compiler.name = true;
      (0, _chai().expect)(validateFunc).to.throw('to be string, got boolean');
    });
    it('compiler.name should be a valid bit id with version', () => {
      version.compiler.name = 'scope/pref/aaa@latest';
      (0, _chai().expect)(validateFunc).to.throw('does not have a version');
    });
    it('compiler.files should have name attribute', () => {
      version.compiler.files[0] = 'string';
      (0, _chai().expect)(validateFunc).to.throw('missing the name attribute');
    });
    it('if a compiler is string, it should be a valid bit-id', () => {
      version.compiler = 'this/is\\invalid?!/bit/id';
      (0, _chai().expect)(validateFunc).to.throw('the environment-id has an invalid Bit id');
    });
    it('if a compiler is string, it should have scope', () => {
      version.compiler = 'name@0.0.1';
      (0, _chai().expect)(validateFunc).to.throw('the environment-id has an invalid Bit id');
    }); // it('if a compiler is string, it should have version', () => {
    //   version.compiler = 'scope/box/name';
    //   expect(validateFunc).to.throw('does not have a version');
    // });

    it('should throw for an invalid package version', () => {
      version.packageDependencies = {
        lodash: 34
      };
      (0, _chai().expect)(validateFunc).to.throw('expected version of "lodash" to be string, got number');
    });
    it('should not throw for a package version which is a git url', () => {
      version.packageDependencies = {
        userLib: 'gitreadonly ssh://git@git.bit.io'
      };
      (0, _chai().expect)(validateFunc).to.not.throw();
    });
    it('should throw for invalid packageDependencies type', () => {
      version.packageDependencies = 'invalid packages';
      (0, _chai().expect)(validateFunc).to.throw('to be object, got string');
    });
    it('should throw for invalid devPackageDependencies type', () => {
      version.devPackageDependencies = [1, 2, 3];
      (0, _chai().expect)(validateFunc).to.throw('to be object, got array');
    });
    it('should throw for invalid peerPackageDependencies type', () => {
      version.peerPackageDependencies = true;
      (0, _chai().expect)(validateFunc).to.throw('to be object, got boolean');
    });
    it('should throw for invalid key inside compilerPackageDependencies', () => {
      version.compilerPackageDependencies = {
        lodash: '2.0.0'
      };
      (0, _chai().expect)(validateFunc).to.throw('the property lodash inside compilerPackageDependencies is invalid, allowed values are dependencies, devDependencies, peerDependencies');
    });
    it('should throw for invalid type inside compilerPackageDependencies.dependencies', () => {
      version.compilerPackageDependencies = {
        dependencies: {
          lodash: 2
        }
      };
      (0, _chai().expect)(validateFunc).to.throw('expected compilerPackageDependencies.dependencies.lodash to be string, got number');
    });
    it('should throw for invalid dist object', () => {
      version.dists = 'invalid dists';
      (0, _chai().expect)(validateFunc).to.throw('to be array, got string');
    });
    it('should throw for invalid dist.relativePath', () => {
      version.dists[0].relativePath = 'invalid*path';
      (0, _chai().expect)(validateFunc).to.throw(`dist-file ${version.dists[0].relativePath} is invalid`);
    });
    it('should throw for an empty dist.relativePath', () => {
      version.dists[0].relativePath = '';
      (0, _chai().expect)(validateFunc).to.throw(`dist-file ${version.dists[0].relativePath} is invalid`);
    });
    it('should throw for an invalid dist.name', () => {
      version.dists[0].name = 4;
      (0, _chai().expect)(validateFunc).to.throw('to be string, got number');
    });
    it('should throw when the file hash is not a string', () => {
      version.dists[0].file.hash = {};
      (0, _chai().expect)(validateFunc).to.throw('to be string, got object');
    });
    it('should throw when dependencies are invalid', () => {
      version.dependencies = {};
      (0, _chai().expect)(validateFunc).to.throw('dependencies must be an instance of Dependencies, got object');
    });
    it('should throw when devDependencies are invalid', () => {
      version.devDependencies = {};
      (0, _chai().expect)(validateFunc).to.throw('devDependencies must be an instance of Dependencies, got object');
    });
    it('should throw when compilerDependencies are invalid', () => {
      version.compilerDependencies = {};
      (0, _chai().expect)(validateFunc).to.throw('compilerDependencies must be an instance of Dependencies, got object');
    });
    it('should throw when testerDependencies are invalid', () => {
      version.testerDependencies = {};
      (0, _chai().expect)(validateFunc).to.throw('testerDependencies must be an instance of Dependencies, got object');
    });
    it('should throw when there are dependencies and the flattenDependencies are empty', () => {
      version.flattenedDependencies = [];
      (0, _chai().expect)(validateFunc).to.throw('it has dependencies but its flattenedDependencies is empty');
    });
    it('should throw when a flattenDependency is invalid', () => {
      version.flattenedDependencies = [1234];
      (0, _chai().expect)(validateFunc).to.throw('expected to be BitId, got number');
    });
    it('should throw when a flattenDependency does not have a version', () => {
      version.flattenedDependencies[0] = version.flattenedDependencies[0].changeVersion(null);
      (0, _chai().expect)(validateFunc).to.throw('does not have a version');
    });
    it('should throw when a dependency is duplicated', () => {
      version.devDependencies = version.dependencies;
      version.flattenedDevDependencies = version.flattenedDependencies;
      (0, _chai().expect)(validateFunc).to.throw(_generalError().default);
    });
    it('should throw when the log is empty', () => {
      version.log = undefined;
      (0, _chai().expect)(validateFunc).to.throw('log object is missing');
    });
    it('should throw when the log has an invalid type', () => {
      version.log = [];
      (0, _chai().expect)(validateFunc).to.throw('to be object, got array');
    });
    it('should throw when the bindingPrefix has an invalid type', () => {
      version.bindingPrefix = {};
      (0, _chai().expect)(validateFunc).to.throw('to be string, got object');
    });
    it('should throw when packageJsonChangedProps tries to override built-in package.json prop', () => {
      version.packageJsonChangedProps = {
        main: 'my-new-main.js'
      };
      (0, _chai().expect)(validateFunc).to.throw('the packageJsonChangedProps should not override the prop main');
    });
    it('should throw when packageJsonChangedProps is not an object', () => {
      version.packageJsonChangedProps = [1, 2, 3, 4];
      (0, _chai().expect)(validateFunc).to.throw('expected packageJsonChangedProps to be object, got array');
    });
    it('should throw when packageJsonChangedProps has a non-compliant npm value', () => {
      version.packageJsonChangedProps = {
        bin: 1234
      };
      (0, _chai().expect)(validateFunc).to.throw('the generated package.json field "bin" is not compliant with npm requirements');
    });
    it('should not throw when packageJsonChangedProps has a compliant npm value', () => {
      version.packageJsonChangedProps = {
        bin: 'my-file.js'
      };
      (0, _chai().expect)(validateFunc).to.not.throw();
    });
    it('should throw when overrides has a "system" field (field that Bit uses internally for consumer overrides)', () => {
      version.overrides = {
        exclude: ['*']
      };
      (0, _chai().expect)(validateFunc).to.throw('the "overrides" has a forbidden key "exclude"');
    });
    it('should throw when overrides has a package.json field that is non-compliant npm value', () => {
      version.overrides = {
        bin: 1234
      };
      (0, _chai().expect)(validateFunc).to.throw('"overrides.bin" is a package.json field but is not compliant with npm requirements');
    });
    it('should not throw when overrides has a package.json field that is compliant npm value', () => {
      version.overrides = {
        bin: 'my-file.js'
      };
      (0, _chai().expect)(validateFunc).to.not.throw();
    });
    it('should show the original error from package-json-validator when overrides has a package.json field that is non-compliant npm value', () => {
      version.overrides = {
        scripts: false
      };
      (0, _chai().expect)(validateFunc).to.throw('Type for field scripts, was expected to be object, not boolean');
    });
  });
});