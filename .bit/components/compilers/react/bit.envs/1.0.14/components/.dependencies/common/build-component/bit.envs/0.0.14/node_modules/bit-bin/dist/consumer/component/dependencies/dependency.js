"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("../../../utils/path");

  _path = function () {
    return data;
  };

  return data;
}

class Dependency {
  constructor(id, relativePaths) {
    (0, _defineProperty2().default)(this, "id", void 0);
    (0, _defineProperty2().default)(this, "relativePaths", void 0);
    this.id = id;
    this.relativePaths = relativePaths;
  }

  static stripOriginallySharedDir(dependency, manipulateDirData, originallySharedDir) {
    const pathWithoutSharedDir = (pathStr, sharedDir) => {
      if (!sharedDir) return pathStr;
      const partToRemove = `${sharedDir}/`;
      return pathStr.replace(partToRemove, '');
    };

    const depManipulateDir = manipulateDirData.find(manipulateDirItem => manipulateDirItem.id.isEqual(dependency.id));
    dependency.relativePaths.forEach(relativePath => {
      // when custom resolved is used, do not strip the source as it is not used. the actual source
      // is the importSource. strip only the destination as it is relevant when installing
      // dependencies as packages and a link is needed for an internal file
      if (!relativePath.isCustomResolveUsed) {
        relativePath.sourceRelativePath = pathWithoutSharedDir(relativePath.sourceRelativePath, originallySharedDir);
      }

      if (depManipulateDir) {
        relativePath.destinationRelativePath = pathWithoutSharedDir(relativePath.destinationRelativePath, depManipulateDir.originallySharedDir);
      }
    });
  }

  static addWrapDir(dependency, manipulateDirData, componentWrapDir) {
    const pathWithWrapDir = (pathStr, wrapDir) => {
      if (!wrapDir) return pathStr;
      return (0, _path().pathJoinLinux)(wrapDir, pathStr);
    };

    const depManipulateDir = manipulateDirData.find(manipulateDirItem => manipulateDirItem.id.isEqual(dependency.id));
    dependency.relativePaths.forEach(relativePath => {
      if (!relativePath.isCustomResolveUsed) {
        relativePath.sourceRelativePath = pathWithWrapDir(relativePath.sourceRelativePath, componentWrapDir);
      }

      if (depManipulateDir && depManipulateDir.wrapDir) {
        relativePath.destinationRelativePath = pathWithWrapDir(relativePath.destinationRelativePath, depManipulateDir.wrapDir);
      }
    });
  }

  static getClone(dependency) {
    return {
      id: dependency.id,
      relativePaths: _ramda().default.clone(dependency.relativePaths)
    };
  }

}

exports.default = Dependency;