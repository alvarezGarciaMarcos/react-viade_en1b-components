"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var path_1 = require("path");
var src_1 = require("../src");
var cached_process_file_1 = require("../src/cached-process-file");
var generate_test_util_1 = require("./utils/generate-test-util");
function createResolveExtendsResults(fs, fileToProcess, classNameToLookup, isElement) {
    if (isElement === void 0) { isElement = false; }
    var processFile = cached_process_file_1.cachedProcessFile(function (fullpath, content) {
        return src_1.process(src_1.safeParse(content, { from: fullpath }));
    }, fs);
    var resolver = new src_1.StylableResolver(processFile, function (module) { return (module && ''); });
    return resolver.resolveExtends(processFile.process(fileToProcess), classNameToLookup, isElement);
}
describe('stylable-resolver', function () {
    it('should resolve extend classes', function () {
        var fs = src_1.createMinimalFS({
            files: {
                '/button.st.css': {
                    content: "\n                        @namespace:'Button';\n                        .root {\n                            color:red;\n                        }\n                    "
                },
                '/extended-button.st.css': {
                    content: "\n                        :import {\n                            -st-from: './button.st.css';\n                            -st-default: Button;\n                        }\n                        .myClass {\n                            -st-extends:Button;\n                            width: 100px;\n                        }\n                    "
                }
            }
        }).fs;
        var results = createResolveExtendsResults(fs, '/extended-button.st.css', 'myClass');
        chai_1.expect(results[0].symbol.name).to.equal('myClass');
        chai_1.expect(results[1].symbol.name).to.equal('root');
        chai_1.expect(results[1].meta.source).to.equal(path_1.resolve('/button.st.css'));
    });
    it('should resolve extend elements', function () {
        var fs = src_1.createMinimalFS({
            files: {
                '/button.st.css': {
                    content: "\n                        @namespace:'Button';\n                        .root {\n                            color:red;\n                        }\n                    "
                },
                '/extended-button.st.css': {
                    content: "\n                        :import {\n                            -st-from: './button.st.css';\n                            -st-default: Button;\n                        }\n                        Button {\n                            width: 100px;\n                        }\n                    "
                }
            }
        }).fs;
        var results = createResolveExtendsResults(fs, '/extended-button.st.css', 'Button', true);
        chai_1.expect(results[0].symbol.name).to.equal('Button');
        chai_1.expect(results[1].symbol.name).to.equal('root');
        chai_1.expect(results[1].meta.source).to.equal(path_1.resolve('/button.st.css'));
    });
    it('should resolve extend classes on broken css', function () {
        var fs = src_1.createMinimalFS({
            files: {
                '/button.st.css': {
                    content: "\n                        .gaga\n                    "
                }
            }
        }).fs;
        var results = createResolveExtendsResults(fs, path_1.resolve('/button.st.css'), 'gaga');
        chai_1.expect(results).to.eql([]);
    });
    it('should resolve extend through exported alias', function () {
        var fs = src_1.createMinimalFS({
            files: {
                '/entry.st.css': {
                    content: "\n                        :import {\n                            -st-from: \"./index.st.css\";\n                            -st-named: Comp;\n                        }\n                        .root {\n                            -st-extends: Comp;\n                        }\n                    "
                },
                '/index.st.css': {
                    content: "\n                        :import{\n                            -st-from: \"./button.st.css\";\n                            -st-default: Comp;\n                        }\n                        Comp{}\n                    "
                },
                '/button.st.css': {
                    content: "\n                        .root{}\n                    "
                }
            }
        }).fs;
        var results = createResolveExtendsResults(fs, path_1.resolve('/entry.st.css'), 'root');
        chai_1.expect(results[0].symbol.name).to.equal('root');
        chai_1.expect(results[1].symbol.name).to.equal('Comp');
        chai_1.expect(results[2].symbol.name).to.equal('root');
        chai_1.expect(results[0].meta.source).to.equal(path_1.resolve('/entry.st.css'));
        chai_1.expect(results[1].meta.source).to.equal(path_1.resolve('/index.st.css'));
        chai_1.expect(results[2].meta.source).to.equal(path_1.resolve('/button.st.css'));
    });
    it('should resolve classes', function () {
        var _a = generate_test_util_1.generateInfra({
            files: {
                '/entry.st.css': {
                    content: "\n                        :import {\n                            -st-from: \"./button.st.css\";\n                            -st-default: Button;\n                        }\n                        .x {-st-extends: Button}\n                    "
                },
                '/button.st.css': {
                    content: "\n                        .root{}\n                    "
                }
            }
        }), resolver = _a.resolver, fileProcessor = _a.fileProcessor;
        var entryMeta = fileProcessor.process('/entry.st.css');
        var btnMeta = fileProcessor.process('/button.st.css');
        var res = resolver.resolve(entryMeta.mappedSymbols.x);
        chai_1.expect(res.symbol).to.eql(btnMeta.classes.root);
    });
    it('should resolve elements', function () {
        var _a = generate_test_util_1.generateInfra({
            files: {
                '/entry.st.css': {
                    content: "\n                        :import {\n                            -st-from: \"./button.st.css\";\n                            -st-default: Button;\n                            -st-named: ButtonX;\n                        }\n                        Button {}\n                        ButtonX {}\n                    "
                },
                '/button.st.css': {
                    content: "\n                        .root{}\n                        .label{}\n                        ButtonX{}\n                    "
                }
            }
        }), resolver = _a.resolver, fileProcessor = _a.fileProcessor;
        var btnMeta = fileProcessor.process('/button.st.css');
        var entryMeta = fileProcessor.process('/entry.st.css');
        var btn = entryMeta.mappedSymbols.Button;
        var res = resolver.resolve(btn);
        var btn1 = entryMeta.mappedSymbols.ButtonX;
        var res1 = resolver.resolve(btn1);
        chai_1.expect(res.symbol).to.eql(btnMeta.classes.root);
        chai_1.expect(res1.symbol).to.eql(btnMeta.elements.ButtonX);
    });
    it('should resolve elements deep', function () {
        var _a = generate_test_util_1.generateInfra({
            files: {
                '/entry.st.css': {
                    content: "\n                        :import {\n                            -st-from: \"./button.st.css\";\n                            -st-named: ButtonX;\n                        }\n                        ButtonX {}\n                    "
                },
                '/button.st.css': {
                    content: "\n                        :import {\n                            -st-from: \"./button-x.st.css\";\n                            -st-default: ButtonX;\n                        }\n                        ButtonX{}\n                    "
                },
                '/button-x.st.css': {
                    content: "\n                        .x-label{}\n                    "
                }
            }
        }), resolver = _a.resolver, fileProcessor = _a.fileProcessor;
        var entryMeta = fileProcessor.process('/entry.st.css');
        var btnXMeta = fileProcessor.process('/button-x.st.css');
        var btn1 = entryMeta.mappedSymbols.ButtonX;
        var res1 = resolver.deepResolve(btn1);
        chai_1.expect(res1.symbol).to.eql(btnXMeta.classes.root);
    });
    it('should handle circular "re-declare" (deepResolve)', function () {
        var _a = generate_test_util_1.generateInfra({
            files: {
                '/entry.st.css': {
                    content: "\n                        :import {\n                            -st-from: \"./entry.st.css\";\n                            -st-named: a;\n                        }\n                        .a {}\n                    "
                }
            }
        }), resolver = _a.resolver, fileProcessor = _a.fileProcessor;
        var entryMeta = fileProcessor.process('/entry.st.css');
        var a = entryMeta.mappedSymbols.a;
        var res1 = resolver.deepResolve(a);
        chai_1.expect(res1.symbol).to.eql(entryMeta.classes.a);
    });
    it('should handle circular "re-declare" (resolveSymbolOrigin)', function () {
        var _a = generate_test_util_1.generateInfra({
            files: {
                '/entry.st.css': {
                    content: "\n                        :import {\n                            -st-from: \"./entry.st.css\";\n                            -st-named: a;\n                        }\n                        .a {}\n                    "
                }
            }
        }), resolver = _a.resolver, fileProcessor = _a.fileProcessor;
        var entryMeta = fileProcessor.process('/entry.st.css');
        var a = entryMeta.mappedSymbols.a;
        var res1 = resolver.resolveSymbolOrigin(a, entryMeta);
        chai_1.expect(res1.symbol).to.eql(entryMeta.classes.a);
    });
    it('should resolve alias origin', function () {
        var _a = generate_test_util_1.generateInfra({
            files: {
                '/entry.st.css': {
                    content: "\n                        :import {\n                            -st-from: \"./a.st.css\";\n                            -st-named: a, b;\n                        }\n                        .a{}\n                        .b{}\n                    "
                },
                '/a.st.css': {
                    content: "\n                        :import {\n                            -st-from: \"./a1.st.css\";\n                            -st-named: a, b;\n                        }\n                        .a{}\n                        .b{}\n                    "
                },
                '/a1.st.css': {
                    content: "\n                        :import {\n                            -st-from: \"./comp.st.css\";\n                            -st-named: Comp;\n                        }\n                        .a{}\n                        .b{-st-extends: Comp}\n                    "
                },
                '/comp.st.css': {
                    content: ""
                }
            }
        }), resolver = _a.resolver, fileProcessor = _a.fileProcessor;
        var entryMeta = fileProcessor.process('/entry.st.css');
        var a1 = fileProcessor.process('/a1.st.css');
        var res1 = resolver.resolveSymbolOrigin(entryMeta.mappedSymbols.a, entryMeta);
        var res2 = resolver.resolveSymbolOrigin(entryMeta.mappedSymbols.b, entryMeta);
        chai_1.expect(res1.symbol).to.eql(a1.classes.a);
        chai_1.expect(res2.symbol).to.eql(a1.classes.b);
    });
    it('should not resolve extends on alias', function () {
        var _a = generate_test_util_1.generateInfra({
            files: {
                '/entry.st.css': {
                    content: "\n                        :import {\n                            -st-from: \"./a.st.css\";\n                            -st-named: a;\n                        }\n                        .a {\n                           -st-extends: a;\n                        }\n                    "
                },
                '/a.st.css': {
                    content: "\n                        .a{}\n                    "
                }
            }
        }), resolver = _a.resolver, fileProcessor = _a.fileProcessor;
        var entryMeta = fileProcessor.process('/entry.st.css');
        var res1 = resolver.resolveSymbolOrigin(entryMeta.mappedSymbols.a, entryMeta);
        chai_1.expect(res1.symbol).to.eql(entryMeta.classes.a);
    });
});
//# sourceMappingURL=stylable-resolver.spec.js.map