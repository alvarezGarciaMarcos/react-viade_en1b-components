"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = extractDataRegex;

function _doctrine() {
  const data = _interopRequireDefault(require("doctrine"));

  _doctrine = function () {
    return data;
  };

  return data;
}

function _exampleTagParser() {
  const data = _interopRequireDefault(require("./example-tag-parser"));

  _exampleTagParser = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function formatTag(tag) {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  delete tag.title; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  if (!tag.type) return tag; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  let formattedType = _doctrine().default.type.stringify(tag.type); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  if (tag.type.type === _doctrine().default.type.Syntax.TypeApplication) {
    // Doctrine adds a dot after the generic type for historical reasons.
    // see here for more info: https://github.com/eslint/doctrine/issues/185
    formattedType = formattedType.replace('.<', '<');
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  if (tag.type.type === _doctrine().default.type.Syntax.OptionalType) {
    // Doctrine shows an optional type with a suffix `=` (e.g. `string=`), we prefer the more
    // common syntax `?` (e.g. `string?`)
    formattedType = formattedType.replace('=', '?');
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  tag.type = formattedType;
  return tag;
}

function extractDataRegex(doc, doclets, filePath) {
  const commentsAst = _doctrine().default.parse(doc.trim(), {
    unwrap: true,
    recoverable: true,
    sloppy: true
  });

  if (!commentsAst) return;
  const args = [];
  let description = commentsAst.description;
  let returns = {};
  let isStatic = false;
  let access = 'public';
  const examples = [];
  const properties = [];
  let name = '';
  let render = '';
  commentsAst.tags.forEach(tag => {
    switch (tag.title) {
      case 'desc':
      case 'description':
        description = tag.description;
        break;

      case 'name':
        name = tag.name;
        break;

      case 'param':
      case 'arg':
      case 'argument':
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        args.push(formatTag(tag));
        break;

      case 'returns':
      case 'return':
        returns = formatTag(tag);
        break;

      case 'static':
        isStatic = true;
        break;

      case 'private':
      case 'protected':
        access = tag.title;
        break;

      case 'access':
        access = tag.access;
        break;

      case 'example':
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        examples.push((0, _exampleTagParser().default)(tag.description));
        break;

      case 'property':
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        properties.push(formatTag(tag));
        break;

      case 'render':
        render = tag.description;
        break;

      default:
        break;
    }
  });
  const doclet = {
    name,
    // todo: find the function/method name by regex
    description,
    args,
    returns,
    access,
    examples,
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    render,
    properties,
    static: isStatic,
    filePath: (0, _utils().pathNormalizeToLinux)(filePath)
  };
  doclets.push(doclet);
}