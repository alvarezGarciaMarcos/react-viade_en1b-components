"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var postcss = require("postcss");
var selector_utils_1 = require("./selector-utils");
var stylable_value_parsers_1 = require("./stylable-value-parsers");
var replaceRuleSelector = require('postcss-selector-matches/dist/replaceRuleSelector');
var cloneDeep = require('lodash.clonedeep');
exports.CUSTOM_SELECTOR_RE = /:--[\w-]+/g;
function isValidDeclaration(decl) {
    return typeof decl.value === 'string';
}
exports.isValidDeclaration = isValidDeclaration;
function expandCustomSelectors(rule, customSelectors, diagnostics) {
    if (rule.selector.indexOf(':--') > -1) {
        rule.selector = rule.selector.replace(exports.CUSTOM_SELECTOR_RE, function (extensionName, _matches, selector) {
            if (!customSelectors[extensionName] && diagnostics) {
                diagnostics.warn(rule, "The selector '" + rule.selector + "' is undefined", { word: rule.selector });
                return selector;
            }
            // TODO: support nested CustomSelectors
            return ':matches(' + customSelectors[extensionName] + ')';
        });
        return rule.selector = transformMatchesOnRule(rule, false);
    }
    return rule.selector;
}
exports.expandCustomSelectors = expandCustomSelectors;
function transformMatchesOnRule(rule, lineBreak) {
    return replaceRuleSelector(rule, { lineBreak: lineBreak });
}
exports.transformMatchesOnRule = transformMatchesOnRule;
function scopeSelector(scopeSelectorRule, targetSelectorRule, rootScopeLevel) {
    if (rootScopeLevel === void 0) { rootScopeLevel = false; }
    var scopingSelectorAst = selector_utils_1.parseSelector(scopeSelectorRule);
    var targetSelectorAst = selector_utils_1.parseSelector(targetSelectorRule);
    var nodes = [];
    targetSelectorAst.nodes.forEach(function (targetSelector) {
        scopingSelectorAst.nodes.forEach(function (scopingSelector) {
            var outputSelector = cloneDeep(targetSelector);
            outputSelector.before = scopingSelector.before || outputSelector.before;
            var first = outputSelector.nodes[0];
            var parentRef = first.type === 'invalid' && first.value === '&';
            var startsWithScoping = rootScopeLevel ? scopingSelector.nodes.every(function (node, i) {
                var o = outputSelector.nodes[i];
                for (var k in node) {
                    if (node[k] !== o[k]) {
                        return false;
                    }
                }
                return true;
            }) : false;
            if (first && first.type !== 'spacing' && !parentRef && !startsWithScoping) {
                (_a = outputSelector.nodes).unshift.apply(_a, cloneDeep(scopingSelector.nodes, true).concat([{
                        type: 'spacing',
                        value: ' '
                    }]));
            }
            selector_utils_1.traverseNode(outputSelector, function (node, i, nodes) {
                if (node.type === 'invalid' && node.value === '&') {
                    nodes.splice.apply(nodes, [i, 1].concat(cloneDeep(scopingSelector.nodes, true)));
                }
            });
            nodes.push(outputSelector);
            var _a;
        });
    });
    scopingSelectorAst.nodes = nodes;
    return {
        selector: selector_utils_1.stringifySelector(scopingSelectorAst),
        selectorAst: scopingSelectorAst
    };
}
exports.scopeSelector = scopeSelector;
function mergeRules(mixinAst, rule) {
    var mixinRoot = null;
    mixinAst.walkRules(function (mixinRule) {
        if (mixinRule.selector === '&' && !mixinRoot) {
            mixinRoot = mixinRule;
        }
        else {
            var out = scopeSelector(rule.selector, mixinRule.selector);
            mixinRule.selector = out.selector;
            // mixinRule.selectorAst = out.selectorAst;
        }
    });
    if (mixinAst.nodes) {
        var nextRule_1 = rule;
        var mixinEntry_1 = null;
        rule.walkDecls(stylable_value_parsers_1.valueMapping.mixin, function (decl) {
            mixinEntry_1 = decl;
        });
        if (!mixinEntry_1) {
            throw rule.error('missing mixin entry');
        }
        // TODO: handle rules before and after decl on entry
        mixinAst.nodes.slice().forEach(function (node) {
            if (node === mixinRoot) {
                node.walkDecls(function (node) {
                    rule.insertBefore(mixinEntry_1, node);
                });
            }
            else if (node.type === 'decl') {
                rule.insertBefore(mixinEntry_1, node);
            }
            else if (node.type === 'rule' || node.type === 'atrule') {
                if (rule.parent.last === nextRule_1) {
                    rule.parent.append(node);
                }
                else {
                    rule.parent.insertAfter(nextRule_1, node);
                }
                nextRule_1 = node;
            }
        });
    }
    return rule;
}
exports.mergeRules = mergeRules;
function createSubsetAst(root, selectorPrefix, mixinTarget, isRoot) {
    // keyframes on class mixin?
    if (isRoot === void 0) { isRoot = false; }
    var prefixType = selector_utils_1.parseSelector(selectorPrefix).nodes[0].nodes[0];
    var containsPrefix = containsMatchInFistChunk.bind(null, prefixType);
    var mixinRoot = mixinTarget ? mixinTarget : postcss.root();
    root.nodes.forEach(function (node) {
        if (node.type === 'rule') {
            var ast = isRoot ?
                scopeSelector(selectorPrefix, node.selector, true).selectorAst : selector_utils_1.parseSelector(node.selector);
            var matchesSelectors = isRoot ? ast.nodes : ast.nodes.filter(containsPrefix);
            if (matchesSelectors.length) {
                var selector = selector_utils_1.stringifySelector(__assign({}, ast, { nodes: matchesSelectors.map(function (selectorNode) {
                        if (!isRoot) {
                            selector_utils_1.fixChunkOrdering(selectorNode, prefixType);
                        }
                        return destructiveReplaceNode(selectorNode, prefixType, { type: 'invalid', value: '&' });
                    }) }));
                mixinRoot.append(node.clone({ selector: selector }));
            }
        }
        else if (node.type === 'atrule') {
            if (node.name === 'media') {
                var mediaSubset = createSubsetAst(node, selectorPrefix, postcss.atRule({
                    params: node.params,
                    name: node.name
                }), isRoot);
                if (mediaSubset.nodes) {
                    mixinRoot.append(mediaSubset);
                }
            }
            else if (isRoot) {
                mixinRoot.append(node.clone());
            }
        }
        else {
            // TODO: add warn?
        }
    });
    return mixinRoot;
}
exports.createSubsetAst = createSubsetAst;
function removeUnusedRules(ast, meta, _import, usedFiles, resolvePath) {
    var isUnusedImport = usedFiles.indexOf(_import.from) === -1;
    if (isUnusedImport) {
        var symbols_1 = Object.keys(_import.named).concat(_import.defaultExport); // .filter(Boolean);
        ast.walkRules(function (rule) {
            var shouldOutput = true;
            selector_utils_1.traverseNode(rule.selectorAst, function (node) {
                // TODO: remove.
                if (symbols_1.indexOf(node.name) !== -1) {
                    return shouldOutput = false;
                }
                var symbol = meta.mappedSymbols[node.name];
                if (symbol && (symbol._kind === 'class' || symbol._kind === 'element')) {
                    var extend = symbol[stylable_value_parsers_1.valueMapping.extends] || symbol.alias;
                    extend = extend && extend._kind !== 'import' ? (extend.alias || extend) : extend;
                    if (extend && extend._kind === 'import' &&
                        usedFiles.indexOf(resolvePath(meta.source, extend.import.from)) === -1) {
                        return shouldOutput = false;
                    }
                }
                return undefined;
            });
            // TODO: optimize the multiple selectors
            if (!shouldOutput && rule.selectorAst.nodes.length <= 1) {
                rule.remove();
            }
        });
    }
}
exports.removeUnusedRules = removeUnusedRules;
function findDeclaration(importNode, test) {
    var fromIndex = importNode.rule.nodes.findIndex(test);
    return importNode.rule.nodes[fromIndex];
}
exports.findDeclaration = findDeclaration;
function findRule(root, selector, test) {
    if (test === void 0) { test = function (statement) { return statement.prop === stylable_value_parsers_1.valueMapping.extends; }; }
    var found = null;
    root.walkRules(selector, function (rule) {
        var declarationIndex = rule.nodes ? rule.nodes.findIndex(test) : -1;
        if (rule.isSimpleSelector && !!~declarationIndex) {
            found = rule.nodes[declarationIndex];
        }
    });
    return found;
}
exports.findRule = findRule;
function getDeclStylable(decl) {
    if (decl.stylable) {
        return decl.stylable;
    }
    else {
        decl.stylable = decl.stylable ?
            decl.stylable :
            { sourceValue: '' };
        return decl.stylable;
    }
}
exports.getDeclStylable = getDeclStylable;
function destructiveReplaceNode(ast, matchNode, replacementNode) {
    selector_utils_1.traverseNode(ast, function (node) {
        if (selector_utils_1.isNodeMatch(node, matchNode)) {
            node.type = 'selector';
            node.nodes = [replacementNode];
        }
    });
    return ast;
}
function containsMatchInFistChunk(prefixType, selectorNode) {
    var isMatch = false;
    selector_utils_1.traverseNode(selectorNode, function (node) {
        if (node.type === 'operator' || node.type === 'spacing') {
            return false;
        }
        else if (node.type === 'nested-pseudo-class') {
            return true;
        }
        else if (selector_utils_1.isNodeMatch(node, prefixType)) {
            isMatch = true;
            return false;
        }
        return undefined;
    });
    return isMatch;
}
//# sourceMappingURL=stylable-utils.js.map