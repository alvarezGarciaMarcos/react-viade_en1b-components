"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _componentObjects() {
  const data = _interopRequireDefault(require("./component-objects"));

  _componentObjects = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _customError() {
  const data = _interopRequireDefault(require("../error/custom-error"));

  _customError = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

class ComponentVersion {
  constructor(component, version) {
    (0, _defineProperty2().default)(this, "component", void 0);
    (0, _defineProperty2().default)(this, "version", void 0);

    if (!version) {
      throw new TypeError(`ComponentVersion expects "version" to be defined (failed for ${component.id()})`);
    }

    this.component = component;
    this.version = version;
    Object.freeze(this);
  }

  getVersion(repository) {
    return this.component.loadVersion(this.version, repository);
  }

  flattenedDependencies(repository) {
    return this.getVersion(repository).then(version => version.flattenedDependencies);
  }

  flattenedDevDependencies(repository) {
    return this.getVersion(repository).then(version => version.flattenedDevDependencies);
  }

  flattenedCompilerDependencies(repository) {
    return this.getVersion(repository).then(version => version.flattenedCompilerDependencies);
  }

  flattenedTesterDependencies(repository) {
    return this.getVersion(repository).then(version => version.flattenedTesterDependencies);
  }

  toId() {
    return new (_bitId().BitId)({
      scope: this.component.scope,
      name: this.component.name,
      version: this.version
    });
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get id() {
    return this.toId();
  }

  toConsumer(repo, manipulateDirData) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    return this.component.toConsumerComponent(this.version, this.component.scope, repo, manipulateDirData);
  }

  toObjects(repo, clientVersion) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      const version = yield _this.getVersion(repo);
      if (!version) throw new (_showDoctorError().default)(`failed loading version ${_this.version} of ${_this.component.id()}`); // @todo: remove this customError once upgrading to v15, because when the server has v15
      // and the client has < 15, the client will get anyway an error to upgrade the version

      if (clientVersion && version.overrides && !_ramda().default.isEmpty(version.overrides) && _semver().default.lt(clientVersion, '14.1.0')) {
        throw new (_customError().default)(`Your components were created with a newer version and use the "overrides" feature.
Please upgrade your bit client to version >= v14.1.0`);
      }

      try {
        const [compObject, objects, versionBuffer, scopeMeta] = yield Promise.all([_this.component.asRaw(repo), version.collectRaw(repo), version.asRaw(repo), repo.getScopeMetaObject()]);
        return new (_componentObjects().default)(compObject, objects.concat([versionBuffer, scopeMeta]));
      } catch (err) {
        _logger().default.error('component-version.toObjects got an error', err);

        const originalVersionHash = _this.component.versions[_this.version].toString();

        const currentVersionHash = version.hash().toString();

        if (originalVersionHash !== currentVersionHash) {
          throw new (_exceptions().HashMismatch)(_this.component.id(), _this.version, originalVersionHash, currentVersionHash);
        }

        throw err;
      }
    })();
  }

}

exports.default = ComponentVersion;