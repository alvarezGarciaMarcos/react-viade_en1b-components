"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.componentToPrintableForDiff = componentToPrintableForDiff;
exports.prettifyFieldName = prettifyFieldName;
exports.getDiffBetweenObjects = getDiffBetweenObjects;
exports.diffBetweenComponentsObjects = diffBetweenComponentsObjects;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function RA() {
  const data = _interopRequireWildcard(require("ramda-adjunct"));

  RA = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _objectDiff() {
  const data = _interopRequireDefault(require("object-diff"));

  _objectDiff = function () {
    return data;
  };

  return data;
}

function _normalizePath() {
  const data = _interopRequireDefault(require("normalize-path"));

  _normalizePath = function () {
    return data;
  };

  return data;
}

function _arrayDifference() {
  const data = _interopRequireDefault(require("array-difference"));

  _arrayDifference = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function componentToPrintableForDiff(component) {
  const obj = {};

  const parsePackages = packages => {
    return !_ramda().default.isEmpty(packages) && !_ramda().default.isNil(packages) ? Object.keys(packages).map(key => `${key}@${packages[key]}`) : null;
  };

  const parseEnvFiles = envExtension => {
    // $FlowFixMe sadly, Flow doesn't know what isNilOrEmpty does
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (RA().isNilOrEmpty(envExtension) || RA().isNilOrEmpty(envExtension.files)) return null; // $FlowFixMe sadly, Flow doesn't know what isNilOrEmpty does
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return envExtension.files.map(file => `${file.name} => ${file.relative}`).sort();
  };

  const {
    lang,
    compiler,
    tester,
    dependencies,
    devDependencies,
    compilerDependencies,
    testerDependencies,
    packageDependencies,
    devPackageDependencies,
    compilerPackageDependencies,
    testerPackageDependencies,
    files,
    mainFile,
    deprecated
  } = component;

  const allDevPackages = _objectSpread({}, devPackageDependencies, {}, compilerPackageDependencies.devDependencies, {}, testerPackageDependencies.devDependencies);

  const allPackages = _objectSpread({}, packageDependencies, {}, compilerPackageDependencies.dependencies, {}, testerPackageDependencies.dependencies);

  const allPeerPackages = _objectSpread({}, component.peerPackageDependencies, {}, compilerPackageDependencies.peerDependencies, {}, testerPackageDependencies.peerDependencies);

  const parsedDevPackageDependencies = parsePackages(allDevPackages) || [];
  const printableCompilerDependencies = compilerDependencies.toStringOfIds();
  const printableTesterDependencies = testerDependencies.toStringOfIds(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  const peerPackageDependencies = [].concat(parsePackages(allPeerPackages)).filter(x => x);
  const overrides = component.overrides.componentOverridesData; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.id = component.id.toStringWithoutScope(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.compiler = compiler ? compiler.name : null; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.compilerFiles = parseEnvFiles(compiler); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.language = lang || null; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.tester = tester ? tester.name : null; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.testerFiles = parseEnvFiles(tester); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.mainFile = mainFile ? (0, _normalizePath().default)(mainFile) : null; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.dependencies = dependencies.toStringOfIds().sort() // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  .concat(parsePackages(allPackages)).filter(x => x); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.devDependencies = devDependencies.toStringOfIds().sort().concat(parsedDevPackageDependencies).concat(printableCompilerDependencies).concat(printableTesterDependencies).filter(x => x); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.peerDependencies = peerPackageDependencies.length ? peerPackageDependencies : undefined; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.files = files && !_ramda().default.isEmpty(files) && !_ramda().default.isNil(files) ? // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  files.filter(file => !file.test).map(file => (0, _normalizePath().default)(file.relative)) : null; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.specs = files && !_ramda().default.isEmpty(files) && !_ramda().default.isNil(files) && _ramda().default.find(_ramda().default.propEq('test', true))(files) ? // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  files.filter(file => file.test).map(file => (0, _normalizePath().default)(file.relative)) : null; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.deprecated = deprecated ? 'True' : null; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.overridesDependencies = parsePackages(overrides.dependencies); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.overridesDevDependencies = parsePackages(overrides.devDependencies); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.overridesPeerDependencies = parsePackages(overrides.peerDependencies); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  obj.overridesPackageJsonProps = JSON.stringify(component.overrides.componentOverridesPackageJsonData);
  return obj;
}

function prettifyFieldName(field) {
  return `${field[0].toUpperCase()}${field.substr(1)}`.replace(/([A-Z])/g, ' $1').trim();
}

function comparator(a, b) {
  if (a instanceof Array && b instanceof Array) {
    return _ramda().default.isEmpty((0, _arrayDifference().default)(a, b));
  }

  return a === b;
}

function getDiffBetweenObjects(objectLeft, objectRight) {
  return _objectDiff().default.custom({
    equal: comparator
  }, objectLeft, objectRight);
}

function diffBetweenComponentsObjects(consumer, componentLeft, componentRight, verbose) {
  const printableLeft = componentToPrintableForDiff(componentLeft);
  const printableRight = componentToPrintableForDiff(componentRight);
  const fieldsDiff = getDiffBetweenObjects(printableLeft, printableRight);

  if (!componentLeft.version || !componentRight.version) {
    throw new Error('diffBetweenComponentsObjects component does not have a version');
  }

  const areVersionsTheSame = componentLeft.version === componentRight.version;
  const labelLeft = areVersionsTheSame ? `${componentLeft.version} original` : componentLeft.version;
  const labelRight = areVersionsTheSame ? `${componentRight.version} modified` : componentRight.version;

  const titleLeft = field => `--- ${prettifyFieldName(field)} (${labelLeft})\n`;

  const titleRight = field => `+++ ${prettifyFieldName(field)} (${labelRight})\n`;

  const printFieldValue = fieldValue => {
    if (typeof fieldValue === 'string') return fieldValue;
    if (Array.isArray(fieldValue)) return `[ ${fieldValue.join(', ')} ]`;
    throw new Error(`diffBetweenComponentsObjects: not support ${typeof fieldValue}`);
  };

  const printFieldLeft = field => {
    const fieldValue = printableLeft[field];
    if (!fieldValue) return '';
    return `- ${printFieldValue(fieldValue)}\n`;
  };

  const printFieldRight = field => {
    const fieldValue = printableRight[field];
    if (!fieldValue) return '';
    return `+ ${printFieldValue(fieldValue)}\n`;
  };

  const fieldsDiffOutput = Object.keys(fieldsDiff).map(field => {
    const title = titleLeft(field) + _chalk().default.bold(titleRight(field));

    const value = _chalk().default.red(printFieldLeft(field)) + _chalk().default.green(printFieldRight(field));

    const diffOutput = title + value;
    return {
      fieldName: field,
      diffOutput
    };
  });

  const dependenciesOutput = () => {
    if (!verbose) return [];
    const dependenciesLeft = componentLeft.getAllDependencies();
    const dependenciesRight = componentRight.getAllDependencies();
    if (_ramda().default.isEmpty(dependenciesLeft) || _ramda().default.isEmpty(dependenciesRight)) return [];
    return dependenciesLeft.reduce((acc, dependencyLeft) => {
      const idStr = dependencyLeft.id.toString();
      const dependencyRight = dependenciesRight.find(dep => dep.id.isEqual(dependencyLeft.id));
      if (!dependencyRight) return acc;
      if (JSON.stringify(dependencyLeft.relativePaths) === JSON.stringify(dependencyRight.relativePaths)) return acc;
      const fieldName = `Dependency ${idStr} relative-paths`;

      const title = titleLeft(fieldName) + _chalk().default.bold(titleRight(fieldName));

      const getValue = (fieldValue, left) => {
        if (_ramda().default.isEmpty(fieldValue)) return '';
        const sign = left ? '-' : '+';
        const jsonOutput = JSON.stringify(fieldValue, null, `${sign} `);
        return `${jsonOutput}\n`;
      };

      const value = _chalk().default.red(getValue(dependencyLeft.relativePaths, true)) + _chalk().default.green(getValue(dependencyRight.relativePaths, false));

      const diffOutput = title + value; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      acc.push({
        fieldName,
        diffOutput
      });
      return acc;
    }, []);
  };

  const envs = ['compiler', 'tester'];
  const fieldsEnvsConfigOutput = envs.map(env => {
    const leftConfig = componentLeft[env] && componentLeft[env].dynamicConfig ? componentLeft[env].dynamicConfig : {};
    const rightConfig = // $FlowFixMe
    componentRight[env] && componentRight[env].dynamicConfig ? componentRight[env].dynamicConfig : {}; // $FlowFixMe we remove the null later

    if (JSON.stringify(leftConfig) === JSON.stringify(rightConfig)) return null;
    const fieldName = `${env} configuration`;

    const title = titleLeft(fieldName) + _chalk().default.bold(titleRight(fieldName));

    const getValue = (fieldValue, left) => {
      if (_ramda().default.isEmpty(fieldValue)) return '';
      const sign = left ? '-' : '+';
      const jsonOutput = JSON.stringify(fieldValue, null, `${sign} `);
      return `${jsonOutput}\n`;
    };

    const value = _chalk().default.red(getValue(leftConfig, true)) + _chalk().default.green(getValue(rightConfig, false));

    const diffOutput = title + value;
    return {
      fieldName,
      diffOutput
    };
  }).filter(x => x);
  const allDiffs = [...fieldsDiffOutput, ...fieldsEnvsConfigOutput, ...dependenciesOutput()]; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  return _ramda().default.isEmpty(allDiffs) ? undefined : allDiffs;
}