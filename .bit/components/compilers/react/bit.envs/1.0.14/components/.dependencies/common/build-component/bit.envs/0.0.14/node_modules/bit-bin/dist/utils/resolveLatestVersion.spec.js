"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

function _chai() {
  const data = require("chai");

  _chai = function () {
    return data;
  };

  return data;
}

function _bitIds() {
  const data = _interopRequireDefault(require("../bit-id/bit-ids"));

  _bitIds = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = _interopRequireDefault(require("../bit-id/bit-id"));

  _bitId = function () {
    return data;
  };

  return data;
}

function _resolveLatestVersion() {
  const data = _interopRequireDefault(require("./resolveLatestVersion"));

  _resolveLatestVersion = function () {
    return data;
  };

  return data;
}

describe('getLatestVersionNumber', () => {
  const idWithNoVersion = new (_bitId().default)({
    name: 'is-string'
  });
  const idWithVersionLatest = new (_bitId().default)({
    name: 'is-string',
    version: 'latest'
  });
  const idWithVersion1 = new (_bitId().default)({
    name: 'is-string',
    version: '0.0.1'
  });
  const idWithVersion2 = new (_bitId().default)({
    name: 'is-string',
    version: '0.0.2'
  });
  const idWithVersion3 = new (_bitId().default)({
    name: 'is-string',
    version: '0.0.3'
  });
  const idWithNoVersionWithScope = new (_bitId().default)({
    scope: 'my-scope',
    name: 'is-string'
  });
  const idWithVersion1WithScope = new (_bitId().default)({
    scope: 'my-scope',
    name: 'is-string',
    version: '0.0.1'
  });
  it('should return the same id when bitIds is empty', () => {
    const bitIds = new (_bitIds().default)();
    const result = (0, _resolveLatestVersion().default)(bitIds, idWithNoVersion);
    (0, _chai().expect)(result).to.deep.equal(idWithNoVersion);
  });
  it('should return the same id when bitIds does not have the bit id', () => {
    const anotherId = new (_bitId().default)({
      name: 'is-type'
    });
    const bitIds = new (_bitIds().default)(anotherId);
    const result = (0, _resolveLatestVersion().default)(bitIds, idWithNoVersion);
    (0, _chai().expect)(result).to.deep.equal(idWithNoVersion);
  });
  it('should throw when using a pre-release tag', () => {
    const anotherId = new (_bitId().default)({
      scope: 'foo',
      name: 'is-type'
    });
    const idWithPreRelease = new (_bitId().default)({
      scope: 'foo',
      name: 'is-type',
      version: '3.0.0-dev.1'
    });
    const bitIds = new (_bitIds().default)(idWithPreRelease);

    const func = () => (0, _resolveLatestVersion().default)(bitIds, anotherId);

    (0, _chai().expect)(func).to.throw('semver was not able to find the highest version among the following: 3.0.0-dev.1');
  });
  it('should return the id from the bitIds array if it is there with a version', () => {
    const bitIds = new (_bitIds().default)(idWithVersion1);
    const result = (0, _resolveLatestVersion().default)(bitIds, idWithNoVersion);
    (0, _chai().expect)(result).to.not.deep.equal(idWithNoVersion);
    (0, _chai().expect)(result).to.deep.equal(idWithVersion1);
  });
  it('should return the id with the latest version when given id does not have a version', () => {
    const bitIds = new (_bitIds().default)(idWithVersion2, idWithVersion3, idWithVersion1);
    const result = (0, _resolveLatestVersion().default)(bitIds, idWithNoVersion);
    (0, _chai().expect)(result).to.not.deep.equal(idWithNoVersion);
    (0, _chai().expect)(result).to.deep.equal(idWithVersion3);
  });
  it('should return the id with the latest version when given id has version "latest"', () => {
    const bitIds = new (_bitIds().default)(idWithVersion2, idWithVersion3, idWithVersion1);
    const result = (0, _resolveLatestVersion().default)(bitIds, idWithVersionLatest);
    (0, _chai().expect)(result).to.not.deep.equal(idWithVersionLatest);
    (0, _chai().expect)(result).to.deep.equal(idWithVersion3);
  });
  it('should not return the id with the latest version when given id has already a version', () => {
    const bitIds = new (_bitIds().default)(idWithVersion2, idWithVersion3, idWithVersion1);
    const result = (0, _resolveLatestVersion().default)(bitIds, idWithVersion1);
    (0, _chai().expect)(result).to.not.deep.equal(idWithVersion3);
    (0, _chai().expect)(result).to.deep.equal(idWithVersion1);
  });
  it('should return the id from the bitIds array if it is there with same version and same scope', () => {
    const bitIds = new (_bitIds().default)(idWithVersion1WithScope);
    const result = (0, _resolveLatestVersion().default)(bitIds, idWithNoVersionWithScope);
    (0, _chai().expect)(result).to.not.deep.equal(idWithNoVersionWithScope);
    (0, _chai().expect)(result).to.deep.equal(idWithVersion1WithScope);
  });
  it('should not return the id from the bitIds array if it is there with same version but different scope', () => {
    const idWithDifferentScope = new (_bitId().default)({
      scope: 'my-another-scope',
      name: 'is-string',
      version: '0.0.1'
    });
    const bitIds = new (_bitIds().default)(idWithDifferentScope);
    const result = (0, _resolveLatestVersion().default)(bitIds, idWithNoVersionWithScope);
    (0, _chai().expect)(result).to.not.deep.equal(idWithDifferentScope);
    (0, _chai().expect)(result).to.deep.equal(idWithNoVersionWithScope);
  });
  it('should not return the id from the bitIds array if it is there with same version but empty scope', () => {
    const bitIds = new (_bitIds().default)(idWithVersion1);
    const result = (0, _resolveLatestVersion().default)(bitIds, idWithNoVersionWithScope);
    (0, _chai().expect)(result).to.not.deep.equal(idWithVersion1);
    (0, _chai().expect)(result).to.deep.equal(idWithNoVersionWithScope);
  });
  it('should return the same id when bitIds has a similar id where its name is equal to scopereadonly name of the id', () => {
    const idWithScope = new (_bitId().default)({
      scope: 'is',
      name: 'string'
    });
    const idWithoutScope = new (_bitId().default)({
      name: 'is/string',
      version: '0.0.1'
    });
    const bitIds = new (_bitIds().default)(idWithoutScope);
    const result = (0, _resolveLatestVersion().default)(bitIds, idWithScope);
    (0, _chai().expect)(result).to.deep.equal(idWithScope);
  });
});