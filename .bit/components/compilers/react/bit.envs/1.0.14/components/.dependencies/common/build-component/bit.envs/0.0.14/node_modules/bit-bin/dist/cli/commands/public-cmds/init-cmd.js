"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function pathlib() {
  const data = _interopRequireWildcard(require("path"));

  pathlib = function () {
    return data;
  };

  return data;
}

function _command() {
  const data = _interopRequireDefault(require("../../command"));

  _command = function () {
    return data;
  };

  return data;
}

function _scope() {
  const data = require("../../../api/scope");

  _scope = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../api/consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _interactive() {
  const data = require("../../../interactive");

  _interactive = function () {
    return data;
  };

  return data;
}

function _objectClean() {
  const data = _interopRequireDefault(require("../../../utils/object-clean"));

  _objectClean = function () {
    return data;
  };

  return data;
}

function _shouldShowInteractive() {
  const data = _interopRequireDefault(require("../../../interactive/utils/should-show-interactive"));

  _shouldShowInteractive = function () {
    return data;
  };

  return data;
}

class Init extends _command().default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2().default)(this, "name", 'init [path]');
    (0, _defineProperty2().default)(this, "skipWorkspace", true);
    (0, _defineProperty2().default)(this, "description", `initialize an empty bit scope\n  https://${_constants().BASE_DOCS_DOMAIN}/docs/workspace`);
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "opts", [['b', 'bare [name]', 'initialize an empty bit bare scope'], ['s', 'shared <groupname>', 'add group write permissions to a scope properly'], ['T', 'standalone [boolean]', 'do not nest component store within .git directory and do not write config data inside package.json'], ['r', 'reset', 'write missing or damaged Bit files'], ['', 'reset-hard', 'delete all Bit files and directories, including Bit configuration, tracking and model data. Useful for re-start using Bit from scratch'], ['c', 'compiler <compiler>', 'set up compiler'], ['t', 'tester <tester>', 'set up tester'], ['d', 'default-directory <default-directory>', 'set up default directory to import components into'], ['p', 'package-manager <package-manager>', 'set up package manager (npm or yarn)'], ['f', 'force', 'force workspace initialization without clearing local objects'], ['I', 'interactive', 'EXPERIMENTAL. start an interactive process']]);
  }

  action([path], flags) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (!_isAnyNotInteractiveFlagUsed(flags) && (flags.interactive || (0, _shouldShowInteractive().default)(_constants().CFG_INIT_INTERACTIVE))) {
      return (0, _interactive().initInteractive)();
    }

    const {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      bare,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      shared,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      standalone,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      reset,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      resetHard,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      force,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      compiler,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      tester,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      defaultDirectory,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      packageManager
    } = flags;
    if (path) path = pathlib().resolve(path);

    if (bare) {
      if (reset || resetHard) throw new (_generalError().default)('--reset and --reset-hard flags are not available for bare scope'); // Handle both cases init --bare and init --bare [scopeName]

      const bareVal = bare === true ? '' : bare;
      return (0, _scope().initScope)(path, bareVal, shared).then(({
        created
      }) => {
        return {
          created,
          bare: true
        };
      });
    }

    if (reset && resetHard) throw new (_generalError().default)('please use --reset or --reset-hard. not both');
    const workspaceConfigProps = {
      compiler,
      tester,
      componentsDefaultDirectory: defaultDirectory,
      packageManager
    };
    return (0, _consumer().init)(path, standalone, reset, resetHard, force, workspaceConfigProps).then(({
      created,
      addedGitHooks,
      existingGitHooks
    }) => {
      return {
        created,
        addedGitHooks,
        existingGitHooks,
        reset,
        resetHard
      };
    });
  }

  report({
    created,
    bare,
    reset,
    resetHard
  }) {
    if (bare) {
      // if (!created) return `${chalk.grey('successfully reinitialized a bare bit scope.')}`;
      // @TODO - a case that you already have a bit scope
      return `${_chalk().default.green('successfully initialized an empty bare bit scope.')}`;
    }

    let initMessage = `${_chalk().default.green('successfully initialized a bit workspace.')}`;
    if (!created) initMessage = `${_chalk().default.grey('successfully reinitialized a bit workspace.')}`;
    if (reset) initMessage = `${_chalk().default.grey('your bit workspace has been reset successfully.')}`;
    if (resetHard) initMessage = `${_chalk().default.grey('your bit workspace has been hard-reset successfully.')}`; // const addedGitHooksTemplate = _generateAddedGitHooksTemplate(addedGitHooks);
    // const existingGitHooksTemplate = _generateExistingGitHooksTemplate(existingGitHooks);
    // return `${initMessage}\n${addedGitHooksTemplate}\n${existingGitHooksTemplate}`;

    return initMessage;
  }

}

exports.default = Init;

function _isAnyNotInteractiveFlagUsed(flags) {
  const withoutInteractive = _ramda().default.omit(['interactive'], flags);

  const cleaned = (0, _objectClean().default)(withoutInteractive);
  return !_ramda().default.isEmpty(cleaned);
} // function _generateAddedGitHooksTemplate(addedGitHooks) {
//   if (addedGitHooks && addedGitHooks.length > 0) {
//     return chalk.green(`the following git hooks were added: ${addedGitHooks.join(', ')}`);
//   }
//   return '';
// }
// function _generateExistingGitHooksTemplate(existingGitHooks) {
//   if (existingGitHooks && existingGitHooks.length > 0) {
//     return chalk.yellow(
//       `warning: the following git hooks are already existing: ${existingGitHooks.join(
//         ', '
//       )}\nplease add the following code to your hooks: \`bit import\``
//     );
//   }
//   return '';
// }