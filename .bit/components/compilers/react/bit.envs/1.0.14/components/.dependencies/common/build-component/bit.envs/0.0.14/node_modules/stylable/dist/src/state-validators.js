"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:max-line-length */
var validationErrors = {
    string: {
        STRING_TYPE_VALIDATION_FAILED: function (actualParam) { return "\"" + actualParam + "\" should be of type string"; },
        REGEX_VALIDATION_FAILED: function (regex, actualParam) { return "expected \"" + actualParam + "\" to match regex \"" + regex + "\""; },
        CONTAINS_VALIDATION_FAILED: function (shouldContain, actualParam) { return "expected \"" + actualParam + "\" to contain string \"" + shouldContain + "\""; },
        MIN_LENGTH_VALIDATION_FAILED: function (length, actualParam) { return "expected \"" + actualParam + "\" to be of length longer than or equal to " + length; },
        MAX_LENGTH_VALIDATION_FAILED: function (length, actualParam) { return "expected \"" + actualParam + "\" to be of length shorter than or equal to " + length; },
        UKNOWN_VALIDATOR: function (name) { return "encountered unknown string validator \"" + name + "\""; }
    },
    number: {
        NUMBER_TYPE_VALIDATION_FAILED: function (actualParam) { return "expected \"" + actualParam + "\" to be of type number"; },
        MIN_VALIDATION_FAILED: function (actualParam, min) { return "expected \"" + actualParam + "\" to be larger than or equal to " + min; },
        MAX_VALIDATION_FAILED: function (actualParam, max) { return "expected \"" + actualParam + "\" to be lesser then or equal to " + max; },
        MULTIPLE_OF_VALIDATION_FAILED: function (actualParam, multipleOf) { return "expected \"" + actualParam + "\" to be a multiple of " + multipleOf; },
        UKNOWN_VALIDATOR: function (name) { return "encountered unknown number validator \"" + name + "\""; }
    },
    enum: {
        ENUM_TYPE_VALIDATION_FAILED: function (actualParam, options) { return "expected \"" + actualParam + "\" to be one of the options: \"" + options.join(', ') + "\""; },
        NO_OPTIONS_DEFINED: function () { return "expected enum to be defined with one option or more"; }
    },
    tag: {
        NO_SPACES_ALLOWED: function (actualParam) { return "expected \"" + actualParam + "\" to be a single value with no spaces"; }
    }
};
exports.systemValidators = {
    string: {
        validate: function (value, validators, resolveParam, validateDefinition, validateValue) {
            var _this = this;
            var res = value;
            var errors = [];
            if (validateValue && typeof value !== 'string') {
                errors.push(validationErrors.string.STRING_TYPE_VALIDATION_FAILED(value));
            }
            if (validators.length > 0) {
                validators.forEach(function (validatorMeta) {
                    if (typeof validatorMeta === 'object') {
                        if (_this.subValidators && _this.subValidators[validatorMeta.name]) {
                            var subValidator = _this.subValidators[validatorMeta.name];
                            var validationRes = subValidator(value, resolveParam(validatorMeta.args[0]));
                            if (validateValue && validationRes.errors) {
                                errors.push.apply(errors, validationRes.errors);
                            }
                        }
                        else if (validateDefinition) {
                            errors.push(validationErrors.string.UKNOWN_VALIDATOR(validatorMeta.name));
                        }
                    }
                });
            }
            return { res: res, errors: errors.length ? errors : null };
        },
        subValidators: {
            regex: function (value, regex) {
                var r = new RegExp(regex);
                var valid = r.test(value);
                return {
                    res: value,
                    errors: valid ?
                        null :
                        [validationErrors.string.REGEX_VALIDATION_FAILED(regex, value)]
                };
            },
            contains: function (value, checkedValue) {
                var valid = !!~value.indexOf(checkedValue);
                return {
                    res: value,
                    errors: valid ?
                        null :
                        [validationErrors.string.CONTAINS_VALIDATION_FAILED(checkedValue, value)]
                };
            },
            minLength: function (value, length) {
                var valid = value.length > Number(length);
                return {
                    res: value,
                    errors: valid ?
                        null :
                        [validationErrors.string.MIN_LENGTH_VALIDATION_FAILED(length, value)]
                };
            },
            maxLength: function (value, length) {
                var valid = value.length < Number(length);
                return {
                    res: value,
                    errors: valid ?
                        null :
                        [validationErrors.string.MAX_LENGTH_VALIDATION_FAILED(length, value)]
                };
            }
        }
    },
    number: {
        validate: function (value, validators, resolveParam, validateDefinition, validateValue) {
            var _this = this;
            var res = value;
            var errors = [];
            if (isNaN(value)) {
                if (validateValue) {
                    errors.push(validationErrors.number.NUMBER_TYPE_VALIDATION_FAILED(value));
                }
            }
            else if (validators.length > 0) {
                validators.forEach(function (validatorMeta) {
                    if (typeof validatorMeta === 'object') {
                        if (_this.subValidators && _this.subValidators[validatorMeta.name]) {
                            var subValidator = _this.subValidators[validatorMeta.name];
                            var validationRes = subValidator(value, resolveParam(validatorMeta.args[0]));
                            if (validateValue && validationRes.errors) {
                                errors.push.apply(errors, validationRes.errors);
                            }
                        }
                        else if (validateDefinition) {
                            errors.push(validationErrors.number.UKNOWN_VALIDATOR(validatorMeta.name));
                        }
                    }
                });
            }
            return { res: res, errors: errors.length ? errors : null };
        },
        subValidators: {
            min: function (value, minValue) {
                var valid = Number(value) > Number(minValue);
                return {
                    res: value,
                    errors: valid ?
                        null :
                        [validationErrors.number.MIN_VALIDATION_FAILED(value, minValue)]
                };
            },
            max: function (value, maxValue) {
                var valid = Number(value) < Number(maxValue);
                return {
                    res: value,
                    errors: valid ?
                        null :
                        [validationErrors.number.MAX_VALIDATION_FAILED(value, maxValue)]
                };
            },
            multipleOf: function (value, multipleOf) {
                var valid = Number(value) % Number(multipleOf) === 0;
                return {
                    res: value,
                    errors: valid ?
                        null :
                        [validationErrors.number.MULTIPLE_OF_VALIDATION_FAILED(value, multipleOf)]
                };
            }
        }
    },
    enum: {
        validate: function (value, options, resolveParam, validateDefinition, validateValue) {
            var res = value;
            var errors = [];
            var stringOptions = [];
            if (options.length) {
                var isOneOf = options.some(function (option) {
                    if (typeof option === 'string') {
                        stringOptions.push(option);
                        return resolveParam(option) === value;
                    }
                    return true;
                });
                if (validateValue && !isOneOf) {
                    errors.push(validationErrors.enum.ENUM_TYPE_VALIDATION_FAILED(value, stringOptions));
                }
            }
            else if (validateDefinition) {
                errors.push(validationErrors.enum.NO_OPTIONS_DEFINED());
            }
            return { res: res, errors: errors.length ? errors : null };
        }
    },
    tag: {
        validate: function (value, _options, _resolveParam, _validateDefinition, validateValue) {
            var errors = [];
            if (validateValue && ~value.indexOf(' ')) {
                errors.push(validationErrors.tag.NO_SPACES_ALLOWED(value));
            }
            return { res: value, errors: errors.length ? errors : null };
        }
    }
};
//# sourceMappingURL=state-validators.js.map