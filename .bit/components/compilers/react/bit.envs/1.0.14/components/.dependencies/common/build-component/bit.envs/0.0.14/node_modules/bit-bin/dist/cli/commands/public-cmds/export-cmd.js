"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _command() {
  const data = _interopRequireDefault(require("../../command"));

  _command = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../api/consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _ejectTemplate() {
  const data = _interopRequireDefault(require("../../templates/eject-template"));

  _ejectTemplate = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class Export extends _command().default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2().default)(this, "name", 'export [remote] [id...]');
    (0, _defineProperty2().default)(this, "description", `export components to a remote scope.
  bit export <remote> [id...] => export (optionally given ids) to the specified remote
  bit export ${_constants().CURRENT_UPSTREAM} [id...] => export (optionally given ids) to their current scope
  bit export => export all staged components to their current scope
  https://${_constants().BASE_DOCS_DOMAIN}/docs/export
  ${(0, _constants().WILDCARD_HELP)('export remote-scope')}`);
    (0, _defineProperty2().default)(this, "alias", 'e');
    (0, _defineProperty2().default)(this, "opts", [['e', 'eject', 'replaces the exported components from the local scope with the corresponding packages'], ['a', 'all', 'export all components include non-staged'], ['d', 'include-dependencies', "EXPERIMENTAL. include the component's dependencies as part of the export to the remote scope"], ['s', 'set-current-scope', "EXPERIMENTAL. ensure the component's remote scope is set according to the target location"], ['r', 'rewire', 'EXPERIMENTAL. when exporting to a different scope, replace import/require statements in the source code to the new scope'], ['f', 'force', 'force changing a component remote without asking for a confirmation']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
  }

  action([remote, ids], {
    eject = false,
    includeDependencies = false,
    setCurrentScope = false,
    all = false,
    force = false,
    rewire = false
  }) {
    const currentScope = !remote || remote === _constants().CURRENT_UPSTREAM;

    if (currentScope && remote) {
      remote = '';
    }

    if (includeDependencies && !remote) {
      throw new (_generalError().default)('to use --includeDependencies, please specify a remote (the default remote gets already the dependencies)');
    }

    if (rewire && !includeDependencies) {
      throw new (_generalError().default)('to use --rewire, please enter --include-dependencies as well (there is no point of changing the require/import of dependencies without changing themselves)');
    }

    return (0, _consumer().exportAction)({
      ids,
      remote,
      eject,
      includeDependencies,
      setCurrentScope,
      includeNonStaged: all,
      codemod: rewire,
      force
    }).then(results => _objectSpread({}, results, {
      remote,
      includeDependencies
    }));
  }

  report({
    componentsIds,
    nonExistOnBitMap,
    missingScope,
    ejectResults,
    remote,
    includeDependencies
  }) {
    if (_ramda().default.isEmpty(componentsIds) && _ramda().default.isEmpty(nonExistOnBitMap) && _ramda().default.isEmpty(missingScope)) {
      return _chalk().default.yellow('nothing to export');
    }

    const exportOutput = () => {
      if (_ramda().default.isEmpty(componentsIds)) return '';
      if (remote) return _chalk().default.green(`exported ${componentsIds.length} components to scope ${_chalk().default.bold(remote)}`);
      return _chalk().default.green(`exported the following ${componentsIds.length} component(s):\n${_chalk().default.bold(componentsIds.join('\n'))}`);
    };

    const nonExistOnBitMapOutput = () => {
      // if includeDependencies is true, the nonExistOnBitMap might be the dependencies
      if (_ramda().default.isEmpty(nonExistOnBitMap) || includeDependencies) return '';
      const ids = nonExistOnBitMap.map(id => id.toString()).join(', ');
      return _chalk().default.yellow(`${ids}\nexported successfully. bit did not update the workspace as the component files are not tracked. this might happen when a component was tracked in a different git branch. to fix it check if they where tracked in a different git branch, checkout to that branch and resync by running 'bit import'. or stay on your branch and track the components again using 'bit add'.\n`);
    };

    const missingScopeOutput = () => {
      if (_ramda().default.isEmpty(missingScope)) return '';
      const ids = missingScope.map(id => id.toString()).join(', ');
      return _chalk().default.yellow(`the following component(s) were not exported: ${_chalk().default.bold(ids)}.\nplease specify <remote> to export them, or set a "defaultScope" in your workspace config\n\n`);
    };

    const ejectOutput = () => {
      if (!ejectResults) return '';
      const output = (0, _ejectTemplate().default)(ejectResults);
      return `\n${output}`;
    };

    return nonExistOnBitMapOutput() + missingScopeOutput() + exportOutput() + ejectOutput();
  }

}

exports.default = Export;