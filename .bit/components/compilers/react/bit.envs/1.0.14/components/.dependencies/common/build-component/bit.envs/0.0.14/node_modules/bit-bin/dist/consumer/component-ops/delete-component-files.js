"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("../component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _removePath() {
  const data = _interopRequireDefault(require("../component/sources/remove-path"));

  _removePath = function () {
    return data;
  };

  return data;
}

function _dists() {
  const data = _interopRequireDefault(require("../component/sources/dists"));

  _dists = function () {
    return data;
  };

  return data;
}

var _default =
/*#__PURE__*/
function () {
  var _deleteComponentsFiles = (0, _bluebird().coroutine)(function* (consumer, bitIds, deleteFilesForAuthor) {
    _logger().default.debug(`deleteComponentsFiles, ids: ${bitIds.toString()}`);

    const filesToDelete = getFilesToDelete();
    filesToDelete.addBasePath(consumer.getPath());
    return filesToDelete.persistAllToFS();

    function getFilesToDelete() {
      const dataToPersist = new (_dataToPersist().default)();
      bitIds.forEach(id => {
        const ignoreVersion = id.isLocal() || !id.hasVersion();
        const componentMap = consumer.bitMap.getComponentIfExist(id, {
          ignoreVersion
        });

        if (!componentMap) {
          _logger().default.warn(`deleteComponentsFiles was unable to delete ${id.toString()} because the id is missing from bitmap`);

          return null;
        }

        if (componentMap.origin === _constants().COMPONENT_ORIGINS.IMPORTED || componentMap.origin === _constants().COMPONENT_ORIGINS.NESTED) {
          // $FlowFixMe rootDir is set for non authored
          // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
          const rootDir = componentMap.rootDir;
          dataToPersist.removePath(new (_removePath().default)(rootDir, true));

          if (!consumer.shouldDistsBeInsideTheComponent()) {
            const distDir = _dists().default.getDistDirWhenDistIsOutsideCompDir(consumer.config, rootDir);

            dataToPersist.removePath(new (_removePath().default)(distDir, true));
          }
        } else if (componentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED && deleteFilesForAuthor) {
          const filesToRemove = componentMap.getAllFilesPaths().map(f => new (_removePath().default)(f));
          dataToPersist.removeManyPaths(filesToRemove);
        }

        return null;
      });
      return dataToPersist;
    }
  });

  function deleteComponentsFiles(_x, _x2, _x3) {
    return _deleteComponentsFiles.apply(this, arguments);
  }

  return deleteComponentsFiles;
}();

exports.default = _default;