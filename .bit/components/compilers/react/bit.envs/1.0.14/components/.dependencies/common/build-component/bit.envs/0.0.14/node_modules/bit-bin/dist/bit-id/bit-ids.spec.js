"use strict";

function _chai() {
  const data = require("chai");

  _chai = function () {
    return data;
  };

  return data;
}

function _() {
  const data = require(".");

  _ = function () {
    return data;
  };

  return data;
}

describe('bitIds', () => {
  describe('uniqFromArray', () => {
    it('should return a uniq array with no duplications', () => {
      const a = new (_().BitId)({
        name: 'a'
      });
      const b = new (_().BitId)({
        name: 'a'
      });
      (0, _chai().expect)(_().BitIds.uniqFromArray([a, b])).to.have.lengthOf(1);
    });
  });
  describe('search functions', () => {
    let bitIds;
    before(() => {
      const a = new (_().BitId)({
        name: 'a',
        scope: 'my-scope',
        version: '0.0.1'
      });
      const b = new (_().BitId)({
        name: 'b'
      });
      const c = new (_().BitId)({
        name: 'c'
      });
      bitIds = new (_().BitIds)(a, b, c);
    });
    describe('search', () => {
      it('should find an exact match', () => {
        const result = bitIds.search(new (_().BitId)({
          name: 'a',
          scope: 'my-scope',
          version: '0.0.1'
        }));
        (0, _chai().expect)(result).to.be.an.instanceOf(_().BitId);
        (0, _chai().expect)(result.serialize()).to.deep.equal({
          name: 'a',
          scope: 'my-scope',
          version: '0.0.1'
        });
      });
      it('should find a match when an ID has only name', () => {
        const result = bitIds.search(new (_().BitId)({
          name: 'b'
        }));
        (0, _chai().expect)(result).to.be.an.instanceOf(_().BitId);
        (0, _chai().expect)(result.serialize()).to.deep.equal({
          name: 'b'
        });
      });
      it('should not return a result with a mismatch version', () => {
        const result = bitIds.search(new (_().BitId)({
          name: 'a',
          scope: 'my-scope',
          version: '0.0.2'
        }));
        (0, _chai().expect)(result).to.be.undefined;
      });
      it('should not return a result with a mismatch scope', () => {
        const result = bitIds.search(new (_().BitId)({
          name: 'a',
          scope: 'my-another-scope',
          version: '0.0.1'
        }));
        (0, _chai().expect)(result).to.be.undefined;
      });
    });
    describe('searchWithoutVersion', () => {
      it('should find an exact match', () => {
        const result = bitIds.searchWithoutVersion(new (_().BitId)({
          name: 'a',
          scope: 'my-scope',
          version: '0.0.1'
        }));
        (0, _chai().expect)(result).to.be.an.instanceOf(_().BitId);
        (0, _chai().expect)(result.serialize()).to.deep.equal({
          name: 'a',
          scope: 'my-scope',
          version: '0.0.1'
        });
      });
      it('should return a result even with a mismatch version', () => {
        const result = bitIds.searchWithoutVersion(new (_().BitId)({
          name: 'a',
          scope: 'my-scope',
          version: '0.0.2'
        }));
        (0, _chai().expect)(result).to.be.an.instanceOf(_().BitId);
        (0, _chai().expect)(result.serialize()).to.deep.equal({
          name: 'a',
          scope: 'my-scope',
          version: '0.0.1'
        });
      });
      it('should not return a result with a mismatch scope', () => {
        const result = bitIds.searchWithoutVersion(new (_().BitId)({
          name: 'a',
          scope: 'my-another-scope',
          version: '0.0.1'
        }));
        (0, _chai().expect)(result).to.be.undefined;
      });
    });
    describe('searchWithoutScopeAndVersion', () => {
      it('should find an exact match', () => {
        const result = bitIds.searchWithoutScopeAndVersion(new (_().BitId)({
          name: 'a',
          scope: 'my-scope',
          version: '0.0.1'
        }));
        (0, _chai().expect)(result).to.be.an.instanceOf(_().BitId);
        (0, _chai().expect)(result.serialize()).to.deep.equal({
          name: 'a',
          scope: 'my-scope',
          version: '0.0.1'
        });
      });
      it('should return a result even with a mismatch version', () => {
        const result = bitIds.searchWithoutScopeAndVersion(new (_().BitId)({
          name: 'a',
          scope: 'my-scope',
          version: '0.0.2'
        }));
        (0, _chai().expect)(result).to.be.an.instanceOf(_().BitId);
        (0, _chai().expect)(result.serialize()).to.deep.equal({
          name: 'a',
          scope: 'my-scope',
          version: '0.0.1'
        });
      });
      it('should return a result even with a mismatch scope', () => {
        const result = bitIds.searchWithoutScopeAndVersion(new (_().BitId)({
          name: 'a',
          scope: 'my-another-scope',
          version: '0.0.1'
        }));
        (0, _chai().expect)(result).to.be.an.instanceOf(_().BitId);
        (0, _chai().expect)(result.serialize()).to.deep.equal({
          name: 'a',
          scope: 'my-scope',
          version: '0.0.1'
        });
      });
    });
  });
});