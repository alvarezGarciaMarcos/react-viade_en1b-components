/**
 * Bind instance methods
 * @function abind
 * @param {Object} instance - Instance to bind
 * @param {Object} [options={}] - Optional settings
 * @param {Object} [options.proto=getPrototypeOf(instance)] - Prototype to bind
 * @param {string[]} [options.excludes] - Names to exclude
 * @returns {Object} instance - Bounded instance
 */
'use strict';
/** @lends abind */

function abind(instance) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var _options$proto = options.proto,
      proto = _options$proto === void 0 ? Object.getPrototypeOf(instance) : _options$proto,
      _options$excludes = options.excludes,
      excludes = _options$excludes === void 0 ? [] : _options$excludes;
  var propertyNames = Object.getOwnPropertyNames(proto).filter(function (name) {
    return !~excludes.indexOf(name);
  });
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = propertyNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var name = _step.value;

      var _ref = Object.getOwnPropertyDescriptor && Object.getOwnPropertyDescriptor(proto, name),
          get = _ref.get,
          set = _ref.set;

      var shouldBind = !/^__/.test(name) && (get || set);

      if (shouldBind) {
        Object.defineProperty(instance, name, {
          get: get,
          set: set
        });
        continue;
      }

      var value = proto[name];

      if (typeof value === 'function') {
        instance[name] = value.bind(instance);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return != null) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return instance;
}

module.exports = abind;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImFiaW5kLmpzIl0sIm5hbWVzIjpbImFiaW5kIiwiaW5zdGFuY2UiLCJvcHRpb25zIiwicHJvdG8iLCJPYmplY3QiLCJnZXRQcm90b3R5cGVPZiIsImV4Y2x1ZGVzIiwicHJvcGVydHlOYW1lcyIsImdldE93blByb3BlcnR5TmFtZXMiLCJmaWx0ZXIiLCJuYW1lIiwiaW5kZXhPZiIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsInNldCIsInNob3VsZEJpbmQiLCJ0ZXN0IiwiZGVmaW5lUHJvcGVydHkiLCJ2YWx1ZSIsImJpbmQiLCJtb2R1bGUiLCJleHBvcnRzIl0sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7O0FBU0E7QUFFQTs7QUFDQSxTQUFTQSxLQUFULENBQWVDLFFBQWYsRUFBdUM7QUFBQSxNQUFkQyxPQUFjLHVFQUFKLEVBQUk7QUFBQSx1QkFJakNBLE9BSmlDLENBRW5DQyxLQUZtQztBQUFBLE1BRW5DQSxLQUZtQywrQkFFM0JDLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQkosUUFBdEIsQ0FGMkI7QUFBQSwwQkFJakNDLE9BSmlDLENBR25DSSxRQUhtQztBQUFBLE1BR25DQSxRQUhtQyxrQ0FHeEIsRUFId0I7QUFLckMsTUFBTUMsYUFBYSxHQUFHSCxNQUFNLENBQUNJLG1CQUFQLENBQTJCTCxLQUEzQixFQUNuQk0sTUFEbUIsQ0FDWixVQUFDQyxJQUFEO0FBQUEsV0FBVSxDQUFDLENBQUNKLFFBQVEsQ0FBQ0ssT0FBVCxDQUFpQkQsSUFBakIsQ0FBWjtBQUFBLEdBRFksQ0FBdEI7QUFMcUM7QUFBQTtBQUFBOztBQUFBO0FBT3JDLHlCQUFtQkgsYUFBbkIsOEhBQWtDO0FBQUEsVUFBdkJHLElBQXVCOztBQUFBLGlCQUNiTixNQUFNLENBQUNRLHdCQUFQLElBQW1DUixNQUFNLENBQUNRLHdCQUFQLENBQWdDVCxLQUFoQyxFQUF1Q08sSUFBdkMsQ0FEdEI7QUFBQSxVQUMxQkcsR0FEMEIsUUFDMUJBLEdBRDBCO0FBQUEsVUFDckJDLEdBRHFCLFFBQ3JCQSxHQURxQjs7QUFFaEMsVUFBSUMsVUFBVSxHQUFHLENBQUMsTUFBTUMsSUFBTixDQUFXTixJQUFYLENBQUQsS0FBc0JHLEdBQUcsSUFBSUMsR0FBN0IsQ0FBakI7O0FBQ0EsVUFBSUMsVUFBSixFQUFnQjtBQUNkWCxRQUFBQSxNQUFNLENBQUNhLGNBQVAsQ0FBc0JoQixRQUF0QixFQUFnQ1MsSUFBaEMsRUFBc0M7QUFDcENHLFVBQUFBLEdBQUcsRUFBSEEsR0FEb0M7QUFFcENDLFVBQUFBLEdBQUcsRUFBSEE7QUFGb0MsU0FBdEM7QUFJQTtBQUNEOztBQUNELFVBQUlJLEtBQUssR0FBR2YsS0FBSyxDQUFDTyxJQUFELENBQWpCOztBQUNBLFVBQUksT0FBT1EsS0FBUCxLQUFpQixVQUFyQixFQUFpQztBQUMvQmpCLFFBQUFBLFFBQVEsQ0FBQ1MsSUFBRCxDQUFSLEdBQWlCUSxLQUFLLENBQUNDLElBQU4sQ0FBV2xCLFFBQVgsQ0FBakI7QUFDRDtBQUNGO0FBckJvQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQXNCckMsU0FBT0EsUUFBUDtBQUNEOztBQUVEbUIsTUFBTSxDQUFDQyxPQUFQLEdBQWlCckIsS0FBakIiLCJzb3VyY2VSb290IjoiLi4vLi4vbGliIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCaW5kIGluc3RhbmNlIG1ldGhvZHNcbiAqIEBmdW5jdGlvbiBhYmluZFxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlIC0gSW5zdGFuY2UgdG8gYmluZFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIE9wdGlvbmFsIHNldHRpbmdzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucHJvdG89Z2V0UHJvdG90eXBlT2YoaW5zdGFuY2UpXSAtIFByb3RvdHlwZSB0byBiaW5kXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBbb3B0aW9ucy5leGNsdWRlc10gLSBOYW1lcyB0byBleGNsdWRlXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBpbnN0YW5jZSAtIEJvdW5kZWQgaW5zdGFuY2VcbiAqL1xuJ3VzZSBzdHJpY3QnXG5cbi8qKiBAbGVuZHMgYWJpbmQgKi9cbmZ1bmN0aW9uIGFiaW5kKGluc3RhbmNlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGluc3RhbmNlKSxcbiAgICBleGNsdWRlcyA9IFtdXG4gIH0gPSBvcHRpb25zXG4gIGNvbnN0IHByb3BlcnR5TmFtZXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhwcm90bylcbiAgICAuZmlsdGVyKChuYW1lKSA9PiAhfmV4Y2x1ZGVzLmluZGV4T2YobmFtZSkpXG4gIGZvciAoY29uc3QgbmFtZSBvZiBwcm9wZXJ0eU5hbWVzKSB7XG4gICAgbGV0IHsgZ2V0LCBzZXQgfSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihwcm90bywgbmFtZSlcbiAgICBsZXQgc2hvdWxkQmluZCA9ICEvXl9fLy50ZXN0KG5hbWUpICYmIChnZXQgfHwgc2V0KVxuICAgIGlmIChzaG91bGRCaW5kKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdGFuY2UsIG5hbWUsIHtcbiAgICAgICAgZ2V0LFxuICAgICAgICBzZXRcbiAgICAgIH0pXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBsZXQgdmFsdWUgPSBwcm90b1tuYW1lXVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluc3RhbmNlW25hbWVdID0gdmFsdWUuYmluZChpbnN0YW5jZSlcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGluc3RhbmNlXG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWJpbmRcbiJdfQ==