"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _checkoutVersion() {
  const data = _interopRequireDefault(require("../../../consumer/versions-ops/checkout-version"));

  _checkoutVersion = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../../../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("../../../utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _noIdMatchWildcard() {
  const data = _interopRequireDefault(require("./exceptions/no-id-match-wildcard"));

  _noIdMatchWildcard = function () {
    return data;
  };

  return data;
}

var _default =
/*#__PURE__*/
function () {
  var _checkout = (0, _bluebird().coroutine)(function* (values, checkoutProps) {
    _loader().default.start(_loaderMessages().BEFORE_CHECKOUT);

    const consumer = yield (0, _consumer().loadConsumer)();
    yield parseValues(consumer, values, checkoutProps);
    const checkoutResults = yield (0, _checkoutVersion().default)(consumer, checkoutProps);
    yield consumer.onDestroy();
    return checkoutResults;
  });

  function checkout(_x, _x2) {
    return _checkout.apply(this, arguments);
  }

  return checkout;
}();

exports.default = _default;

function parseValues(_x3, _x4, _x5) {
  return _parseValues.apply(this, arguments);
}
/**
 * when user didn't enter any id and used '--all' flag, populate all ids.
 */


function _parseValues() {
  _parseValues = (0, _bluebird().coroutine)(function* (consumer, values, checkoutProps) {
    const firstValue = _ramda().default.head(values);

    checkoutProps.version = firstValue && (_bitId().BitId.isValidVersion(firstValue) || firstValue === _constants().LATEST) ? firstValue : undefined;
    const ids = checkoutProps.version ? _ramda().default.tail(values) : values; // if first value is a version, the rest are ids

    checkoutProps.latestVersion = Boolean(checkoutProps.version && checkoutProps.version === _constants().LATEST);

    if (!firstValue && !checkoutProps.reset && !checkoutProps.all) {
      throw new (_generalError().default)('please enter [values...] or use --reset --all flags');
    }

    if (checkoutProps.reset && checkoutProps.version) {
      throw new (_generalError().default)(`the first argument "${checkoutProps.version}" seems to be a version. however, --reset flag doesn't support a version`);
    }

    if (!checkoutProps.reset && !checkoutProps.version) {
      if (ids.length) throw new (_generalError().default)(`the specified version "${ids[0]}" is not a valid version`);else throw new (_generalError().default)('please specify a version');
    }

    if (ids.length && checkoutProps.all) {
      throw new (_generalError().default)('please specify either [ids...] or --all, not both');
    }

    if (!ids.length) {
      populateAllIds(consumer, checkoutProps);
    } else {
      const idsHasWildcard = (0, _hasWildcard().default)(ids);
      checkoutProps.ids = idsHasWildcard ? getIdsMatchedByWildcard(consumer, checkoutProps, ids) : ids.map(id => consumer.getParsedId(id));
    }
  });
  return _parseValues.apply(this, arguments);
}

function populateAllIds(consumer, checkoutProps) {
  if (!checkoutProps.all) {
    throw new (_generalError().default)('please specify [ids...] or use --all flag');
  }

  checkoutProps.ids = getCandidateIds(consumer, checkoutProps);
}

function getIdsMatchedByWildcard(consumer, checkoutProps, ids) {
  const candidateIds = getCandidateIds(consumer, checkoutProps);

  const matchedIds = _componentsList().default.filterComponentsByWildcard(candidateIds, ids);

  if (!matchedIds.length) throw new (_noIdMatchWildcard().default)(ids);
  return matchedIds;
}

function getCandidateIds(consumer, checkoutProps) {
  const idsFromBitMap = consumer.bitMap.getAuthoredAndImportedBitIds();
  return idsFromBitMap.map(bitId => {
    const version = checkoutProps.latestVersion ? _constants().LATEST : bitId.version;
    return bitId.changeVersion(version);
  });
}