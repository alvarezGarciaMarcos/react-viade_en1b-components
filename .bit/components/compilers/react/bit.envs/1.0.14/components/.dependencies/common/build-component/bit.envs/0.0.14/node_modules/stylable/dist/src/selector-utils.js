"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var tokenizer = require('css-selector-tokenizer');
function parseSelector(selector) {
    return tokenizer.parse(selector);
}
exports.parseSelector = parseSelector;
function stringifySelector(ast) {
    return tokenizer.stringify(ast);
}
exports.stringifySelector = stringifySelector;
function traverseNode(node, visitor, index, nodes) {
    if (index === void 0) { index = 0; }
    if (nodes === void 0) { nodes = [node]; }
    if (!node) {
        return;
    }
    var cNodes = node.nodes;
    var doNext = visitor(node, index, nodes);
    if (doNext === false) {
        return false;
    }
    if (doNext === true) {
        return true;
    }
    if (cNodes) {
        for (var i = 0; i < node.nodes.length; i++) {
            doNext = traverseNode(node.nodes[i], visitor, i, node.nodes);
            if (doNext === true) {
                continue;
            }
            if (doNext === false) {
                return false;
            }
        }
    }
}
exports.traverseNode = traverseNode;
function createChecker(types) {
    return function () {
        var index = 0;
        return function (node) {
            var matcher = types[index];
            if (Array.isArray(matcher)) {
                return matcher.indexOf(node.type) !== -1;
            }
            else if (matcher !== node.type) {
                return false;
            }
            if (types[index] !== node.type) {
                return false;
            }
            index++;
            return true;
        };
    };
}
exports.createChecker = createChecker;
function createRootAfterSpaceChecker() {
    var hasSpacing = false;
    var isValid = true;
    return function (node) {
        if (!node) {
            return isValid;
        }
        if (node.type === 'selector') {
            hasSpacing = false;
        }
        else if (node.type === 'spacing') {
            hasSpacing = true;
        }
        else if (node.type === 'class' && node.name === 'root' && hasSpacing) {
            isValid = false;
        }
        return isValid;
    };
}
exports.createRootAfterSpaceChecker = createRootAfterSpaceChecker;
exports.createSimpleSelectorChecker = createChecker(['selectors', 'selector', ['element', 'class']]);
function isImport(ast) {
    var selectors = ast.nodes[0];
    var selector = selectors && selectors.nodes[0];
    return selector && selector.type === 'pseudo-class' && selector.name === 'import';
}
exports.isImport = isImport;
function matchAtKeyframes(selector) {
    return selector.match(/^@keyframes\s*(.*)/);
}
exports.matchAtKeyframes = matchAtKeyframes;
function matchAtMedia(selector) {
    return selector.match(/^@media\s*(.*)/);
}
exports.matchAtMedia = matchAtMedia;
function isNodeMatch(nodeA, nodeB) {
    return nodeA.type === nodeB.type && nodeA.name === nodeB.name;
}
exports.isNodeMatch = isNodeMatch;
function separateChunks(selectorNode) {
    var selectors = [];
    traverseNode(selectorNode, function (node) {
        if (node.type === 'selectors') {
            // skip
        }
        else if (node.type === 'selector') {
            selectors.push([
                { type: 'selector', nodes: [] }
            ]);
        }
        else if (node.type === 'operator') {
            var chunks = selectors[selectors.length - 1];
            chunks.push({ type: node.type, operator: node.operator, nodes: [] });
        }
        else if (node.type === 'spacing') {
            var chunks = selectors[selectors.length - 1];
            chunks.push({ type: node.type, nodes: [] });
        }
        else {
            var chunks = selectors[selectors.length - 1];
            chunks[chunks.length - 1].nodes.push(node);
        }
    });
    return selectors;
}
exports.separateChunks = separateChunks;
function getLastChunk(selectorChunk) {
    return selectorChunk[selectorChunk.length - 1];
}
function filterChunkNodesByType(chunk, typeOptions) {
    return chunk.nodes.filter(function (node) {
        return node.type && typeOptions.indexOf(node.type) !== -1;
    });
}
exports.filterChunkNodesByType = filterChunkNodesByType;
function isPseudoDiff(a, b) {
    var aNodes = a.pseudo;
    var bNodes = b.pseudo;
    if (!aNodes || !bNodes || aNodes.length !== bNodes.length) {
        return false;
    }
    return aNodes.every(function (node, index) { return isNodeMatch(node, bNodes[index]); });
}
function groupClassesAndPseudoElements(nodes) {
    var nodesWithPseudos = [];
    nodes.forEach(function (node) {
        if (node.type === 'class' || node.type === 'element') {
            nodesWithPseudos.push(__assign({}, node, { pseudo: [] }));
        }
        else if (node.type === 'pseudo-element') {
            nodesWithPseudos[nodesWithPseudos.length - 1].pseudo.push(__assign({}, node));
        }
    });
    var nodesNoDuplicates = [];
    nodesWithPseudos.forEach(function (node) {
        if (node.pseudo.length || !nodesWithPseudos.find(function (n) { return isNodeMatch(n, node) && node !== n; })) {
            nodesNoDuplicates.push(node);
        }
    });
    return nodesNoDuplicates;
}
var containsInTheEnd = function (originalElements, currentMatchingElements) {
    var offset = originalElements.length - currentMatchingElements.length;
    var arraysEqual = false;
    if (offset >= 0 && currentMatchingElements.length > 0) {
        arraysEqual = true;
        for (var i = 0; i < currentMatchingElements.length; i++) {
            var a = originalElements[i + offset];
            var b = currentMatchingElements[i];
            if (a.name !== b.name || a.type !== b.type || !isPseudoDiff(a, b)) {
                arraysEqual = false;
                break;
            }
        }
    }
    return arraysEqual;
};
function matchSelectorTarget(sourceSelector, targetSelector) {
    var a = separateChunks(parseSelector(sourceSelector));
    var b = separateChunks(parseSelector(targetSelector));
    if (a.length > 1) {
        throw new Error('source selector must not be composed of more than one compound selector');
    }
    var lastChunkA = getLastChunk(a[0]);
    var relevantChunksA = groupClassesAndPseudoElements(filterChunkNodesByType(lastChunkA, ['class', 'element', 'pseudo-element']));
    return b.some(function (compoundSelector) {
        var lastChunkB = getLastChunk(compoundSelector);
        var relevantChunksB = groupClassesAndPseudoElements(filterChunkNodesByType(lastChunkB, ['class', 'element', 'pseudo-element']));
        relevantChunksB = relevantChunksB.filter(function (nodeB) { return relevantChunksA.find(function (nodeA) { return isNodeMatch(nodeA, nodeB); }); });
        return containsInTheEnd(relevantChunksA, relevantChunksB);
    });
}
exports.matchSelectorTarget = matchSelectorTarget;
function fixChunkOrdering(selectorNode, prefixType) {
    var startChunkIndex = 0;
    var moved = false;
    traverseNode(selectorNode, function (node, index, nodes) {
        if (node.type === 'operator' || node.type === 'spacing') {
            startChunkIndex = index + 1;
            moved = false;
        }
        else if (isNodeMatch(node, prefixType)) {
            if (index > 0 && !moved) {
                moved = true;
                nodes.splice(index, 1);
                nodes.splice(startChunkIndex, 0, node);
            }
            // return false;
        }
        return undefined;
    });
}
exports.fixChunkOrdering = fixChunkOrdering;
//# sourceMappingURL=selector-utils.js.map