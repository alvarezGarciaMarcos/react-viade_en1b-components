"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var parser_1 = require("../src/parser");
var stylable_utils_1 = require("../src/stylable-utils");
describe('scopeSelector', function () {
    var tests = [
        {
            root: '.a',
            child: '.x',
            selector: '.a .x'
        },
        {
            root: '.a',
            child: '.x:hover',
            selector: '.a .x:hover'
        },
        {
            root: '.a',
            child: '&',
            selector: '.a'
        },
        {
            root: '.a:hover',
            child: '&',
            selector: '.a:hover'
        },
        {
            root: '.a.x',
            child: '&',
            selector: '.a.x'
        },
        {
            root: '.a.x .b:hover',
            child: '&',
            selector: '.a.x .b:hover'
        },
        {
            root: '.a',
            child: '&.x',
            selector: '.a.x'
        },
        {
            root: '.a',
            child: '&.x .y',
            selector: '.a.x .y'
        },
        {
            root: '.a .b',
            child: '&.x .y',
            selector: '.a .b.x .y'
        },
        {
            root: '.a',
            child: '& &',
            selector: '.a .a'
        },
        {
            root: '.a, .b',
            child: '& & &',
            selector: '.a .a .a, .b .b .b'
        },
        {
            root: '.a:hover, .b:focus',
            child: '& & &',
            selector: '.a:hover .a:hover .a:hover, .b:focus .b:focus .b:focus'
        }
    ];
    tests.forEach(function (test) {
        var _it = test.only ? it.only : it;
        _it("apply \"" + test.root + "\" on \"" + test.child + "\" should output \"" + test.selector + "\"", function () {
            var res = stylable_utils_1.scopeSelector(test.root, test.child);
            chai_1.expect(res.selector).to.equal(test.selector);
        });
    });
});
describe('createSubsetAst', function () {
    function testMatcher(expected, actualNodes) {
        expected.forEach(function (expectedMatch, i) {
            var nodes = expectedMatch.nodes, match = __rest(expectedMatch, ["nodes"]);
            var actual = actualNodes[i];
            chai_1.expect(actual).to.contain(match);
            if (nodes) {
                testMatcher(nodes, actual.nodes);
            }
        });
        chai_1.expect(actualNodes.length).to.equal(expected.length);
    }
    it('should extract all selectors that has given prefix in the first chunk', function () {
        var res = stylable_utils_1.createSubsetAst(parser_1.safeParse("\n            .i .x{}\n            .i::x{}\n            .i[data]{}\n            .i:hover{}\n            .x,.i{}\n            .i,.x{}\n            .i.x{}\n            .x.i{}\n\n            /*more complex*/\n            .x.y::i.z:hover.i{}\n            .x,.i:hover .y{}\n            .i .y,.x{}\n            .i:not(.x){}\n            .i .x:hover.i{}\n            .x.i.y{}\n\n            .i.i{}\n\n            /*extracted as decl on root*/\n            .i{color: red}\n\n            /*not extracted*/\n            .x .i{}\n            :not(.i) .i{}\n        "), '.i');
        var expected = [
            { selector: '& .x' },
            { selector: '&::x' },
            { selector: '&[data]' },
            { selector: '&:hover' },
            { selector: '&' },
            { selector: '&' },
            { selector: '&.x' },
            { selector: '&.x' },
            { selector: '&.x.y::i.z:hover' },
            { selector: '&:hover .y' },
            { selector: '& .y' },
            { selector: '&:not(.x)' },
            { selector: '& &.x:hover' },
            { selector: '&.x.y' },
            { selector: '&&' },
            { selector: '&' }
        ];
        testMatcher(expected, res.nodes);
    });
    it('should parts under @media', function () {
        var res = stylable_utils_1.createSubsetAst(parser_1.safeParse("\n            .i {color: red}\n            .i:hover {}\n            @media (max-width: 300px) {\n                .i {}\n                .i:hover {}\n            }\n        "), '.i');
        var expected = [
            { selector: '&' },
            { selector: '&:hover' },
            {
                type: 'atrule',
                params: '(max-width: 300px)',
                nodes: [
                    { selector: '&' },
                    { selector: '&:hover' }
                ]
            }
        ];
        testMatcher(expected, res.nodes);
    });
    it('should not append empty media', function () {
        var res = stylable_utils_1.createSubsetAst(parser_1.safeParse("\n            .i {}\n            @media (max-width: 300px) {\n                .x {}\n            }\n        "), '.i');
        var expected = [
            { selector: '&' }
        ];
        testMatcher(expected, res.nodes);
    });
});
//# sourceMappingURL=stylable-ast-mixin.spec.js.map