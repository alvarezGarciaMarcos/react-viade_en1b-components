"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var functions_1 = require("./functions");
var native_reserved_lists_1 = require("./native-reserved-lists");
var state_validators_1 = require("./state-validators");
var stylable_value_parsers_1 = require("./stylable-value-parsers");
var stylable_value_parsers_2 = require("./stylable-value-parsers");
var valueParser = require('postcss-value-parser');
/* tslint:disable:max-line-length */
var errors = {
    UNKNOWN_STATE_USAGE: function (name) { return "unknown pseudo-state \"" + name + "\""; },
    UNKNOWN_STATE_TYPE: function (name, type) { return "pseudo-state \"" + name + "\" defined with unknown type: \"" + type + "\""; },
    TOO_MANY_STATE_TYPES: function (name, types) { return "pseudo-state \"" + name + "(" + types.join(', ') + ")\" definition must be of a single type"; },
    NO_STATE_TYPE_GIVEN: function (name) { return "pseudo-state \"" + name + "\" expected a definition of a single type, but received none"; },
    TOO_MANY_ARGS_IN_VALIDATOR: function (name, validator, args) { return "pseudo-state \"" + name + "\" expected \"" + validator + "\" validator to receive a single argument, but it received \"" + args.join(', ') + "\""; }
};
/* tslint:enable:max-line-length */
// PROCESS
function processPseudoStates(value, decl, diagnostics) {
    var mappedStates = {};
    var ast = valueParser(value);
    var statesSplitByComma = stylable_value_parsers_1.groupValues(ast.nodes);
    statesSplitByComma.forEach(function (workingState) {
        var stateDefinition = workingState[0], stateDefault = workingState.slice(1);
        if (stateDefinition.type === 'function') {
            resolveStateType(stateDefinition, mappedStates, stateDefault, diagnostics, decl);
        }
        else if (stateDefinition.type === 'word') {
            resolveBooleanState(mappedStates, stateDefinition);
        }
        else {
            // TODO: Invalid state, edge case needs warning
        }
    });
    return mappedStates;
}
exports.processPseudoStates = processPseudoStates;
function resolveStateType(stateDefinition, mappedStates, stateDefault, diagnostics, decl) {
    if (stateDefinition.type === 'function' && stateDefinition.nodes.length === 0) {
        resolveBooleanState(mappedStates, stateDefinition);
        diagnostics.warn(decl, errors.NO_STATE_TYPE_GIVEN(stateDefinition.value), { word: decl.value });
        return;
    }
    if (stateDefinition.nodes.length > 1) {
        diagnostics.warn(decl, errors.TOO_MANY_STATE_TYPES(stateDefinition.value, stylable_value_parsers_1.listOptions(stateDefinition)), { word: decl.value });
    }
    var paramType = stateDefinition.nodes[0];
    var stateType = {
        type: stateDefinition.nodes[0].value,
        arguments: [],
        defaultValue: valueParser.stringify(stateDefault).trim()
    };
    if (isCustomMapping(stateDefinition)) {
        mappedStates[stateDefinition.value] = stateType.type.trim().replace(/\\["']/g, '"');
    }
    else if (typeof stateType === 'object' && stateType.type === 'boolean') {
        resolveBooleanState(mappedStates, stateDefinition);
        return;
    }
    else if (paramType.type === 'function' && stateType.type in state_validators_1.systemValidators) {
        if (paramType.nodes.length > 0) {
            resolveArguments(paramType, stateType, stateDefinition.value, diagnostics, decl);
        }
        mappedStates[stateDefinition.value] = stateType;
    }
    else if (stateType.type in state_validators_1.systemValidators) {
        mappedStates[stateDefinition.value] = stateType;
    }
    else {
        diagnostics.warn(decl, errors.UNKNOWN_STATE_TYPE(stateDefinition.value, paramType.value), { word: paramType.value });
    }
}
function resolveArguments(paramType, stateType, name, diagnostics, decl) {
    var seperetedByComma = stylable_value_parsers_1.groupValues(paramType.nodes);
    seperetedByComma.forEach(function (group) {
        var validator = group[0];
        if (validator.type === 'function') {
            var args = stylable_value_parsers_1.listOptions(validator);
            if (args.length > 1) {
                diagnostics.warn(decl, errors.TOO_MANY_ARGS_IN_VALIDATOR(name, validator.value, args), { word: decl.value });
            }
            else {
                stateType.arguments.push({
                    name: validator.value,
                    args: args
                });
            }
        }
        else if (validator.type === 'string' || validator.type === 'word') {
            stateType.arguments.push(validator.value);
        }
    });
}
function isCustomMapping(stateDefinition) {
    return stateDefinition.nodes.length === 1 && stateDefinition.nodes[0].type === 'string';
}
function resolveBooleanState(mappedStates, stateDefinition) {
    var currentState = mappedStates[stateDefinition.type];
    if (!currentState) {
        mappedStates[stateDefinition.value] = null; // add boolean state
    }
    else {
        // TODO: warn with such name already exists
    }
}
// TRANSFORM
function validateStateDefinition(decl, meta, resolver, diagnostics) {
    if (decl.parent && decl.parent.type !== 'root') {
        var container = decl.parent;
        if (container.type !== 'atrule') {
            var sRule = container;
            if (sRule.selectorAst.nodes && sRule.selectorAst.nodes.length === 1) {
                var singleSelectorAst = sRule.selectorAst.nodes[0];
                var selectorChunk = singleSelectorAst.nodes;
                if (selectorChunk.length === 1 && selectorChunk[0].type === 'class') {
                    var className = selectorChunk[0].name;
                    var classMeta = meta.classes[className];
                    if (classMeta && classMeta._kind === 'class') {
                        for (var stateName in classMeta[stylable_value_parsers_2.valueMapping.states]) {
                            var state = classMeta[stylable_value_parsers_2.valueMapping.states][stateName];
                            if (state && typeof state === 'object') {
                                var res = validateStateArgument(state, meta, state.defaultValue || '', resolver, diagnostics, sRule, true, !!state.defaultValue);
                                if (res.errors) {
                                    // tslint:disable-next-line:max-line-length
                                    res.errors.unshift("pseudo-state \"" + stateName + "\" default value \"" + state.defaultValue + "\" failed validation:");
                                    diagnostics.warn(decl, res.errors.join('\n'), { word: decl.value });
                                }
                            }
                        }
                    }
                    else {
                        // TODO: error state on non-class
                    }
                }
            }
        }
    }
}
exports.validateStateDefinition = validateStateDefinition;
function validateStateArgument(stateAst, meta, value, resolver, diagnostics, rule, validateDefinition, validateValue) {
    if (validateValue === void 0) { validateValue = true; }
    var resolvedValidations = {
        res: resolveParam(meta, resolver, diagnostics, rule, value || stateAst.defaultValue),
        errors: null
    };
    var paramType = stateAst.type, paramValidators = stateAst.arguments;
    var validator = state_validators_1.systemValidators[paramType];
    try {
        if (resolvedValidations.res || validateDefinition) {
            var errors_1 = validator.validate(resolvedValidations.res, stateAst.arguments, resolveParam.bind(null, meta, resolver, diagnostics, rule), !!validateDefinition, validateValue).errors;
            resolvedValidations.errors = errors_1;
        }
    }
    catch (error) {
        // TODO: warn about validation throwing exception
    }
    return resolvedValidations;
}
exports.validateStateArgument = validateStateArgument;
function transformPseudoStateSelector(meta, node, name, symbol, origin, originSymbol, resolver, diagnostics, rule) {
    var current = meta;
    var currentSymbol = symbol;
    if (symbol !== originSymbol) {
        var states = originSymbol[stylable_value_parsers_2.valueMapping.states];
        if (states && states.hasOwnProperty(name)) {
            setStateToNode(states, meta, name, node, origin.namespace, resolver, diagnostics, rule);
            return meta;
        }
    }
    var found = false;
    while (current && currentSymbol) {
        if (currentSymbol._kind === 'class') {
            var states = currentSymbol[stylable_value_parsers_2.valueMapping.states];
            var extend = currentSymbol[stylable_value_parsers_2.valueMapping.extends];
            if (states && states.hasOwnProperty(name)) {
                found = true;
                setStateToNode(states, meta, name, node, current.namespace, resolver, diagnostics, rule);
                break;
            }
            else if (extend) {
                var next = resolver.resolve(extend);
                if (next && next.meta) {
                    currentSymbol = next.symbol;
                    current = next.meta;
                }
                else {
                    break;
                }
            }
            else {
                break;
            }
        }
        else {
            break;
        }
    }
    if (!found && rule) {
        if (native_reserved_lists_1.nativePseudoClasses.indexOf(name) === -1) {
            diagnostics.warn(rule, errors.UNKNOWN_STATE_USAGE(name), { word: name });
        }
    }
    return meta;
}
exports.transformPseudoStateSelector = transformPseudoStateSelector;
function setStateToNode(states, meta, name, node, namespace, resolver, diagnostics, rule) {
    var stateDef = states[name];
    if (stateDef === null) {
        node.type = 'attribute';
        node.content = autoStateAttrName(name, namespace);
    }
    else if (typeof stateDef === 'string') {
        node.type = 'invalid'; // simply concat global mapped selector - ToDo: maybe change to 'selector'
        node.value = stateDef;
    }
    else if (typeof stateDef === 'object') {
        resolveStateValue(meta, resolver, diagnostics, rule, node, stateDef, name, namespace);
    }
}
exports.setStateToNode = setStateToNode;
function resolveStateValue(meta, resolver, diagnostics, rule, node, stateDef, name, namespace) {
    var actualParam = resolveParam(meta, resolver, diagnostics, rule, node.content || stateDef.defaultValue);
    var paramType = stateDef.type, paramValidators = stateDef.arguments;
    var validator = state_validators_1.systemValidators[stateDef.type];
    var stateParamOutput;
    try {
        stateParamOutput = validator.validate(actualParam, stateDef.arguments, resolveParam.bind(null, meta, resolver, diagnostics, rule), false, true);
    }
    catch (e) {
        // TODO: warn about validation throwing exception
    }
    if (stateParamOutput !== undefined) {
        if (stateParamOutput.res !== actualParam) {
            actualParam = stateParamOutput.res;
        }
        if (rule && stateParamOutput.errors) {
            stateParamOutput.errors.unshift("pseudo-state \"" + name + "\" with parameter \"" + actualParam + "\" failed validation:");
            diagnostics.warn(rule, stateParamOutput.errors.join('\n'), { word: actualParam });
        }
    }
    node.type = 'attribute';
    var selectorSuffix = stateDef.type === 'tag' ? '~' : undefined; // TODO: should be generic
    node.content = autoStateAttrName(name, namespace, selectorSuffix) + "=\"" + actualParam + "\"";
}
function resolveParam(meta, resolver, diagnostics, rule, nodeContent) {
    var defaultStringValue = '';
    var param = nodeContent || defaultStringValue;
    return rule ? functions_1.evalDeclarationValue(resolver, param, meta, rule, undefined, undefined, diagnostics) : param;
}
function autoStateAttrName(stateName, namespace, suffix) {
    if (suffix === void 0) { suffix = ''; }
    return "data-" + namespace.toLowerCase() + "-" + stateName.toLowerCase() + suffix;
}
exports.autoStateAttrName = autoStateAttrName;
//# sourceMappingURL=pseudo-states.js.map