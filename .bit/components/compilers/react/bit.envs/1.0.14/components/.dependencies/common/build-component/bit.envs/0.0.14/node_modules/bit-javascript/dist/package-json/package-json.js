"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _parents() {
  const data = _interopRequireDefault(require("parents"));

  _parents = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

/** @flow */
function composePath(componentRootFolder) {
  return _path().default.join(componentRootFolder, _constants().PACKAGE_JSON);
}

function convertComponentsIdToValidPackageName(registryPrefix, id) {
  return `${registryPrefix}/${id.replace(/\//g, '.')}`;
}

class PackageJson {
  // path where to write the package.json
  constructor(componentRootFolder, {
    name,
    version,
    homepage,
    main,
    dependencies,
    devDependencies,
    peerDependencies,
    license,
    scripts,
    workspaces
  }) {
    (0, _defineProperty2().default)(this, "name", void 0);
    (0, _defineProperty2().default)(this, "version", void 0);
    (0, _defineProperty2().default)(this, "homepage", void 0);
    (0, _defineProperty2().default)(this, "main", void 0);
    (0, _defineProperty2().default)(this, "dependencies", void 0);
    (0, _defineProperty2().default)(this, "devDependencies", void 0);
    (0, _defineProperty2().default)(this, "peerDependencies", void 0);
    (0, _defineProperty2().default)(this, "componentRootFolder", void 0);
    (0, _defineProperty2().default)(this, "license", void 0);
    (0, _defineProperty2().default)(this, "scripts", void 0);
    (0, _defineProperty2().default)(this, "workspaces", void 0);
    this.name = name;
    this.version = version;
    this.homepage = homepage;
    this.main = main;
    this.dependencies = dependencies;
    this.devDependencies = devDependencies;
    this.peerDependencies = peerDependencies;
    this.componentRootFolder = componentRootFolder;
    this.license = license;
    this.scripts = scripts;
    this.workspaces = workspaces;
  }

  static loadSync(componentRootFolder) {
    const composedPath = composePath(componentRootFolder);
    if (!PackageJson.hasExisting(componentRootFolder)) return null;

    const componentJsonObject = _fsExtra().default.readJsonSync(composedPath);

    return new PackageJson(componentRootFolder, componentJsonObject);
  }

  static hasExisting(componentRootFolder) {
    const packageJsonPath = composePath(componentRootFolder);
    return _fsExtra().default.pathExistsSync(packageJsonPath);
  }
  /**
   * Taken from this package (with some minor changes):
   * https://www.npmjs.com/package/find-package
   * https://github.com/jalba/find-package
   */


  static findPath(dir) {
    const parentsArr = (0, _parents().default)(dir);
    let i; // eslint-disable-next-line

    for (i = 0; i < parentsArr.length; i++) {
      const config = `${parentsArr[i]}/package.json`;

      try {
        if (_fsExtra().default.lstatSync(config).isFile()) {
          return config;
        }
      } catch (e) {} // eslint-disable-line

    }

    return null;
  }
  /**
   * Taken from this package (with some minor changes):
   * https://www.npmjs.com/package/find-package
   * https://github.com/jalba/find-package
   *
   */


  static findPackage(dir, addPaths) {
    const pathToConfig = this.findPath(dir);
    let configJSON = null; // eslint-disable-next-line import/no-dynamic-require, global-require

    if (pathToConfig !== null) configJSON = require(_path().default.resolve(pathToConfig));

    if (configJSON && addPaths) {
      configJSON.paths = {
        // @ts-ignore
        relative: _path().default.relative(dir, pathToConfig),
        absolute: pathToConfig
      };
    } else if (configJSON !== null) {
      delete configJSON.paths;
    }

    return configJSON;
  }
  /*
   * load package.json from path
   */


  static getPackageJson(pathStr) {
    return (0, _bluebird().coroutine)(function* () {
      const getRawObject = () => _fsExtra().default.readJson(composePath(pathStr));

      const exist = PackageJson.hasExisting(pathStr);
      if (exist) return getRawObject();
      return null;
    })();
  }
  /*
   * save package.json in path
   */


  static saveRawObject(pathStr, obj) {
    return _fsExtra().default.outputJSON(composePath(pathStr), obj, {
      spaces: 2
    });
  }
  /*
   * For an existing package.json file of the root project, we don't want to do any change, other than what needed.
   * That's why this method doesn't use the 'load' and 'write' methods of this class. Otherwise, it'd write only the
   * PackageJsonPropsNames attributes.
   * Also, in case there is no package.json file in this project, it generates a new one with only the 'dependencies'
   * adds workspaces with private flag if dosent exist.
   */


  static addWorkspacesToPackageJson(rootDir, componentsDefaultDirectory, dependenciesDirectory, customImportPath) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      const pkg = (yield PackageJson.getPackageJson(rootDir)) || {};
      const workSpaces = PackageJson.extractWorkspacesPackages(pkg) || [];
      workSpaces.push(dependenciesDirectory);
      workSpaces.push(componentsDefaultDirectory);
      if (customImportPath) workSpaces.push(customImportPath);
      if (!pkg.workspaces) pkg.workspaces = [];

      _this.updateWorkspacesPackages(pkg, _ramda().default.uniq(workSpaces));

      pkg.private = !!pkg.workspaces;
      yield PackageJson.saveRawObject(rootDir, pkg);
    })();
  }
  /*
   * remove workspaces dir from workspace in package.json with changing other fields in package.json
   */


  static removeComponentsFromWorkspaces(rootDir, pathsTOoRemove) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      const pkg = (yield PackageJson.getPackageJson(rootDir)) || {};

      const workspaces = _this2.extractWorkspacesPackages(pkg);

      if (!workspaces) return;
      const updatedWorkspaces = workspaces.filter(folder => !pathsTOoRemove.includes(folder));

      _this2.updateWorkspacesPackages(pkg, updatedWorkspaces);

      yield PackageJson.saveRawObject(rootDir, pkg);
    })();
  }
  /*
   * remove components from package.json dependencies
   */


  static removeComponentsFromDependencies(rootDir, registryPrefix, componentIds) {
    return (0, _bluebird().coroutine)(function* () {
      const pkg = yield PackageJson.getPackageJson(rootDir);

      if (pkg && pkg.dependencies) {
        componentIds.forEach(id => {
          delete pkg.dependencies[convertComponentsIdToValidPackageName(registryPrefix, id)];
        });
        yield PackageJson.saveRawObject(rootDir, pkg);
      }
    })();
  }

  static extractWorkspacesPackages(packageJson) {
    if (!packageJson.workspaces) return null;
    this.throwForInvalidWorkspacesConfig(packageJson);

    if (Array.isArray(packageJson.workspaces)) {
      return packageJson.workspaces;
    }

    if (Array.isArray(packageJson.workspaces.packages)) {
      return packageJson.workspaces.packages;
    }

    return null;
  }

  static updateWorkspacesPackages(packageJson, workspacesPackages) {
    if (!packageJson.workspaces) return;
    this.throwForInvalidWorkspacesConfig(packageJson);

    if (Array.isArray(packageJson.workspaces)) {
      packageJson.workspaces = workspacesPackages;
    }

    if (Array.isArray(packageJson.workspaces.packages)) {
      packageJson.workspaces.packages = workspacesPackages;
    }
  }
  /**
   * according to Yarn Git repo, the workspaces type configured as the following
   * `workspaces?: Array<string> | WorkspacesConfig`
   * and `WorkspacesConfig` is:
   * `export type WorkspacesConfig = { packages?: Array<string>, nohoist?: Array<string> };`
   * see https://github.com/yarnpkg/yarn/blob/master/src/types.js
   */


  static throwForInvalidWorkspacesConfig(packageJson) {
    if (!packageJson.workspaces) return;

    if (typeof packageJson.workspaces !== 'object' || !Array.isArray(packageJson.workspaces) && !Array.isArray(packageJson.workspaces.packages)) {
      throw new Error('workspaces property does not have the correct format, please refer to Yarn documentation');
    }
  }

}

exports.default = PackageJson;