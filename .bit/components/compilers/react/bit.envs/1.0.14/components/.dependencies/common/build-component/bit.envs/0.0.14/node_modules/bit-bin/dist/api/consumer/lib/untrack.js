"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("../../../utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

var _default =
/*#__PURE__*/
function () {
  var _untrack = (0, _bluebird().coroutine)(function* (componentIds, all) {
    const untrackedComponents = [];
    const missing = [];
    const unRemovableComponents = [];
    const consumer = yield (0, _consumer().loadConsumer)();
    const componentsList = new (_componentsList().default)(consumer); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const newComponents = yield componentsList.listNewComponents(false);
    const idsHaveWildcard = (0, _hasWildcard().default)(componentIds);

    if (all || idsHaveWildcard) {
      const componentsToUntrack = (0, _hasWildcard().default)(componentIds) ? _componentsList().default.filterComponentsByWildcard(newComponents, componentIds) : newComponents;
      componentsToUntrack.forEach(componentId => consumer.bitMap.removeComponent(componentId));
      yield consumer.onDestroy();
      return {
        untrackedComponents: componentsToUntrack,
        unRemovableComponents,
        missingComponents: missing
      };
    }

    componentIds.forEach(componentId => {
      const bitId = consumer.getParsedIdIfExist(componentId);

      if (!bitId) {
        missing.push(componentId);
        return;
      }

      if (newComponents.has(bitId)) {
        untrackedComponents.push(bitId);
        consumer.bitMap.removeComponent(bitId);
      } else {
        unRemovableComponents.push(bitId);
      }
    });
    yield consumer.onDestroy();
    return {
      untrackedComponents,
      unRemovableComponents,
      missingComponents: missing
    };
  });

  function untrack(_x, _x2) {
    return _untrack.apply(this, arguments);
  }

  return untrack;
}();

exports.default = _default;