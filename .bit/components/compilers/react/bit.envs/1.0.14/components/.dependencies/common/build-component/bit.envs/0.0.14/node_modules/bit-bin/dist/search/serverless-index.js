"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

// import searchIndex from 'search-index';
const indexName = 'search_index';
const logLevel = 'error';
let index;

function getIndexPath(scopePath) {
  return path().join(scopePath, indexName);
}

function deleteDb(scopePath) {
  const indexPath = getIndexPath(scopePath);

  _logger().default.debug(`deleting index-search at ${indexPath}`);

  if (!scopePath || !indexPath) return;

  _fsExtra().default.removeSync(indexPath);
}

function initializeIndex(_x) {
  return _initializeIndex.apply(this, arguments);
}

function _initializeIndex() {
  _initializeIndex = (0, _bluebird().coroutine)(function* (scopePath) {
    if (!index) {
      // static var to make sure the index is not instantiated twice
      const indexOptions = {
        indexPath: getIndexPath(scopePath),
        logLevel,
        stopwords: []
      };
      index = new Promise((resolve, reject) => {// searchIndex(indexOptions, (err, si) => {
        //   if (err) reject(err);
        //   resolve(si);
        // });
      });
    }

    return index;
  });
  return _initializeIndex.apply(this, arguments);
}

module.exports = {
  deleteDb,
  getIndexPath,
  initializeIndex
};