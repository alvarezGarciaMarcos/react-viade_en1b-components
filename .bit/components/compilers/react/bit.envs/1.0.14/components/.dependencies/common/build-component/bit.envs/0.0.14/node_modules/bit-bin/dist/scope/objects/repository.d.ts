/// <reference types="node" />
import BitObject from './object';
import BitRawObject from './raw-object';
import Ref from './ref';
import ComponentsIndex from './components-index';
import { ScopeJson } from '../scope-json';
export default class Repository {
    objects: {
        [key: string]: BitObject;
    };
    objectsToRemove: Ref[];
    scopeJson: ScopeJson;
    scopePath: string;
    types: {
        [key: string]: Function;
    };
    componentsIndex: ComponentsIndex;
    _cache: {
        [key: string]: BitObject;
    };
    constructor(scopePath: string, scopeJson: ScopeJson, types?: {
        [key: string]: Function;
    });
    static load({ scopePath, scopeJson }: {
        scopePath: string;
        scopeJson: ScopeJson;
    }): Promise<Repository>;
    static create({ scopePath, scopeJson }: {
        scopePath: string;
        scopeJson: ScopeJson;
    }): Repository;
    static reset(scopePath: string): Promise<void>;
    static getPathByScopePath(scopePath: string): string;
    ensureDir(): Promise<boolean>;
    getPath(): string;
    getBackupPath(dirName?: string): string;
    getLicense(): Promise<string>;
    getScopeMetaObject(): Promise<Buffer>;
    objectPath(ref: Ref): string;
    load(ref: Ref, throws?: boolean): Promise<BitObject>;
    list(): Promise<BitObject[]>;
    listRefs(): Promise<Array<Ref>>;
    listRawObjects(): Promise<any>;
    listComponentsIncludeSymlinks(): Promise<BitObject[]>;
    listComponents(): Promise<BitObject[]>;
    _getBitObjectsByHashes(hashes: string[]): Promise<BitObject[]>;
    loadOptionallyCreateComponentsIndex(): Promise<ComponentsIndex>;
    loadRaw(ref: Ref): Promise<Buffer>;
    loadRawObject(ref: Ref): Promise<BitRawObject>;
    loadSync(ref: Ref, throws?: boolean): BitObject;
    setCache(object: BitObject): this;
    getCache(ref: Ref): BitObject;
    removeFromCache(ref: Ref): void;
    backup(dirName?: string): void;
    add(object: BitObject | null | undefined): Repository;
    addMany(objects: BitObject[]): Repository;
    removeObject(ref: Ref): void;
    removeManyObjects(refs: Ref[]): void;
    findMany(refs: Ref[]): Promise<BitObject[]>;
    persist(validate?: boolean): Promise<void>;
    _validateObjects(validate: boolean): void;
    _deleteMany(): Promise<void>;
    _writeMany(): Promise<void>;
    _deleteOne(ref: Ref): Promise<boolean>;
    _writeOne(object: BitObject): Promise<boolean>;
}
