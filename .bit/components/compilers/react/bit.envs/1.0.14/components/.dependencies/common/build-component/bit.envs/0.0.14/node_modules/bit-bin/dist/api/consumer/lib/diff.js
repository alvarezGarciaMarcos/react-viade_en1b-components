"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _componentsDiff() {
  const data = _interopRequireDefault(require("../../../consumer/component-ops/components-diff"));

  _componentsDiff = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("../../../utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

var _default =
/*#__PURE__*/
function () {
  var _diff = (0, _bluebird().coroutine)(function* (values, verbose) {
    const consumer = yield (0, _consumer().loadConsumer)();
    const {
      bitIds,
      version,
      toVersion
    } = yield parseValues(consumer, values);

    if (!bitIds || !bitIds.length) {
      throw new (_generalError().default)('there are no modified components to diff');
    }

    const diffResults = yield (0, _componentsDiff().default)(consumer, bitIds, version, toVersion, verbose);
    yield consumer.onDestroy();
    return diffResults;
  });

  function diff(_x, _x2) {
    return _diff.apply(this, arguments);
  }

  return diff;
}();

exports.default = _default;

function parseValues(_x3, _x4) {
  return _parseValues.apply(this, arguments);
}

function _parseValues() {
  _parseValues = (0, _bluebird().coroutine)(function* (consumer, values) {
    // option #1: bit diff
    // no arguments
    if (!values.length) {
      const componentsList = new (_componentsList().default)(consumer);
      const bitIds = yield componentsList.listModifiedComponents(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      return {
        bitIds
      };
    }

    const firstValue = values[0];
    const lastValue = values[values.length - 1];
    const oneBeforeLastValue = values[values.length - 2];

    const isLastItemVersion = _bitId().BitId.isValidVersion(lastValue);

    const isOneBeforeLastItemVersion = _bitId().BitId.isValidVersion(oneBeforeLastValue); // option #2: bit diff [ids...]
    // all arguments are ids


    if (!isLastItemVersion) {
      return {
        bitIds: getBitIdsForDiff(consumer, values)
      };
    } // option #3: bit diff [id] [version]
    // last argument is a version, first argument is id


    if (!isOneBeforeLastItemVersion) {
      if (values.length !== 2) {
        throw new (_generalError().default)(`bit diff [id] [version] syntax was used, however, ${values.length} arguments were given instead of 2`);
      }

      return {
        bitIds: getBitIdsForDiff(consumer, [firstValue]),
        version: lastValue
      };
    } // option #4: bit diff [id] [version] [to_version]
    // last argument and one before the last are versions, first argument is id


    if (values.length !== 3) {
      throw new (_generalError().default)(`bit diff [id] [version] [to_version] syntax was used, however, ${values.length} arguments were given instead of 3`);
    }

    return {
      bitIds: getBitIdsForDiff(consumer, [firstValue]),
      version: oneBeforeLastValue,
      toVersion: lastValue
    };
  });
  return _parseValues.apply(this, arguments);
}

function getBitIdsForDiff(consumer, ids) {
  if ((0, _hasWildcard().default)(ids)) {
    const componentsList = new (_componentsList().default)(consumer);
    return componentsList.listComponentsByIdsWithWildcard(ids);
  }

  return ids.map(id => consumer.getParsedId(id));
}