"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tagAction = tagAction;
exports.tagAllAction = tagAllAction;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _hooks() {
  const data = _interopRequireDefault(require("../../../hooks"));

  _hooks = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _invalidVersion() {
  const data = _interopRequireDefault(require("./exceptions/invalid-version"));

  _invalidVersion = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../../../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

const HooksManagerInstance = _hooks().default.getInstance();

function tagAction(_x) {
  return _tagAction.apply(this, arguments);
}

function _tagAction() {
  _tagAction = (0, _bluebird().coroutine)(function* (args) {
    const {
      id,
      message,
      exactVersion,
      releaseType,
      force,
      verbose,
      ignoreUnresolvedDependencies,
      ignoreNewestVersion,
      skipTests,
      skipAutoTag
    } = args;

    const validExactVersion = _validateVersion(exactVersion);

    HooksManagerInstance.triggerHook(_constants().PRE_TAG_HOOK, args);
    const consumer = yield (0, _consumer().loadConsumer)();
    const componentsList = new (_componentsList().default)(consumer);
    const newComponents = yield componentsList.listNewComponents();
    const bitId = consumer.getParsedId(id);

    if (!force) {
      const componentStatus = yield consumer.getComponentStatusById(bitId); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      if (componentStatus.modified === false) return null;
    }

    const tagResults = yield consumer.tag(new (_bitId().BitIds)(bitId), message, validExactVersion, releaseType, force, verbose, ignoreUnresolvedDependencies, ignoreNewestVersion, skipTests, skipAutoTag); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    tagResults.newComponents = newComponents;
    HooksManagerInstance.triggerHook(_constants().POST_TAG_HOOK, tagResults);
    yield consumer.onDestroy(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return tagResults;
  });
  return _tagAction.apply(this, arguments);
}

function getCommitPendingComponents(_x2, _x3, _x4, _x5) {
  return _getCommitPendingComponents.apply(this, arguments);
}

function _getCommitPendingComponents() {
  _getCommitPendingComponents = (0, _bluebird().coroutine)(function* (consumer, isAllScope, exactVersion, includeImported) {
    const componentsList = new (_componentsList().default)(consumer);

    if (isAllScope) {
      return componentsList.listCommitPendingOfAllScope(exactVersion, includeImported);
    }

    const tagPendingComponents = yield componentsList.listCommitPendingComponents();
    const warnings = [];
    return {
      tagPendingComponents,
      warnings
    };
  });
  return _getCommitPendingComponents.apply(this, arguments);
}

function tagAllAction(_x6) {
  return _tagAllAction.apply(this, arguments);
}

function _tagAllAction() {
  _tagAllAction = (0, _bluebird().coroutine)(function* (args) {
    const {
      message,
      exactVersion,
      releaseType,
      force,
      verbose,
      ignoreUnresolvedDependencies,
      ignoreNewestVersion,
      skipTests,
      scope,
      includeImported,
      idWithWildcard,
      skipAutoTag
    } = args;

    const validExactVersion = _validateVersion(exactVersion);

    HooksManagerInstance.triggerHook(_constants().PRE_TAG_ALL_HOOK, args);
    const consumer = yield (0, _consumer().loadConsumer)();
    const componentsList = new (_componentsList().default)(consumer);
    const newComponents = yield componentsList.listNewComponents();
    const {
      tagPendingComponents,
      warnings
    } = yield getCommitPendingComponents(consumer, Boolean(scope), // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    exactVersion, includeImported); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    if (_ramda().default.isEmpty(tagPendingComponents)) return null;
    const componentsToTag = idWithWildcard ? _componentsList().default.filterComponentsByWildcard(tagPendingComponents, idWithWildcard) : tagPendingComponents;
    const tagResults = yield consumer.tag( // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    componentsToTag, message, validExactVersion, releaseType, force, verbose, ignoreUnresolvedDependencies, ignoreNewestVersion, skipTests, skipAutoTag); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    tagResults.warnings = warnings; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    tagResults.newComponents = newComponents;
    HooksManagerInstance.triggerHook(_constants().POST_TAG_ALL_HOOK, tagResults);

    _analytics().Analytics.setExtraData('num_components', // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    _ramda().default.concat(tagResults.taggedComponents, tagResults.autoTaggedResults, tagResults.newComponents).length);

    yield consumer.onDestroy(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return tagResults;
  });
  return _tagAllAction.apply(this, arguments);
}

function _validateVersion(version) {
  if (version) {
    const validVersion = _semver().default.valid(version);

    if (!validVersion) throw new (_invalidVersion().default)(version);
    if (_semver().default.prerelease(version)) throw new (_generalError().default)(`error: a prerelease version "${version}" is not supported`);
    return validVersion;
  }

  return null;
}