"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _invalidCompilerInterface() {
  const data = _interopRequireDefault(require("../component/exceptions/invalid-compiler-interface"));

  _invalidCompilerInterface = function () {
    return data;
  };

  return data;
}

function _environment() {
  const data = _interopRequireDefault(require("../../environment"));

  _environment = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _externalBuildErrors() {
  const data = _interopRequireDefault(require("../component/exceptions/external-build-errors"));

  _externalBuildErrors = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _sources() {
  const data = require("../component/sources");

  _sources = function () {
    return data;
  };

  return data;
}

function _ejectConf() {
  const data = require("./eject-conf");

  _ejectConf = function () {
    return data;
  };

  return data;
}

function _isolator() {
  const data = _interopRequireDefault(require("../../environment/isolator"));

  _isolator = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("../component/package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

function _extensionIsolateResult() {
  const data = _interopRequireDefault(require("../../extensions/extension-isolate-result"));

  _extensionIsolateResult = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

var _default =
/*#__PURE__*/
function () {
  var _buildComponent = (0, _bluebird().coroutine)(function* ({
    component,
    scope,
    save,
    // this is true only when originated from `runAndUpdateCI()`
    consumer,
    noCache,
    directory,
    verbose,
    dontPrintEnvMsg,
    keep
  }) {
    _logger().default.debug(`consumer-component.build ${component.id.toString()}`); // @TODO - write SourceMap Type


    if (!component.compiler) {
      if (!consumer || consumer.shouldDistsBeInsideTheComponent()) {
        _logger().default.debug('compiler was not found, nothing to build');

        return undefined;
      }

      _logger().default.debugAndAddBreadCrumb('build-component.buildComponent', 'compiler was not found, however, because the dists are set to be outside the components directory, save the source file as dists');

      component.copyFilesIntoDists();
      return component.dists;
    }

    const bitMap = consumer ? consumer.bitMap : undefined;
    const consumerPath = consumer ? consumer.getPath() : '';
    const componentMap = bitMap && bitMap.getComponentIfExist(component.id);
    let componentDir = consumerPath;

    if (componentMap) {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      componentDir = consumerPath && componentMap.rootDir ? path().join(consumerPath, componentMap.rootDir) : undefined;
    }

    const needToRebuild = yield _isNeededToReBuild(consumer, component, noCache);

    if (!needToRebuild && !component.dists.isEmpty()) {
      _logger().default.debugAndAddBreadCrumb('build-component.buildComponent', 'skip the build process as the component was not modified, use the dists saved in the model');

      return component.dists;
    }

    _logger().default.debug('compiler found, start building');

    if (component.compiler && !component.compiler.loaded) {
      yield component.compiler.install(scope, {
        verbose: !!verbose,
        dontPrintEnvMsg
      }, {
        workspaceDir: consumerPath,
        componentDir,
        dependentId: component.id
      });
    }

    const compilerResults = yield _build({
      component,
      consumer,
      componentMap,
      scope,
      keep,
      directory,
      verbose: !!verbose
    });
    const {
      builtFiles,
      mainDist,
      packageJson,
      shouldBuildUponDependenciesChanges
    } = compilerResults;
    builtFiles.forEach(file => {
      if (file && (!file.contents || !(0, _utils().isString)(file.contents.toString()))) {
        throw new (_generalError().default)('builder interface has to return object with a code attribute that contains string');
      }
    }); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    component.setDists(builtFiles.map(file => new (_sources().Dist)(file)), mainDist);

    if (save) {
      yield scope.sources.updateDist({
        source: component
      });
    }

    if (packageJson && !_ramda().default.isEmpty(packageJson)) {
      yield _updateComponentPackageJson(component, packageJson);
      component.packageJsonChangedProps = Object.assign(component.packageJsonChangedProps || {}, packageJson);
    }

    if (shouldBuildUponDependenciesChanges) {
      component.addExtensionValue(component.compiler.name, 'shouldBuildUponDependenciesChanges', true);
    }

    return component.dists;
  });

  function buildComponent(_x) {
    return _buildComponent.apply(this, arguments);
  }

  return buildComponent;
}();

exports.default = _default;

function _updateComponentPackageJson(_x2, _x3) {
  return _updateComponentPackageJson2.apply(this, arguments);
}

function _updateComponentPackageJson2() {
  _updateComponentPackageJson2 = (0, _bluebird().coroutine)(function* (component, packageJsonPropsToAdd) {
    const componentPackageJsonFile = component.packageJsonFile;

    if (!componentPackageJsonFile) {
      _logger().default.debug(`ignore compiler packageJson result as the component ${component.id.toString()} does not have a package.json file`);

      return;
    }

    componentPackageJsonFile.mergePackageJsonObject(packageJsonPropsToAdd); // When running in capsule there is no workspace dir, so no need to update the package.json

    if (componentPackageJsonFile.workspaceDir) {
      yield componentPackageJsonFile.write();
    }
  });
  return _updateComponentPackageJson2.apply(this, arguments);
}

function _extractAndVerifyCompilerResults(compilerResults) {
  if (Array.isArray(compilerResults)) {
    return {
      builtFiles: compilerResults,
      mainDist: null,
      packageJson: null
    };
  }

  if (typeof compilerResults === 'object') {
    // @ts-ignore yes, it should not contain files, it's only a verification
    if (compilerResults.files && !compilerResults.dists) {
      // previously, the new compiler "action" method expected to get "files", suggest to replace with 'dists'.
      throw new (_generalError().default)('fatal: compiler returned "files" instead of "dists", please change it to "dists"');
    }

    if (!compilerResults.dists) {
      throw new (_generalError().default)('fatal: compiler that returns an object, must include "dists" property');
    }

    if (compilerResults.packageJson) {
      _verifyPackageJsonReturnedByCompiler(compilerResults.packageJson);
    }

    return {
      builtFiles: compilerResults.dists,
      mainDist: compilerResults.mainFile,
      packageJson: compilerResults.packageJson
    };
  }

  throw new (_generalError().default)(`fatal: compiler must return an array or object, instead, got ${typeof compilerResults}`);
}

function _verifyPackageJsonReturnedByCompiler(packageJson) {
  if (typeof packageJson !== 'object') {
    throw new (_generalError().default)(`fatal: compiler must return packageJson as an object, got ${typeof packageJson}`);
  }

  _packageJsonFile().default.propsNonUserChangeable().forEach(prop => {
    if (packageJson[prop]) {
      throw new (_generalError().default)(`fatal: compiler must not return packageJson with "${prop}" property`);
    }
  });
}

function _build(_x4) {
  return _build2.apply(this, arguments);
} // Ideally it's better to use the dists from the model.
// If there is no consumer, it comes from the scope or isolated environment, which the dists are already saved.
// If there is consumer, check whether the component was modified. If it wasn't, no need to re-build.


function _build2() {
  _build2 = (0, _bluebird().coroutine)(function* ({
    component,
    consumer,
    componentMap,
    scope,
    verbose,
    directory,
    keep
  }) {
    const compiler = component.compiler;

    if (!compiler) {
      throw new (_generalError().default)('compiler was not found, nothing to build');
    }

    if (!compiler.action && !compiler.oldAction) {
      throw new (_invalidCompilerInterface().default)(compiler.name);
    }

    const runBuildParams = {
      component,
      consumer,
      scope,
      componentMap,
      verbose
    };

    if (consumer) {
      return _runBuild(_objectSpread({}, runBuildParams, {
        componentRoot: consumer.getPath()
      }));
    }

    if (component.isolatedEnvironment) {
      return _runBuild(_objectSpread({}, runBuildParams, {
        componentRoot: component.writtenPath
      }));
    }

    const isolatedEnvironment = new (_environment().default)(scope, directory);

    try {
      yield isolatedEnvironment.create();
      const isolateOpts = {
        verbose,
        installNpmPackages: true,
        writePackageJson: true
      };
      const componentWithDependencies = yield isolatedEnvironment.isolateComponent(component.id, isolateOpts);
      const isolatedComponent = componentWithDependencies.component;
      const result = yield _runBuild(_objectSpread({}, runBuildParams, {
        componentRoot: isolatedComponent.writtenPath
      }));
      if (!keep) yield isolatedEnvironment.destroy();
      return result;
    } catch (err) {
      yield isolatedEnvironment.destroy();
      throw err;
    }
  });
  return _build2.apply(this, arguments);
}

function _isNeededToReBuild(_x5, _x6, _x7) {
  return _isNeededToReBuild2.apply(this, arguments);
}

function _isNeededToReBuild2() {
  _isNeededToReBuild2 = (0, _bluebird().coroutine)(function* (consumer, component, noCache) {
    if (noCache) return true;
    if (!consumer) return false;
    const componentStatus = yield consumer.getComponentStatusById(component.id);
    if (componentStatus.modified) return true;
    const shouldBuildUponDependenciesChanges = component.getExtensionValue( // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    component.compiler.name, 'shouldBuildUponDependenciesChanges');
    if (!shouldBuildUponDependenciesChanges) return false;
    const areDependenciesChangedP = component.dependencies.getAllIds().map(
    /*#__PURE__*/
    function () {
      var _ref = (0, _bluebird().coroutine)(function* (dependencyId) {
        const dependencyStatus = yield consumer.getComponentStatusById(dependencyId);
        return dependencyStatus.modified;
      });

      return function (_x9) {
        return _ref.apply(this, arguments);
      };
    }());
    const areDependenciesChanged = yield Promise.all(areDependenciesChangedP);
    return areDependenciesChanged.some(isDependencyChanged => isDependencyChanged);
  });
  return _isNeededToReBuild2.apply(this, arguments);
}

function _runBuild(_x8) {
  return _runBuild2.apply(this, arguments);
}

function _runBuild2() {
  _runBuild2 = (0, _bluebird().coroutine)(function* ({
    component,
    componentRoot,
    consumer,
    scope,
    componentMap,
    verbose
  }) {
    const compiler = component.compiler;

    if (!compiler) {
      throw new (_generalError().default)('compiler was not found, nothing to build');
    }

    let rootDistDir = componentRoot ? path().join(componentRoot, _constants().DEFAULT_DIST_DIRNAME) : undefined;
    const consumerPath = consumer ? consumer.getPath() : '';
    const files = component.files.map(file => file.clone());
    let tmpFolderFullPath;
    let componentDir = '';

    if (componentMap) {
      const rootDistDirRelative = component.dists.getDistDir(consumer, componentMap.getRootDir());
      if (consumer) rootDistDir = consumer.toAbsolutePath(rootDistDirRelative);

      if (consumerPath && componentMap.getComponentDir()) {
        componentDir = componentMap.getComponentDir() || '';
      }
    }

    let shouldBuildUponDependenciesChanges;

    const isolateFunc =
    /*#__PURE__*/
    function () {
      var _ref2 = (0, _bluebird().coroutine)(function* ({
        targetDir,
        shouldBuildDependencies
      }) {
        shouldBuildUponDependenciesChanges = shouldBuildDependencies;
        const isolator = yield _isolator().default.getInstance('fs', scope, consumer, targetDir);
        const componentWithDependencies = yield isolator.isolate(component.id, {
          shouldBuildDependencies,
          writeDists: false
        });
        return new (_extensionIsolateResult().default)(isolator, componentWithDependencies);
      });

      return function isolateFunc(_x10) {
        return _ref2.apply(this, arguments);
      };
    }();

    const context = {
      componentObject: component.toObject(),
      rootDistDir,
      componentDir,
      isolate: isolateFunc
    };

    const getBuildResults =
    /*#__PURE__*/
    function () {
      var _ref3 = (0, _bluebird().coroutine)(function* () {
        try {
          // Change the cwd to make sure we found the needed files
          if (componentRoot) {
            process.chdir(componentRoot);
          }

          if (compiler.action) {
            const isCompilerDetached = yield component.getDetachedCompiler(consumer);
            const shouldWriteConfig = compiler.writeConfigFilesOnAction && isCompilerDetached; // Write config files to tmp folder

            if (shouldWriteConfig) {
              tmpFolderFullPath = component.getTmpFolder(consumerPath);

              if (verbose) {
                console.log(`\nwriting config files to ${tmpFolderFullPath}`); // eslint-disable-line no-console
              }

              yield (0, _ejectConf().writeEnvFiles)({
                configDir: component.getTmpFolder(),
                env: compiler,
                consumer,
                component,
                deleteOldFiles: false,
                verbose
              });
            }

            const actionParams = {
              files,
              rawConfig: compiler.rawConfig,
              dynamicConfig: compiler.dynamicConfig,
              configFiles: compiler.files,
              api: compiler.api,
              context
            };
            const result = yield Promise.resolve(compiler.action(actionParams));

            if (tmpFolderFullPath) {
              if (verbose) {
                console.log(`\ndeleting tmp directory ${tmpFolderFullPath}`); // eslint-disable-line no-console
              }

              _logger().default.info(`build-components, deleting ${tmpFolderFullPath}`);

              yield _fsExtra().default.remove(tmpFolderFullPath);
            }

            return result;
          } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


          return compiler.oldAction(files, rootDistDir, context);
        } catch (e) {
          if (tmpFolderFullPath) {
            _logger().default.info(`build-components, deleting ${tmpFolderFullPath}`);

            _fsExtra().default.removeSync(tmpFolderFullPath);
          } // Some time an external tool might return a complex object or an array of errors
          // See for example this issue: https://github.com/teambit/bit/issues/2023#issuecomment-534952085
          // (The Vue compiler will return an object with different fields such as details, missing, origin, dependencies, module, name, error)


          const errors = e.errors || (e.error ? [e.error] : [e]);
          const err = new (_externalBuildErrors().default)(component.id.toString(), errors);
          throw err;
        }
      });

      return function getBuildResults() {
        return _ref3.apply(this, arguments);
      };
    }();

    const buildResults = yield getBuildResults(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return _objectSpread({}, _extractAndVerifyCompilerResults(buildResults), {
      shouldBuildUponDependenciesChanges
    });
  });
  return _runBuild2.apply(this, arguments);
}