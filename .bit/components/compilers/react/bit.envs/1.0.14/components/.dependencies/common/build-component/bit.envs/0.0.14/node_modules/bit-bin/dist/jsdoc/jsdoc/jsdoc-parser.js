"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = parse;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _extractDataRegex() {
  const data = _interopRequireDefault(require("../extract-data-regex"));

  _extractDataRegex = function () {
    return data;
  };

  return data;
}

function parse(_x, _x2) {
  return _parse.apply(this, arguments);
}

function _parse() {
  _parse = (0, _bluebird().coroutine)(function* (data, filePath) {
    const doclets = [];

    try {
      /**
       * [ \t]*  => can start with any number of tabs
       * \/\*\*  => must start with exact `/**`
       * \s*     => may follow with any number of white spaces
       * [^*]*   => anything except star may repeat
       * ([^\*]|(\*(?!\/)))* => may follow with stars as long as there is no "/" after the star
       * \*\/ => must finish with a star and then \.
       * This was taken as a combination of:
       * https://stackoverflow.com/questions/35905181/regex-for-jsdoc-comments
       * https://github.com/neogeek/jsdoc-regex/blob/master/index.js
       */
      const jsdocRegex = /[ \t]*\/\*\*\s*\n([^*]|(\*(?!\/)))*\*\//g;
      const docs = data.match(jsdocRegex); // populate doclets array
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      docs.forEach(doc => (0, _extractDataRegex().default)(doc, doclets, filePath));
    } catch (e) {
      // never mind, ignore the doc of this source
      _logger().default.debug(`failed parsing docs using on path ${filePath} with error`, e);
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    return doclets.filter(doclet => doclet.access === 'public');
  });
  return _parse.apply(this, arguments);
}