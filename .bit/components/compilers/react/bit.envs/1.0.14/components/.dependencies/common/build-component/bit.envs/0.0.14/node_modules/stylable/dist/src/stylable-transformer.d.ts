import * as postcss from 'postcss';
import { FileProcessor } from './cached-process-file';
import { Diagnostics } from './diagnostics';
import { SelectorAstNode } from './selector-utils';
import { ClassSymbol, StylableMeta, StylableSymbol } from './stylable-processor';
import { CSSResolve, StylableResolver } from './stylable-resolver';
import { Pojo } from './types';
export interface ResolvedElement {
    name: string;
    type: string;
    resolved: CSSResolve[];
}
export interface KeyFrameWithNode {
    value: string;
    node: postcss.Node;
}
export interface StylableResults {
    meta: StylableMeta;
    exports: Pojo<string>;
}
export interface ScopedSelectorResults {
    current: StylableMeta;
    symbol: StylableSymbol | null;
    selectorAst: SelectorAstNode;
    selector: string;
    elements: ResolvedElement[][];
}
export declare type replaceValueHook = (value: string, name: string | {
    name: string;
    args: string[];
}, isLocal: boolean, passedThrough: string[]) => string;
export declare type postProcessor<T = {}> = (stylableResults: StylableResults, transformer: StylableTransformer) => StylableResults & T;
export interface TransformHooks {
    postProcessor?: postProcessor;
    replaceValueHook?: replaceValueHook;
}
export interface Options {
    fileProcessor: FileProcessor<StylableMeta>;
    requireModule: (modulePath: string) => any;
    diagnostics: Diagnostics;
    delimiter?: string;
    keepValues?: boolean;
    optimize?: boolean;
    replaceValueHook?: replaceValueHook;
    postProcessor?: postProcessor;
    scopeRoot?: boolean;
}
export interface AdditionalSelector {
    selectorNode: SelectorAstNode;
    node: SelectorAstNode;
    customElementChunk: string;
}
export declare class StylableTransformer {
    fileProcessor: FileProcessor<StylableMeta>;
    diagnostics: Diagnostics;
    resolver: StylableResolver;
    delimiter: string;
    keepValues: boolean;
    optimize: boolean;
    scopeRoot: boolean;
    replaceValueHook: replaceValueHook | undefined;
    postProcessor: postProcessor | undefined;
    constructor(options: Options);
    transform(meta: StylableMeta): StylableResults;
    transformAst(ast: postcss.Root, meta: StylableMeta, scopeRoot?: boolean, metaExports?: Pojo<string>, variableOverride?: Pojo<string>, path?: string[]): void;
    isChildOfAtRule(rule: postcss.Rule, atRuleName: string): boolean;
    exportLocalVars(meta: StylableMeta, metaExports: Pojo<string>, variableOverride?: Pojo<string>): void;
    exportKeyframes(keyframeMapping: Pojo<KeyFrameWithNode>, metaExports: Pojo<string>): void;
    exportRootClass(meta: StylableMeta, metaExports: Pojo<string>): void;
    exportClass(meta: StylableMeta, name: string, classSymbol: ClassSymbol, metaExports?: Pojo<string>): string;
    scopeKeyframes(ast: postcss.Root, meta: StylableMeta): Pojo<KeyFrameWithNode>;
    resolveSelectorElements(meta: StylableMeta, selector: string): ResolvedElement[][];
    scopeSelector(meta: StylableMeta, selector: string, metaExports?: Pojo<string>, scopeRoot?: boolean, calcPaths?: boolean, rule?: postcss.Rule): ScopedSelectorResults;
    addAdditionalSelectors(addedSelectors: AdditionalSelector[], selectorAst: SelectorAstNode): void;
    applyRootScoping(meta: StylableMeta, selectorAst: SelectorAstNode): void;
    scopeRule(meta: StylableMeta, rule: postcss.Rule, scopeRoot: boolean, metaExports?: Pojo<string>): string;
    handleClass(meta: StylableMeta, node: SelectorAstNode, name: string, metaExports?: Pojo<string>): CSSResolve;
    handleElement(meta: StylableMeta, node: SelectorAstNode, name: string): CSSResolve | {
        meta: StylableMeta;
        symbol: StylableSymbol;
    };
    handlePseudoElement(meta: StylableMeta, node: SelectorAstNode, name: string, selectorNode: SelectorAstNode, addedSelectors: AdditionalSelector[], rule?: postcss.Rule): CSSResolve;
    cssStates(stateMapping: Pojo<boolean> | null | undefined, namespace: string): {};
    scope(name: string, namespace: string, delimiter?: string): string;
}
