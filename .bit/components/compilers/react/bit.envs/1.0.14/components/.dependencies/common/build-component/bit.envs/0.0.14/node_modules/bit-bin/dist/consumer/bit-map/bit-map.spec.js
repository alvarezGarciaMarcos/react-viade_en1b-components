"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _chai() {
  const data = require("chai");

  _chai = function () {
    return data;
  };

  return data;
}

function _bitMap() {
  const data = _interopRequireDefault(require("./bit-map"));

  _bitMap = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _configDir() {
  const data = _interopRequireDefault(require("./config-dir"));

  _configDir = function () {
    return data;
  };

  return data;
}

const bitMapFixtureDir = path().join(__dirname, '../../../fixtures/bitmap-fixtures');
const addComponentParamsFixture = {
  componentId: new (_bitId().BitId)({
    name: 'is-string'
  }),
  files: [{
    name: 'is-string.js',
    relativePath: 'is-string.js',
    test: false
  }],
  mainFile: 'is-string.js',
  origin: _constants().COMPONENT_ORIGINS.AUTHORED
};
const addComponentParamsImportedFixture = {
  componentId: new (_bitId().BitId)({
    scope: 'my-scope',
    name: 'is-string-imported',
    version: '0.0.1'
  }),
  files: [{
    name: 'is-string-imported.js',
    relativePath: 'is-string-imported.js',
    test: false
  }],
  mainFile: 'is-string-imported.js',
  origin: _constants().COMPONENT_ORIGINS.IMPORTED,
  rootDir: 'utils'
};
describe('BitMap', function () {
  // @ts-ignore
  _logger().default.debug = () => {}; // @ts-ignore


  _logger().default.info = () => {};

  this.timeout(0);
  describe('toObject', () => {
    let bitMap;
    let componentMap;
    before(() => {
      bitMap = _bitMap().default.load(__dirname);
      bitMap.addComponent(addComponentParamsFixture);
      const allComponents = bitMap.toObjects();
      componentMap = allComponents['is-string'];
    });
    it('should remove the "id" property', () => {
      (0, _chai().expect)(componentMap).to.not.have.property('id');
    });
    it('should add "exported" property to authored components', () => {
      (0, _chai().expect)(componentMap).to.have.property('exported');
      (0, _chai().expect)(componentMap.exported).to.be.false;
    });
    it('should not add "exported" property to imported components', () => {
      bitMap.addComponent(addComponentParamsImportedFixture);
      const allComponents = bitMap.toObjects();
      const componentMapImported = allComponents['my-scope/is-string-imported@0.0.1'];
      (0, _chai().expect)(componentMapImported).to.not.have.property('exported');
    });
  });
  describe('getAuthoredExportedComponents', () => {
    it('should return an empty array when there are no authored components', () => {
      const bitMap = _bitMap().default.load(path().join(bitMapFixtureDir, 'only-imported'));

      const results = bitMap.getAuthoredExportedComponents();
      (0, _chai().expect)(results).to.be.an('array');
      (0, _chai().expect)(results).to.have.lengthOf(0);
    });
  });
  describe('resolveIgnoreFilesAndDirs', () => {
    it('should ignore whole folder if the config dir is not in component dir', () => {
      const res = _bitMap().default.resolveIgnoreFilesAndDirs('conf-dir', 'my-comp-dir', ['./.babelrc'], ['./mochaConf.js']);

      (0, _chai().expect)(res.dirs).to.contain('conf-dir');
    });
    it('should ignore nothing if there is no config dir', () => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const res = _bitMap().default.resolveIgnoreFilesAndDirs(null, 'my-comp-dir', ['./.babelrc'], ['./mochaConf.js']);

      (0, _chai().expect)(res.dirs).to.be.empty;
      (0, _chai().expect)(res.files).to.be.empty;
    });
    it('should ignore nested dir inside the component dir', () => {
      const res = _bitMap().default.resolveIgnoreFilesAndDirs('{COMPONENT_DIR}/nested-dir/{ENV_TYPE}', 'my-comp-dir', ['./compiler/.babelrc'], ['./tester/mochaConf.js']);

      (0, _chai().expect)(res.dirs).to.contain('my-comp-dir/nested-dir');
    });
    it('should ignore env types folders if {ENV_TYPE} exists', () => {
      const res = _bitMap().default.resolveIgnoreFilesAndDirs('{COMPONENT_DIR}/{ENV_TYPE}', 'my-comp-dir', ['./compiler/.babelrc'], ['./tester/mochaConf.js']);

      (0, _chai().expect)(res.dirs).to.contain('my-comp-dir/compiler');
      (0, _chai().expect)(res.dirs).to.contain('my-comp-dir/tester');
    });
    it('should ignore all compiler and tester files when {ENV_TYPE} exists', () => {
      const res = _bitMap().default.resolveIgnoreFilesAndDirs('{COMPONENT_DIR}/{ENV_TYPE}', 'my-comp-dir', ['./compiler/.babelrc'], ['./tester/mochaConf.js']);

      (0, _chai().expect)(res.files).to.contain('my-comp-dir/compiler/.babelrc');
      (0, _chai().expect)(res.files).to.contain('my-comp-dir/tester/mochaConf.js');
    });
    it('should ignore all compiler and tester files when {ENV_TYPE} not exists', () => {
      const res = _bitMap().default.resolveIgnoreFilesAndDirs('{COMPONENT_DIR}', 'my-comp-dir', ['./.babelrc'], ['./mochaConf.js']);

      (0, _chai().expect)(res.files).to.contain('my-comp-dir/.babelrc');
      (0, _chai().expect)(res.files).to.contain('my-comp-dir/mochaConf.js');
    });
  });
  describe('parseConfigDir', () => {
    it('without any place holder', () => {
      const results = _bitMap().default.parseConfigDir(new (_configDir().default)('config-dir'), 'root-dir');

      (0, _chai().expect)(results.compiler).to.equal('config-dir');
      (0, _chai().expect)(results.tester).to.equal('config-dir');
    });
    it('with {COMPONENT_DIR}', () => {
      const results = _bitMap().default.parseConfigDir(new (_configDir().default)('{COMPONENT_DIR}'), 'root-dir');

      (0, _chai().expect)(results.compiler).to.equal('root-dir');
      (0, _chai().expect)(results.tester).to.equal('root-dir');
    });
    it('with {COMPONENT_DIR}/{ENV_TYPE}', () => {
      const results = _bitMap().default.parseConfigDir(new (_configDir().default)('{COMPONENT_DIR}/{ENV_TYPE}'), 'root-dir');

      (0, _chai().expect)(results.compiler).to.equal('root-dir/compiler');
      (0, _chai().expect)(results.tester).to.equal('root-dir/tester');
    });
    it('with dir/{ENV_TYPE}', () => {
      const results = _bitMap().default.parseConfigDir(new (_configDir().default)('dir/{ENV_TYPE}'), 'root-dir');

      (0, _chai().expect)(results.compiler).to.equal('dir/compiler');
      (0, _chai().expect)(results.tester).to.equal('dir/tester');
    });
  });
});