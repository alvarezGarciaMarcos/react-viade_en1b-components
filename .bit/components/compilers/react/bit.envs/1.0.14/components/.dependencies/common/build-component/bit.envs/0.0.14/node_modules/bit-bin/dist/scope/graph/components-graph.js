"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.buildComponentsGraph = buildComponentsGraph;
exports.buildComponentsGraphForComponentsAndVersion = buildComponentsGraphForComponentsAndVersion;
exports.topologicalSortComponentDependencies = topologicalSortComponentDependencies;

function _graphlib() {
  const data = _interopRequireWildcard(require("graphlib"));

  _graphlib = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function buildComponentsGraph(components) {
  const graphDeps = new (_graphlib().Graph)();
  const graphDevDeps = new (_graphlib().Graph)();
  const graphCompilerDeps = new (_graphlib().Graph)();
  const graphTesterDeps = new (_graphlib().Graph)();
  components.forEach(component => {
    _setGraphEdges(component.id, component.dependencies, graphDeps);

    _setGraphEdges(component.id, component.devDependencies, graphDevDeps);

    _setGraphEdges(component.id, component.compilerDependencies, graphCompilerDeps);

    _setGraphEdges(component.id, component.testerDependencies, graphTesterDeps);
  });
  return {
    graphDeps,
    graphDevDeps,
    graphCompilerDeps,
    graphTesterDeps
  };
}

function buildComponentsGraphForComponentsAndVersion(components) {
  const graphDeps = new (_graphlib().Graph)();
  const graphDevDeps = new (_graphlib().Graph)();
  const graphCompilerDeps = new (_graphlib().Graph)();
  const graphTesterDeps = new (_graphlib().Graph)();
  components.forEach(({
    component,
    version,
    versionStr
  }) => {
    const bitId = component.toBitId().changeVersion(versionStr);

    _setGraphEdges(bitId, version.dependencies, graphDeps);

    _setGraphEdges(bitId, version.devDependencies, graphDevDeps);

    _setGraphEdges(bitId, version.compilerDependencies, graphCompilerDeps);

    _setGraphEdges(bitId, version.testerDependencies, graphTesterDeps);
  });
  return {
    graphDeps,
    graphDevDeps,
    graphCompilerDeps,
    graphTesterDeps
  };
}

function _setGraphEdges(bitId, dependencies, graph) {
  const id = bitId.toString();
  dependencies.get().forEach(dependency => {
    const depId = dependency.id.toString(); // save the full BitId of a string id to be able to retrieve it later with no confusion

    if (!graph.hasNode(id)) graph.setNode(id, bitId);
    if (!graph.hasNode(depId)) graph.setNode(depId, dependency.id);
    graph.setEdge(id, depId);
  });
}
/**
 * throw for cyclic dependencies
 * it sorts only "dependencies", not "devDependencies" (nor compiler/tester dependencies).
 */


function topologicalSortComponentDependencies(componentWithDependencies) {
  const {
    graphDeps
  } = buildComponentsGraph([componentWithDependencies.component, ...componentWithDependencies.allDependencies]);
  const componentId = componentWithDependencies.component.id.toString();
  let sortedComponents;

  if (!_graphlib().default.alg.isAcyclic(graphDeps)) {
    const circle = _graphlib().default.alg.findCycles(graphDeps);

    throw new (_generalError().default)(`unable to topological sort dependencies of ${componentId}, it has the following cyclic dependencies\n${circle}`);
  }

  try {
    sortedComponents = _graphlib().default.alg.topsort(graphDeps);
    const sortedComponentsIds = sortedComponents.map(s => graphDeps.node(s));

    const sortedDependenciesIds = _ramda().default.tail(sortedComponentsIds); // the first one is the component itself


    const dependencies = sortedDependenciesIds.map(depId => {
      const matchDependency = componentWithDependencies.dependencies.find(dependency => dependency.id.isEqual(depId));
      if (!matchDependency) throw new Error(`topologicalSortComponentDependencies, ${depId.toString()} is missing`);
      return matchDependency;
    });
    componentWithDependencies.dependencies = dependencies;
  } catch (err) {
    throw new (_generalError().default)(`unable to topological sort dependencies of ${componentId}. Original error: ${err.message}`);
  }
}