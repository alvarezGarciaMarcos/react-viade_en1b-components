"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _stringFormat() {
  const data = _interopRequireDefault(require("string-format"));

  _stringFormat = function () {
    return data;
  };

  return data;
}

function _baseExtension() {
  const data = _interopRequireDefault(require("./base-extension"));

  _baseExtension = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = _interopRequireDefault(require("../bit-id/bit-id"));

  _bitId = function () {
    return data;
  };

  return data;
}

function _extensionFile() {
  const data = _interopRequireDefault(require("./extension-file"));

  _extensionFile = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _removeFilesAndEmptyDirsRecursively() {
  const data = _interopRequireDefault(require("../utils/fs/remove-files-and-empty-dirs-recursively"));

  _removeFilesAndEmptyDirsRecursively = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _extensionGetDynamicPackagesError() {
  const data = _interopRequireDefault(require("./exceptions/extension-get-dynamic-packages-error"));

  _extensionGetDynamicPackagesError = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _extensionGetDynamicConfigError() {
  const data = _interopRequireDefault(require("./exceptions/extension-get-dynamic-config-error"));

  _extensionGetDynamicConfigError = function () {
    return data;
  };

  return data;
}

function _installExtensions() {
  const data = _interopRequireDefault(require("../scope/extensions/install-extensions"));

  _installExtensions = function () {
    return data;
  };

  return data;
}

function _dataToPersist() {
  const data = _interopRequireDefault(require("../consumer/component/sources/data-to-persist"));

  _dataToPersist = function () {
    return data;
  };

  return data;
}

function _removePath() {
  const data = _interopRequireDefault(require("../consumer/component/sources/remove-path"));

  _removePath = function () {
    return data;
  };

  return data;
}

function _abstractConfig() {
  const data = _interopRequireDefault(require("../consumer/config/abstract-config"));

  _abstractConfig = function () {
    return data;
  };

  return data;
}

function _envFactory() {
  const data = _interopRequireDefault(require("./env-factory"));

  _envFactory = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

class EnvExtension extends _baseExtension().default {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  /**
   * Return the action
   */
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  get action() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (this.script && this.script.action && typeof this.script.action === 'function') {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return this.script.action;
    }

    return undefined;
  }
  /**
   * return old actions (to support old compilers / testers which uses run / compile functions)
   */
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get oldAction() {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    if (this.script && this.script.run && typeof this.script.run === 'function') {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return this.script.run;
    } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    if (this.script && this.script.compile && typeof this.script.compile === 'function') {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return this.script.compile;
    }

    return undefined;
  }

  constructor(extensionProps) {
    super(extensionProps);
    (0, _defineProperty2().default)(this, "envType", void 0);
    (0, _defineProperty2().default)(this, "dynamicPackageDependencies", void 0);
    (0, _defineProperty2().default)(this, "files", void 0);
    (0, _defineProperty2().default)(this, "dataToPersist", void 0);
    this.envType = extensionProps.envType;
    this.dynamicPackageDependencies = extensionProps.dynamicPackageDependencies;
    this.files = extensionProps.files;
  }

  install(scope, opts, context) {
    var _this = this;

    return (0, _bluebird().coroutine)(function* () {
      _analytics().Analytics.addBreadCrumb('env-extension', 'install env extension');

      _logger().default.debug('env-extension - install env extension'); // Skip the installation in case of using specific file
      // options.file usually used for develop your extension
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      if (_this.options.file) {
        return undefined;
      }

      const dependentId = _ramda().default.path(['dependentId'], context);

      const installOpts = _objectSpread({
        ids: [{
          componentId: _bitId().default.parse(_this.name, true),
          type: _this.envType.toLowerCase()
        }],
        // @todo: make sure it always has a scope name
        dependentId,
        scope
      }, opts); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      const installResult = yield (0, _installExtensions().default)(installOpts);

      _this.setExtensionPathInScope(scope.getPath());

      yield _this.reload(scope.getPath(), context);
      return installResult;
    })();
  }

  toModelObject() {
    const baseObject = super.toModelObject();
    const files = this.files.map(file => file.toModelObject());

    const modelObject = _objectSpread({
      files
    }, baseObject);

    return modelObject;
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  toObject() {
    const baseObject = super.toObject();
    const files = this.files;

    const object = _objectSpread({}, baseObject, {
      files
    });

    return object;
  }
  /**
   * Get a bit.json representation of the env instance
   * @param {string} ejectedEnvDirectory - The base path of where the env config files are stored
   * $FlowFixMe seems to be an issue opened for this https://github.com/facebook/flow/issues/4953
   */
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  toBitJsonObject(ejectedEnvDirectory) {
    _logger().default.debug('env-extension, toBitJsonObject');

    const files = {};
    this.files.forEach(file => {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const relativePath = (0, _utils().pathJoinLinux)(ejectedEnvDirectory, file.relative); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      files[file.name] = `./${relativePath}`;
    });
    const envVal = {
      rawConfig: this.dynamicConfig,
      options: this.options,
      files
    }; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return {
      [this.name]: envVal
    };
  }

  populateDataToPersist({
    configDir,
    envType,
    deleteOldFiles,
    consumer,
    verbose = false
  }) {
    const resolvedEjectedEnvsDirectory = (0, _stringFormat().default)(configDir, {
      ENV_TYPE: envType
    });
    const filePathsToRemove = [];
    this.files.forEach(file => {
      if (deleteOldFiles) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        const pathToDelete = consumer ? consumer.getPathRelativeToConsumer(file.path) : file.path; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        filePathsToRemove.push(pathToDelete);
      } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      file.updatePaths({
        newBase: resolvedEjectedEnvsDirectory,
        newRelative: file.relative
      });
      file.verbose = verbose;
    });
    this.dataToPersist = new (_dataToPersist().default)();
    this.files.forEach(file => {
      const cloned = file.clone();
      cloned.verbose = verbose; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      this.dataToPersist.addFile(cloned);
    });
    filePathsToRemove.map(file => this.dataToPersist.removePath(new (_removePath().default)(file, true)));
    return resolvedEjectedEnvsDirectory;
  }
  /**
   * Delete env files from file system
   */


  removeFilesFromFs(dependencies, configDir, envType, consumerPath) {
    var _this2 = this;

    return (0, _bluebird().coroutine)(function* () {
      _analytics().Analytics.addBreadCrumb('env-extension', 'removeFilesFromFs'); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


      const filePaths = _this2.files.map(file => file.path);

      const relativeSourcePaths = dependencies.getSourcesPaths();
      if (!_this2.context) throw new Error('env-extension.removeFilesFromFs, this.context is missing'); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const componentDir = _this2.context.componentDir;
      const configDirResolved = configDir.getResolved({
        componentDir,
        envType
      });
      const configDirPath = configDirResolved.dirPath;
      const absoluteEnvsDirectory = path().isAbsolute(configDirPath) ? configDirPath : path().join(consumerPath, configDirPath);
      const linkPaths = relativeSourcePaths.map(relativePath => path().join(absoluteEnvsDirectory, relativePath));
      return (0, _removeFilesAndEmptyDirsRecursively().default)([...filePaths, ...linkPaths]);
    })();
  }

  reload(scopePath, context) {
    var _this3 = this,
        _superprop_callReload = (..._args) => super.reload(..._args);

    return (0, _bluebird().coroutine)(function* () {
      _logger().default.debug('env-extension, reload');

      if (context) {
        _this3.context = context;
      }

      const throws = true;
      yield _superprop_callReload(scopePath, {
        throws
      }); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const dynamicPackageDependencies = EnvExtension.loadDynamicPackageDependencies(_this3);
      _this3.dynamicPackageDependencies = dynamicPackageDependencies;
    })();
  }
  /**
   * Loading from props (usually from bit.json)
   * @param {*} props
   * $FlowFixMe seems to be an issue opened for this https://github.com/facebook/flow/issues/4953
   */


  static load(props) {
    var _superprop_callLoad = (..._args2) => super.load(..._args2);

    return (0, _bluebird().coroutine)(function* () {
      const baseExtensionProps = yield _superprop_callLoad(props);
      const files = yield _extensionFile().default.loadFromBitJsonObject( // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      props.files, // $FlowFixMe
      props.consumerPath, props.bitJsonPath, props.envType);

      const envExtensionProps = _objectSpread({
        envType: props.envType,
        files
      }, baseExtensionProps);

      const dynamicPackageDependencies = EnvExtension.loadDynamicPackageDependencies(envExtensionProps);
      envExtensionProps.dynamicPackageDependencies = dynamicPackageDependencies;
      const dynamicConfig = EnvExtension.loadDynamicConfig(envExtensionProps); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      envExtensionProps.dynamicConfig = dynamicConfig;
      return envExtensionProps;
    })();
  }

  static loadDynamicPackageDependencies(envExtensionProps) {
    const getDynamicPackageDependencies = _ramda().default.path(['script', 'getDynamicPackageDependencies'], envExtensionProps);

    if (!getDynamicPackageDependencies || typeof getDynamicPackageDependencies !== 'function') {
      return undefined;
    }

    let dynamicPackageDependencies;

    try {
      dynamicPackageDependencies = getDynamicPackageDependencies({
        rawConfig: envExtensionProps.rawConfig,
        dynamicConfig: envExtensionProps.dynamicConfig,
        configFiles: envExtensionProps.files,
        context: envExtensionProps.context
      });
    } catch (err) {
      throw new (_extensionGetDynamicPackagesError().default)(err, envExtensionProps.name);
    }

    if (!dynamicPackageDependencies) return undefined;

    if (typeof dynamicPackageDependencies !== 'object') {
      throw new (_generalError().default)('expect getDynamicPackageDependencies to return an object');
    } // old format returned an object of the packages, without any separation between
    // dependencies, devDependencies and peerDependencies


    const usesOldFormat = Object.keys(dynamicPackageDependencies).some(field => !_constants().DEPENDENCIES_FIELDS.includes(field));

    if (usesOldFormat) {
      throw new (_generalError().default)(`getDynamicPackageDependencies expects to return the following keys only: [${_constants().DEPENDENCIES_FIELDS.join(', ')}]`);
    }

    return dynamicPackageDependencies;
  }

  static loadDynamicConfig(envExtensionProps) {
    const getDynamicConfig = _ramda().default.path(['script', 'getDynamicConfig'], envExtensionProps);

    if (getDynamicConfig && typeof getDynamicConfig === 'function') {
      try {
        const dynamicConfig = getDynamicConfig({
          rawConfig: envExtensionProps.rawConfig,
          configFiles: envExtensionProps.files,
          context: envExtensionProps.context
        });
        return dynamicConfig;
      } catch (err) {
        throw new (_extensionGetDynamicConfigError().default)(err, envExtensionProps.name);
      }
    }

    return undefined;
  }
  /**
   * $FlowFixMe seems to be an issue opened for this https://github.com/facebook/flow/issues/4953
   */


  static loadFromModelObject(modelObject, repository) {
    var _superprop_callLoadFromModelObject = (..._args3) => super.loadFromModelObject(..._args3);

    return (0, _bluebird().coroutine)(function* () {
      const baseExtensionProps = _superprop_callLoadFromModelObject(modelObject);

      let files = [];

      if (modelObject.files && !_ramda().default.isEmpty(modelObject.files)) {
        const loadFilesP = modelObject.files.map(file => _extensionFile().default.loadFromExtensionFileModel(file, repository)); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        files = yield Promise.all(loadFilesP);
      }

      const envExtensionProps = _objectSpread({
        envType: modelObject.envType,
        files
      }, baseExtensionProps);

      return envExtensionProps;
    })();
  }

  static loadFromSerializedModelObject(modelObject) {
    var _superprop_callLoadFromModelObject2 = (..._args4) => super.loadFromModelObject(..._args4);

    return (0, _bluebird().coroutine)(function* () {
      _logger().default.debug('env-extension, loadFromModelObject');

      const baseExtensionProps = _superprop_callLoadFromModelObject2(modelObject);

      let files = [];

      if (modelObject.files && !_ramda().default.isEmpty(modelObject.files)) {
        const loadFilesP = modelObject.files.map(file => _extensionFile().default.loadFromExtensionFileSerializedModel(file)); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        files = yield Promise.all(loadFilesP);
      }

      const envExtensionProps = _objectSpread({
        envType: modelObject.envType,
        files
      }, baseExtensionProps);

      return envExtensionProps;
    })();
  }
  /**
   * load the compiler/tester according to the following strategies:
   * 1. from component config (bit.json/package.json of the component) if it was written.
   * 2. from component model. an imported component might not have the config written.
   * for author, it's irrelevant, because upon import it's written to consumer config (if changed).
   * 3. from consumer config overrides. (bit.json/package.json of the consumer when this component
   * overrides the general env config).
   * 4. from consumer config.
   */


  static loadFromCorrectSource({
    consumerPath,
    scopePath,
    componentOrigin,
    componentFromModel,
    componentConfig,
    overridesFromConsumer,
    workspaceConfig,
    envType,
    context
  }) {
    return (0, _bluebird().coroutine)(function* () {
      _logger().default.debug(`env-extension (${envType}) loadFromCorrectSource`);

      const isAuthor = componentOrigin === _constants().COMPONENT_ORIGINS.AUTHORED;

      const componentHasWrittenConfig = componentConfig && componentConfig.componentHasWrittenConfig; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      if (componentHasWrittenConfig && componentConfig[envType]) {
        // load from component config.
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        if (Object.keys(componentConfig[envType])[0] === _constants().MANUALLY_REMOVE_ENVIRONMENT) {
          _logger().default.debug(`env-extension, ${envType} was manually removed from the component config`);

          return null;
        } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


        const envConfig = {
          [envType]: componentConfig[envType]
        }; // $FlowFixMe we made sure before that componentConfig is defined
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        const configPath = path().dirname(componentConfig.path);

        _logger().default.debug(`env-extension loading ${envType} from component config`);

        return loadFromConfig({
          envConfig,
          envType,
          consumerPath,
          scopePath,
          configPath,
          context
        });
      }

      if (!componentHasWrittenConfig && !isAuthor && componentFromModel && componentFromModel[envType]) {
        // config was not written into component dir, load the config from the model
        _logger().default.debug(`env-extension, loading ${envType} from the model`);

        return componentFromModel[envType];
      }

      if (overridesFromConsumer && overridesFromConsumer.env && overridesFromConsumer.env[envType]) {
        if (overridesFromConsumer.env[envType] === _constants().MANUALLY_REMOVE_ENVIRONMENT) {
          _logger().default.debug(`env-extension, ${envType} was manually removed from the consumer config overrides`);

          return null;
        }

        _logger().default.debug(`env-extension, loading ${envType} from the consumer config overrides`);

        const envConfig = {
          [envType]: _abstractConfig().default.transformEnvToObject(overridesFromConsumer.env[envType])
        };
        return loadFromConfig({
          envConfig,
          envType,
          consumerPath,
          scopePath,
          configPath: consumerPath,
          context
        });
      }

      if (isAuthor && workspaceConfig[envType]) {
        _logger().default.debug(`env-extension, loading ${envType} from the consumer config`);

        const envConfig = {
          [envType]: workspaceConfig[envType]
        };
        return loadFromConfig({
          envConfig,
          envType,
          consumerPath,
          scopePath,
          configPath: consumerPath,
          context
        });
      }

      return null;
    })();
  }
  /**
   * are two envs (in the model/scope format) different
   */


  static areEnvsDifferent(envModelA, envModelB) {
    const sortEnv = env => {
      env.files = _ramda().default.sortBy(_ramda().default.prop('name'), env.files);
      env.config = (0, _utils().sortObject)(env.config);
      const result = (0, _utils().sortObject)(env);
      return result;
    };

    const stringifyEnv = env => {
      if (!env) {
        return '';
      }

      if (typeof env === 'string') {
        return env;
      }

      return JSON.stringify(sortEnv(env));
    };

    const envModelAString = stringifyEnv(envModelA);
    const envModelBString = stringifyEnv(envModelB); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return (0, _utils().sha1)(envModelAString) !== (0, _utils().sha1)(envModelBString);
  }

}

exports.default = EnvExtension;

function loadFromConfig(_x) {
  return _loadFromConfig.apply(this, arguments);
}

function _loadFromConfig() {
  _loadFromConfig = (0, _bluebird().coroutine)(function* ({
    envConfig,
    envType,
    consumerPath,
    scopePath,
    configPath,
    context
  }) {
    const env = envConfig[envType];
    if (!env) return null;
    const envName = Object.keys(env)[0];
    const envObject = env[envName];
    const envProps = {
      name: envName,
      consumerPath,
      scopePath,
      rawConfig: envObject.rawConfig,
      files: envObject.files,
      bitJsonPath: configPath,
      options: envObject.options,
      envType,
      context
    };
    return (0, _envFactory().default)(envType, envProps);
  });
  return _loadFromConfig.apply(this, arguments);
}