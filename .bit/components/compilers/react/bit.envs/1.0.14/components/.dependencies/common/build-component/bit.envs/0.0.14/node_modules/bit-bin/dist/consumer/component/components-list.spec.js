"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _chai() {
  const data = require("chai");

  _chai = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("./components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _models() {
  const data = require("../../scope/models");

  _models = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

describe('ComponentList', function () {
  this.timeout(0); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  const getModelComponent = () => _models().ModelComponent.fromBitId({
    name: 'myName',
    scope: 'scope'
  });

  const getScope = modelComponent => ({
    listLocal: () => {
      return modelComponent ? Promise.resolve([modelComponent]) : Promise.resolve([]);
    }
  });

  describe('listLocalScope', function () {
    let modelComponent;
    before(() => {
      this.timeout(0);
      modelComponent = getModelComponent();
    });
    it('should return an empty array when there are no components in the scope',
    /*#__PURE__*/
    (0, _bluebird().coroutine)(function* () {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const scope = getScope(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const results = yield _componentsList().default.listLocalScope(scope);
      (0, _chai().expect)(results).to.deep.equal([]);
    }));
    it('should return results with the correct id',
    /*#__PURE__*/
    (0, _bluebird().coroutine)(function* () {
      const scope = getScope(modelComponent); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const results = yield _componentsList().default.listLocalScope(scope);
      const result = results[0];
      (0, _chai().expect)(result).to.have.property('id');
      (0, _chai().expect)(result.id).to.be.an.instanceOf(_bitId().BitId);
    }));
    it('should return results with the correct deprecated status',
    /*#__PURE__*/
    (0, _bluebird().coroutine)(function* () {
      modelComponent.deprecated = true;
      const scope = getScope(modelComponent); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const results = yield _componentsList().default.listLocalScope(scope);
      const result = results[0];
      (0, _chai().expect)(result).to.have.property('deprecated');
      (0, _chai().expect)(result.deprecated).to.be.true;
    }));
  });
  describe('listScope', () => {
    let componentList;
    const scope = {};
    before(() => {
      const bitMap = {
        getAuthoredAndImportedBitIds: () => new (_bitId().BitIds)()
      };
      const consumer = {
        scope,
        bitMap
      }; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      componentList = new (_componentsList().default)(consumer);
    });
    it('should return results with the correct id',
    /*#__PURE__*/
    (0, _bluebird().coroutine)(function* () {
      const modelComponent = getModelComponent(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      scope.list =
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        return [modelComponent];
      });
      const results = yield componentList.listScope(false, true);
      const result = results[0];
      (0, _chai().expect)(result).to.have.property('id');
      (0, _chai().expect)(result.id).to.be.an.instanceOf(_bitId().BitId);
    }));
  });
  describe('filterComponentsByWildcard', () => {
    describe('passing bit ids', () => {
      let bitIds;
      before(() => {
        bitIds = [_bitId().BitId.parse('utils/is/string'), _bitId().BitId.parse('utils/is/type'), _bitId().BitId.parse('utils/fs/read'), _bitId().BitId.parse('utils/fs/write'), _bitId().BitId.parse('bar/foo'), _bitId().BitId.parse('vuz/vuz')];
      });

      const expectToMatch = (idWithWildCard, expectedResults) => {
        const results = _componentsList().default.filterComponentsByWildcard(bitIds, idWithWildCard);

        const resultsStr = results.map(result => result.toString());
        expectedResults.forEach(expectedResult => (0, _chai().expect)(resultsStr).to.include(expectedResult));
        (0, _chai().expect)(results.length).to.equal(expectedResults.length);
      };

      it('should match utils/is/*', () => {
        expectToMatch('utils/is/*', ['utils/is/string', 'utils/is/type']);
      });
      it('should match utils/*', () => {
        expectToMatch('utils/*', ['utils/is/string', 'utils/is/type', 'utils/fs/read', 'utils/fs/write']);
      });
      it('should match *', () => {
        expectToMatch('*', ['utils/is/string', 'utils/is/type', 'utils/fs/read', 'utils/fs/write', 'bar/foo', 'vuz/vuz']);
      });
      it('should match */fs/*', () => {
        expectToMatch('*/fs/*', ['utils/fs/read', 'utils/fs/write']);
      });
      it('should match utils/*/read', () => {
        expectToMatch('utils/*/read', ['utils/fs/read']);
      });
      it('should match v*', () => {
        expectToMatch('v*', ['vuz/vuz']);
      });
      it('should not match non-exist*', () => {
        expectToMatch('non-exist*', []);
      });
      it('should match bit ids also without the scope name', () => {
        expectToMatch('fs*', ['utils/fs/read', 'utils/fs/write']);
      });
      it('should not match s* as non of the ids starts with "s" (with and without scope names)', () => {
        expectToMatch('s*', []);
      });
      it('when no wildcard is specified, it should match an exact id with a scope name', () => {
        expectToMatch('utils/fs/read', ['utils/fs/read']);
      });
      it('when no wildcard is specified, it should match an exact id without a scope name', () => {
        expectToMatch('fs/read', ['utils/fs/read']);
      });
      it('should match multiple different ids when using an array of ids with wildcard', () => {
        expectToMatch(['vuz/*', 'utils/fs/*'], ['vuz/vuz', 'utils/fs/read', 'utils/fs/write']);
      });
    });
  });
});