"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeLocalVersion = removeLocalVersion;
exports.removeLocalVersionsForAllComponents = removeLocalVersionsForAllComponents;
exports.removeLocalVersionsForComponentsMatchedByWildcard = removeLocalVersionsForComponentsMatchedByWildcard;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

/**
 * If not specified version, remove all local versions.
 */
function removeLocalVersion(_x, _x2, _x3) {
  return _removeLocalVersion.apply(this, arguments);
}

function _removeLocalVersion() {
  _removeLocalVersion = (0, _bluebird().coroutine)(function* (scope, id, version, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  force = false) {
    const component = yield scope.getModelComponentIgnoreScope(id);
    const localVersions = component.getLocalVersions();
    const idStr = id.toString();
    if (!localVersions.length) throw new (_generalError().default)(`unable to untag ${idStr}, the component is not staged`);

    if (version && !component.hasVersion(version)) {
      throw new (_generalError().default)(`unable to untag ${idStr}, the version ${version} does not exist`);
    }

    if (version && !localVersions.includes(version)) {
      throw new (_generalError().default)(`unable to untag ${idStr}, the version ${version} was exported already`);
    }

    const versionsToRemove = version ? [version] : localVersions;

    if (!force) {
      const dependencyGraph = yield scope.getDependencyGraph();
      versionsToRemove.forEach(versionToRemove => {
        const idWithVersion = component.toBitId().changeVersion(versionToRemove);
        const dependents = dependencyGraph.getImmediateDependentsPerId(idWithVersion);

        if (dependents.length) {
          throw new (_generalError().default)(`unable to untag ${idStr}, the version ${versionToRemove} has the following dependent(s) ${dependents.join(', ')}`);
        }
      });
    }

    scope.sources.removeComponentVersions(component, versionsToRemove);
    return {
      id,
      versions: versionsToRemove,
      component
    };
  });
  return _removeLocalVersion.apply(this, arguments);
}

function removeLocalVersionsForAllComponents(_x4, _x5) {
  return _removeLocalVersionsForAllComponents.apply(this, arguments);
}

function _removeLocalVersionsForAllComponents() {
  _removeLocalVersionsForAllComponents = (0, _bluebird().coroutine)(function* (scope, version, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  force = false) {
    const componentsToUntag = yield getComponentsWithOptionToUntag(scope, version);
    return removeLocalVersionsForMultipleComponents(componentsToUntag, version, force, scope);
  });
  return _removeLocalVersionsForAllComponents.apply(this, arguments);
}

function removeLocalVersionsForComponentsMatchedByWildcard(_x6, _x7) {
  return _removeLocalVersionsForComponentsMatchedByWildcard.apply(this, arguments);
}

function _removeLocalVersionsForComponentsMatchedByWildcard() {
  _removeLocalVersionsForComponentsMatchedByWildcard = (0, _bluebird().coroutine)(function* (scope, version, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  force = false, idWithWildcard) {
    const candidateComponents = yield getComponentsWithOptionToUntag(scope, version);
    const componentsToUntag = idWithWildcard ? _componentsList().default.filterComponentsByWildcard(candidateComponents, idWithWildcard) : candidateComponents;
    return removeLocalVersionsForMultipleComponents(componentsToUntag, version, force, scope);
  });
  return _removeLocalVersionsForComponentsMatchedByWildcard.apply(this, arguments);
}

function removeLocalVersionsForMultipleComponents(_x8, _x9, _x10, _x11) {
  return _removeLocalVersionsForMultipleComponents.apply(this, arguments);
}

function _removeLocalVersionsForMultipleComponents() {
  _removeLocalVersionsForMultipleComponents = (0, _bluebird().coroutine)(function* (componentsToUntag, version, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  force, scope) {
    if (!componentsToUntag.length) {
      const versionOutput = version ? `${version} ` : '';
      throw new (_generalError().default)(`no components found with version ${versionOutput}to untag on your workspace`);
    } // if no version is given, there is risk of deleting dependencies version without their dependents.


    if (!force && version) {
      const dependencyGraph = yield scope.getDependencyGraph();
      const candidateComponentsIds = componentsToUntag.map(component => {
        const bitId = component.toBitId();
        return bitId.changeVersion(version);
      });
      const candidateComponentsIdsStr = candidateComponentsIds.map(id => id.toString());
      candidateComponentsIds.forEach(bitId => {
        const dependents = dependencyGraph.getImmediateDependentsPerId(bitId); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        const dependentsNotCandidates = dependents.filter(dependent => !candidateComponentsIdsStr.includes(dependent));

        if (dependentsNotCandidates.length) {
          throw new (_generalError().default)( // $FlowFixMe
          `unable to untag ${bitId}, the version ${version} has the following dependent(s) ${dependents.join(', ')}`);
        }
      });
    }

    _logger().default.debug(`found ${componentsToUntag.length} components to untag`);

    return Promise.all(componentsToUntag.map(component => removeLocalVersion(scope, component.toBitId(), version, true)));
  });
  return _removeLocalVersionsForMultipleComponents.apply(this, arguments);
}

function getComponentsWithOptionToUntag(_x12, _x13) {
  return _getComponentsWithOptionToUntag.apply(this, arguments);
}

function _getComponentsWithOptionToUntag() {
  _getComponentsWithOptionToUntag = (0, _bluebird().coroutine)(function* (scope, version) {
    const components = yield scope.list();
    const candidateComponents = components.filter(component => {
      const localVersions = component.getLocalVersions();
      if (!localVersions.length) return false;
      return version ? localVersions.includes(version) : true;
    });
    return candidateComponents;
  });
  return _getComponentsWithOptionToUntag.apply(this, arguments);
}