"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var functions_1 = require("./functions");
var native_reserved_lists_1 = require("./native-reserved-lists");
var pseudo_states_1 = require("./pseudo-states");
var selector_utils_1 = require("./selector-utils");
var stylable_mixins_1 = require("./stylable-mixins");
var stylable_optimizer_1 = require("./stylable-optimizer");
var stylable_resolver_1 = require("./stylable-resolver");
var stylable_utils_1 = require("./stylable-utils");
var stylable_value_parsers_1 = require("./stylable-value-parsers");
var cloneDeep = require('lodash.clonedeep');
var valueParser = require('postcss-value-parser');
var StylableTransformer = /** @class */ (function () {
    function StylableTransformer(options) {
        this.diagnostics = options.diagnostics;
        this.delimiter = options.delimiter || '--';
        this.keepValues = options.keepValues || false;
        this.optimize = options.optimize || false;
        this.fileProcessor = options.fileProcessor;
        this.replaceValueHook = options.replaceValueHook;
        this.postProcessor = options.postProcessor;
        this.scopeRoot = options.scopeRoot === undefined ? true : options.scopeRoot;
        this.resolver = new stylable_resolver_1.StylableResolver(options.fileProcessor, options.requireModule);
    }
    StylableTransformer.prototype.transform = function (meta) {
        var metaExports = {};
        var ast = meta.outputAst = meta.ast.clone();
        this.transformAst(ast, meta, this.scopeRoot, metaExports);
        if (this.optimize) {
            stylable_optimizer_1.removeSTDirective(ast);
        }
        meta.transformDiagnostics = this.diagnostics;
        var result = { meta: meta, exports: metaExports };
        return this.postProcessor ? this.postProcessor(result, this) : result;
    };
    StylableTransformer.prototype.transformAst = function (ast, meta, scopeRoot, metaExports, variableOverride, path) {
        var _this = this;
        if (scopeRoot === void 0) { scopeRoot = false; }
        if (path === void 0) { path = []; }
        var keyframeMapping = this.scopeKeyframes(ast, meta);
        ast.walkRules(function (rule) {
            if (_this.isChildOfAtRule(rule, 'keyframes')) {
                return;
            }
            rule.selector = _this.scopeRule(meta, rule, scopeRoot, metaExports);
        });
        ast.walkAtRules(/media$/, function (atRule) {
            atRule.sourceParams = atRule.params;
            atRule.params = functions_1.evalDeclarationValue(_this.resolver, atRule.params, meta, atRule, variableOverride, _this.replaceValueHook, _this.diagnostics, path.slice());
        });
        ast.walkDecls(function (decl) {
            stylable_utils_1.getDeclStylable(decl).sourceValue = decl.value;
            // TODO: filter out all irrelevant directives
            switch (decl.prop) {
                case stylable_value_parsers_1.valueMapping.mixin:
                    break;
                case stylable_value_parsers_1.valueMapping.states:
                    pseudo_states_1.validateStateDefinition(decl, meta, _this.resolver, _this.diagnostics);
                    break;
                default:
                    decl.value = functions_1.evalDeclarationValue(_this.resolver, decl.value, meta, decl, variableOverride, _this.replaceValueHook, _this.diagnostics, path.slice());
            }
        });
        ast.walkRules(function (rule) { return stylable_mixins_1.appendMixins(_this, rule, meta, variableOverride, path); });
        if (metaExports) {
            this.exportRootClass(meta, metaExports);
            this.exportLocalVars(meta, metaExports, variableOverride);
            this.exportKeyframes(keyframeMapping, metaExports);
        }
    };
    StylableTransformer.prototype.isChildOfAtRule = function (rule, atRuleName) {
        return rule.parent && rule.parent.type === 'atrule' && rule.parent.name === atRuleName;
    };
    StylableTransformer.prototype.exportLocalVars = function (meta, metaExports, variableOverride) {
        var _this = this;
        meta.vars.forEach(function (varSymbol) {
            if (metaExports[varSymbol.name]) {
                _this.diagnostics.warn(varSymbol.node, "symbol '" + varSymbol.name + "' is already in use", { word: varSymbol.name });
            }
            else {
                metaExports[varSymbol.name] = functions_1.evalDeclarationValue(_this.resolver, varSymbol.text, meta, varSymbol.node, variableOverride);
            }
        });
    };
    StylableTransformer.prototype.exportKeyframes = function (keyframeMapping, metaExports) {
        var _this = this;
        Object.keys(keyframeMapping).forEach(function (name) {
            if (metaExports[name] === keyframeMapping[name].value) {
                _this.diagnostics.warn(keyframeMapping[name].node, "symbol " + name + " is already in use", { word: name });
            }
            else {
                metaExports[name] = keyframeMapping[name].value;
            }
        });
    };
    StylableTransformer.prototype.exportRootClass = function (meta, metaExports) {
        var _this = this;
        // TODO: move the theme root composition to the process;
        var classExports = {};
        this.handleClass(meta, {
            type: 'class',
            name: meta.mappedSymbols[meta.root].name,
            nodes: []
        }, meta.mappedSymbols[meta.root].name, classExports);
        var scopedName = classExports[meta.mappedSymbols[meta.root].name];
        meta.imports.forEach(function (_import) {
            if (_import.theme) {
                var resolved = _this.resolver.deepResolve({
                    _kind: 'import',
                    type: 'default',
                    name: 'default',
                    import: _import
                });
                if (resolved && resolved._kind === 'css') {
                    var clsExports = {};
                    _this.exportRootClass(resolved.meta, clsExports);
                    scopedName += ' ' + clsExports[resolved.symbol.name];
                }
                else {
                    var node = stylable_utils_1.findDeclaration(_import, function (n) { return n.prop === stylable_value_parsers_1.valueMapping.from; });
                    _this.diagnostics.error(node, 'Trying to import unknown file', { word: node.value });
                }
            }
        });
        metaExports[meta.root] = scopedName;
    };
    StylableTransformer.prototype.exportClass = function (meta, name, classSymbol, metaExports) {
        var _this = this;
        var scopedName = this.scope(name, meta.namespace);
        if (metaExports && !metaExports[name]) {
            var extend = classSymbol ? classSymbol[stylable_value_parsers_1.valueMapping.extends] : undefined;
            var compose = classSymbol ? classSymbol[stylable_value_parsers_1.valueMapping.compose] : undefined;
            var exportedClasses_1 = scopedName;
            if (extend && extend !== classSymbol) {
                var finalSymbol = void 0;
                var finalName = void 0;
                var finalMeta = void 0;
                if (extend._kind === 'class') {
                    finalSymbol = extend;
                    finalName = extend.name;
                    finalMeta = meta;
                }
                else if (extend._kind === 'import') {
                    var resolved = this.resolver.deepResolve(extend);
                    if (resolved && resolved._kind === 'css' && resolved.symbol) {
                        if (resolved.symbol._kind === 'class') {
                            finalSymbol = resolved.symbol;
                            finalName = resolved.symbol.name;
                            finalMeta = resolved.meta;
                        }
                        else {
                            var found = stylable_utils_1.findRule(meta.ast, '.' + classSymbol.name);
                            if (!!found) {
                                this.diagnostics.error(found, 'import is not extendable', { word: found.value });
                            }
                        }
                    }
                    else {
                        var found = stylable_utils_1.findRule(meta.ast, '.' + classSymbol.name);
                        if (found && resolved) {
                            if (!resolved.symbol) {
                                var importNode = stylable_utils_1.findDeclaration(extend.import, function (node) { return node.prop === stylable_value_parsers_1.valueMapping.named; });
                                this.diagnostics.error(importNode, "Could not resolve '" + found.value + "'", { word: found.value });
                            }
                            else {
                                this.diagnostics.error(found, 'JS import is not extendable', { word: found.value });
                            }
                        }
                        else {
                            var importNode = stylable_utils_1.findDeclaration(extend.import, function (node) { return node.prop === stylable_value_parsers_1.valueMapping.from; });
                            this.diagnostics.error(importNode, "Imported file '" + extend.import.from + "' not found", { word: importNode.value });
                        }
                    }
                }
                if (finalSymbol && finalName && finalMeta && !finalSymbol[stylable_value_parsers_1.valueMapping.root]) {
                    var classExports = {};
                    this.handleClass(finalMeta, { type: 'class', name: finalName, nodes: [] }, finalName, classExports);
                    if (classExports[finalName]) {
                        exportedClasses_1 += ' ' + classExports[finalName];
                    }
                    else {
                        console.error("something went wrong when exporting '" + finalName + "', " +
                            "please file an issue in stylable. With specific use case");
                    }
                }
            }
            if (compose) {
                compose.forEach(function (symbol) {
                    var finalName;
                    var finalMeta;
                    if (symbol._kind === 'class') {
                        finalName = symbol.name;
                        finalMeta = meta;
                    }
                    else if (symbol._kind === 'import') {
                        var resolved = _this.resolver.deepResolve(symbol);
                        if (resolved && resolved._kind === 'css' && resolved.symbol) {
                            if (resolved.symbol._kind === 'class') {
                                finalName = resolved.symbol.name;
                                finalMeta = resolved.meta;
                            }
                            else {
                                // TODO2: warn second phase
                            }
                        }
                        else {
                            // TODO2: warn second phase
                        }
                    }
                    else {
                        // TODO2: warn second phase
                    }
                    if (finalName && finalMeta) {
                        var classExports = {};
                        _this.handleClass(finalMeta, { type: 'class', name: finalName, nodes: [] }, finalName, classExports);
                        if (classExports[finalName]) {
                            exportedClasses_1 += ' ' + classExports[finalName];
                        }
                        else {
                            // TODO2: warn second phase
                        }
                    }
                });
            }
            metaExports[name] = exportedClasses_1;
        }
        return scopedName;
    };
    StylableTransformer.prototype.scopeKeyframes = function (ast, meta) {
        var _this = this;
        var keyframesExports = {};
        ast.walkAtRules(/keyframes$/, function (atRule) {
            var name = atRule.params;
            if (!!~native_reserved_lists_1.reservedKeyFrames.indexOf(name)) {
                _this.diagnostics.error(atRule, "keyframes " + name + " is reserved", { word: name });
            }
            if (!keyframesExports[name]) {
                keyframesExports[name] = {
                    value: _this.scope(name, meta.namespace),
                    node: atRule
                };
            }
            atRule.params = keyframesExports[name].value;
        });
        ast.walkDecls(/animation$|animation-name$/, function (decl) {
            var parsed = valueParser(decl.value);
            parsed.nodes.forEach(function (node) {
                var alias = keyframesExports[node.value] && keyframesExports[node.value].value;
                if (node.type === 'word' && Boolean(alias)) {
                    node.value = alias;
                }
            });
            decl.value = parsed.toString();
        });
        return keyframesExports;
    };
    StylableTransformer.prototype.resolveSelectorElements = function (meta, selector) {
        return this.scopeSelector(meta, selector, undefined, false, true).elements;
    };
    StylableTransformer.prototype.scopeSelector = function (meta, selector, metaExports, scopeRoot, calcPaths, rule) {
        var _this = this;
        if (scopeRoot === void 0) { scopeRoot = false; }
        if (calcPaths === void 0) { calcPaths = false; }
        var current = meta;
        var symbol = null;
        var nestedSymbol;
        var originSymbol;
        var selectorAst = selector_utils_1.parseSelector(selector);
        var addedSelectors = [];
        var elements = selectorAst.nodes.map(function (selectorNode) {
            var selectorElements = [];
            selector_utils_1.traverseNode(selectorNode, function (node) {
                var name = node.name, type = node.type;
                if (calcPaths && (type === 'class' || type === 'element' || type === 'pseudo-element')) {
                    selectorElements.push({
                        name: name,
                        type: type,
                        resolved: _this.resolver.resolveExtends(current, name, type === 'element', _this)
                    });
                }
                if (type === 'selector' || type === 'spacing' || type === 'operator') {
                    if (nestedSymbol) {
                        symbol = nestedSymbol;
                        nestedSymbol = null;
                    }
                    else {
                        current = meta;
                        symbol = meta.classes[meta.root];
                        originSymbol = symbol;
                    }
                }
                else if (type === 'class') {
                    var next = _this.handleClass(current, node, name, metaExports);
                    originSymbol = current.classes[name];
                    symbol = next.symbol;
                    current = next.meta;
                }
                else if (type === 'element') {
                    var next = _this.handleElement(current, node, name);
                    originSymbol = current.elements[name];
                    symbol = next.symbol;
                    current = next.meta;
                }
                else if (type === 'pseudo-element') {
                    var next = _this.handlePseudoElement(current, node, name, selectorNode, addedSelectors, rule);
                    symbol = next.symbol;
                    current = next.meta;
                }
                else if (type === 'pseudo-class') {
                    current = pseudo_states_1.transformPseudoStateSelector(current, node, name, symbol, meta, originSymbol, _this.resolver, _this.diagnostics, rule);
                }
                else if (type === 'nested-pseudo-class') {
                    if (name === 'global') {
                        node.type = 'selector';
                        return true;
                    }
                    nestedSymbol = symbol;
                }
                /* do nothing */
                return undefined;
            });
            return selectorElements;
        });
        this.addAdditionalSelectors(addedSelectors, selectorAst);
        if (scopeRoot) {
            this.applyRootScoping(meta, selectorAst);
        }
        return {
            current: current,
            symbol: symbol,
            selectorAst: selectorAst,
            elements: elements,
            selector: selector_utils_1.stringifySelector(selectorAst)
        };
    };
    StylableTransformer.prototype.addAdditionalSelectors = function (addedSelectors, selectorAst) {
        addedSelectors.forEach(function (s) {
            var clone = cloneDeep(s.selectorNode);
            var i = s.selectorNode.nodes.indexOf(s.node);
            if (i === -1) {
                throw new Error('not supported inside nested classes');
            }
            else {
                clone.nodes[i].value = s.customElementChunk;
            }
            selectorAst.nodes.push(clone);
        });
    };
    StylableTransformer.prototype.applyRootScoping = function (meta, selectorAst) {
        var scopedRoot = meta.mappedSymbols[meta.root][stylable_value_parsers_1.valueMapping.global] ||
            this.scope(meta.root, meta.namespace);
        selectorAst.nodes.forEach(function (selector) {
            var first = selector.nodes[0];
            if (first && first.type === 'selector' && first.name === 'global') {
                return;
            }
            // -st-global can make anther global inside root
            if (first && first.nodes === scopedRoot) {
                return;
            }
            if (first && first.before && first.before === '.' + scopedRoot) {
                return;
            }
            if (first && first.type === 'invalid' && first.value === '&') {
                return;
            }
            if (!first || (first.name !== scopedRoot)) {
                selector.nodes = [
                    typeof scopedRoot !== 'string' ?
                        { type: 'selector', nodes: scopedRoot, name: 'global' } :
                        { type: 'class', name: scopedRoot, nodes: [] },
                    { type: 'spacing', value: ' ', name: '', nodes: [] }
                ].concat(selector.nodes);
            }
        });
    };
    StylableTransformer.prototype.scopeRule = function (meta, rule, scopeRoot, metaExports) {
        return this.scopeSelector(meta, rule.selector, metaExports, scopeRoot, false, rule).selector;
    };
    StylableTransformer.prototype.handleClass = function (meta, node, name, metaExports) {
        var symbol = meta.classes[name];
        var extend = symbol ? symbol[stylable_value_parsers_1.valueMapping.extends] : undefined;
        if (!extend && symbol && symbol.alias) {
            var next_1 = this.resolver.deepResolve(symbol.alias);
            if (next_1 && next_1._kind === 'css' && next_1.symbol && next_1.symbol._kind === 'class') {
                var globalMappedNodes_1 = next_1.symbol[stylable_value_parsers_1.valueMapping.global];
                if (globalMappedNodes_1) {
                    node.before = '';
                    node.type = 'selector';
                    node.nodes = globalMappedNodes_1;
                }
                else {
                    node.name = this.exportClass(next_1.meta, next_1.symbol.name, next_1.symbol, metaExports);
                }
                if (next_1.symbol[stylable_value_parsers_1.valueMapping.extends]) {
                    next_1 = this.resolver.deepResolve(next_1.symbol[stylable_value_parsers_1.valueMapping.extends]);
                    if (next_1 && next_1._kind === 'css') {
                        return next_1;
                    }
                }
                else {
                    return next_1;
                }
            }
            else {
                this.diagnostics.error(symbol.alias.import.rule, 'Trying to import unknown alias', { word: symbol.alias.name });
            }
        }
        var scopedName = '';
        var globalScopedSelector = '';
        var globalMappedNodes = symbol && symbol[stylable_value_parsers_1.valueMapping.global];
        if (globalMappedNodes) {
            globalScopedSelector = selector_utils_1.stringifySelector({ type: 'selector', name: '', nodes: globalMappedNodes });
        }
        else {
            scopedName = this.exportClass(meta, name, symbol, metaExports);
        }
        var next = this.resolver.deepResolve(extend);
        if (next && next._kind === 'css' && next.symbol && next.symbol._kind === 'class') {
            node.before = globalScopedSelector || '.' + scopedName;
            var mappedClassNodes = next.symbol[stylable_value_parsers_1.valueMapping.global];
            if (mappedClassNodes) {
                node.type = 'selector';
                node.nodes = mappedClassNodes;
            }
            else {
                node.name = this.scope(next.symbol.name, next.meta.namespace);
            }
            return next;
        }
        if (extend && extend._kind === 'class') {
            node.before = globalScopedSelector || '.' + scopedName;
            if (extend === symbol && extend.alias) {
                var next_2 = this.resolver.deepResolve(extend.alias);
                if (next_2 && next_2._kind === 'css' && next_2.symbol) {
                    if (next_2.symbol._kind === 'class' && next_2.symbol[stylable_value_parsers_1.valueMapping.global]) {
                        node.before = '';
                        node.type = 'selector';
                        node.nodes = next_2.symbol[stylable_value_parsers_1.valueMapping.global] || [];
                    }
                    else {
                        node.name = this.scope(next_2.symbol.name, next_2.meta.namespace);
                    }
                    // node.name = (next.symbol as ClassSymbol)[valueMapping.global] ||
                    //             this.scope(next.symbol.name, next.meta.namespace);
                    return next_2;
                }
            }
            else {
                node.name = this.scope(extend.name, meta.namespace);
            }
        }
        else {
            if (globalScopedSelector) {
                node.before = '';
                node.type = 'selector';
                node.nodes = symbol[stylable_value_parsers_1.valueMapping.global] || [];
            }
            else {
                node.name = scopedName;
            }
        }
        return { _kind: 'css', meta: meta, symbol: symbol };
    };
    StylableTransformer.prototype.handleElement = function (meta, node, name) {
        var tRule = meta.elements[name];
        var extend = tRule ? meta.mappedSymbols[name] : undefined;
        var next = this.resolver.deepResolve(extend);
        if (next && next._kind === 'css' && next.symbol) {
            if (next.symbol._kind === 'class' && next.symbol[stylable_value_parsers_1.valueMapping.global]) {
                node.before = '';
                node.type = 'selector';
                node.nodes = next.symbol[stylable_value_parsers_1.valueMapping.global] || [];
            }
            else {
                node.type = 'class';
                node.name = this.scope(next.symbol.name, next.meta.namespace);
            }
            // node.name = (next.symbol as ClassSymbol)[valueMapping.global] ||
            //             this.scope(next.symbol.name, next.meta.namespace);
            return next;
        }
        return { meta: meta, symbol: tRule };
    };
    StylableTransformer.prototype.handlePseudoElement = function (meta, node, name, selectorNode, addedSelectors, rule) {
        var next;
        var customSelector = meta.customSelectors[':--' + name];
        if (customSelector) {
            var rootRes = this.scopeSelector(meta, '.root', {}, false);
            var res = this.scopeSelector(meta, customSelector, {}, false);
            var rootEg_1 = new RegExp('^\\s*' + rootRes.selector.replace(/\./, '\\.') + '\\s*');
            var selectors = res.selectorAst.nodes.map(function (sel) { return selector_utils_1.stringifySelector(sel).trim().replace(rootEg_1, ''); });
            if (selectors[0]) {
                node.type = 'invalid'; /*just take it */
                node.before = ' ';
                node.value = selectors[0];
            }
            for (var i = 1 /*start from second one*/; i < selectors.length; i++) {
                addedSelectors.push({
                    selectorNode: selectorNode,
                    node: node,
                    customElementChunk: selectors[i]
                });
            }
            if (res.selectorAst.nodes.length === 1 && res.symbol) {
                return { _kind: 'css', meta: res.current, symbol: res.symbol };
            }
            // this is an error mode fallback
            return { _kind: 'css', meta: meta, symbol: { _kind: 'element', name: '*' } };
        }
        // find if the current symbol exsists in the initial meta;
        var symbol = meta.mappedSymbols[name];
        var current = meta;
        while (!symbol) {
            // go up the root extends path and find first symbol
            var root = current.mappedSymbols[current.root];
            next = this.resolver.deepResolve(root[stylable_value_parsers_1.valueMapping.extends]);
            if (next && next._kind === 'css') {
                current = next.meta;
                symbol = next.meta.mappedSymbols[name];
            }
            else {
                break;
            }
        }
        if (symbol) {
            if (symbol._kind === 'class') {
                node.type = 'class';
                node.before = symbol[stylable_value_parsers_1.valueMapping.root] ? '' : ' ';
                next = this.resolver.deepResolve(symbol);
                if (symbol[stylable_value_parsers_1.valueMapping.global]) {
                    node.type = 'selector';
                    node.nodes = symbol[stylable_value_parsers_1.valueMapping.global] || [];
                }
                else {
                    if (symbol.alias && !symbol[stylable_value_parsers_1.valueMapping.extends]) {
                        if (next && next.meta && next.symbol) {
                            node.name = this.scope(next.symbol.name, next.meta.namespace);
                        }
                        else {
                            // TODO: maybe warn on un resolved alias
                        }
                    }
                    else {
                        node.name = this.scope(symbol.name, current.namespace);
                    }
                }
                if (next && next._kind === 'css') {
                    return next;
                }
            }
        }
        else if (rule) {
            if (native_reserved_lists_1.nativePseudoElements.indexOf(name) === -1) {
                this.diagnostics.warn(rule, "unknown pseudo element \"" + name + "\"", { word: name });
            }
        }
        return { _kind: 'css', meta: current, symbol: symbol };
    };
    StylableTransformer.prototype.cssStates = function (stateMapping, namespace) {
        return stateMapping ? Object.keys(stateMapping).reduce(function (states, key) {
            if (stateMapping[key]) {
                states[pseudo_states_1.autoStateAttrName(key, namespace)] = true;
            }
            return states;
        }, {}) : {};
    };
    StylableTransformer.prototype.scope = function (name, namespace, delimiter) {
        if (delimiter === void 0) { delimiter = this.delimiter; }
        return namespace ? namespace + delimiter + name : name;
    };
    return StylableTransformer;
}());
exports.StylableTransformer = StylableTransformer;
//# sourceMappingURL=stylable-transformer.js.map