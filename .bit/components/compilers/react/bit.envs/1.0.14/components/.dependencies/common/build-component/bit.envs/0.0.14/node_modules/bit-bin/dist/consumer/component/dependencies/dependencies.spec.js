"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _chai() {
  const data = require("chai");

  _chai = function () {
    return data;
  };

  return data;
}

function _() {
  const data = require("./");

  _ = function () {
    return data;
  };

  return data;
}

function _dependenciesFixture() {
  const data = _interopRequireDefault(require("../../../../fixtures/dependencies-fixture.json"));

  _dependenciesFixture = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

// @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
describe('Dependencies', () => {
  describe('validate()', () => {
    let dependencies;
    let validateFunc;
    beforeEach(() => {
      const dependenciesFixtureCloned = _ramda().default.clone(_dependenciesFixture().default);

      dependenciesFixtureCloned.forEach(d => d.id = _bitId().BitId.parse(d.id));
      dependencies = new (_().Dependencies)(dependenciesFixtureCloned);

      validateFunc = () => dependencies.validate();
    });
    it('should not throw when it has a valid dependencies array', () => {
      (0, _chai().expect)(validateFunc).to.not.throw();
    });
    it('should throw when dependencies are not array', () => {
      dependencies.dependencies = {};
      (0, _chai().expect)(validateFunc).to.throw('to be array, got object');
    });
    it('should throw when an individual dependency is not an object', () => {
      dependencies.dependencies[0] = 12;
      (0, _chai().expect)(validateFunc).to.throw('to be object, got number');
    });
    it('should throw when a dependency is missing id', () => {
      delete dependencies.dependencies[0].id;
      (0, _chai().expect)(validateFunc).to.throw('is missing ID');
    });
    it('should throw when a dependency is missing relativePaths', () => {
      delete dependencies.dependencies[0].relativePaths;
      (0, _chai().expect)(validateFunc).to.throw('is missing relativePaths');
    });
    it('should throw when a dependency has an extra attribute other than id and relativePaths', () => {
      dependencies.dependencies[0].extra = 'should not be there!';
      (0, _chai().expect)(validateFunc).to.throw('has an undetected property "extra"');
    });
    it('should throw when relativePaths is not an array', () => {
      dependencies.dependencies[0].relativePaths = {};
      (0, _chai().expect)(validateFunc).to.throw('to be array, got object');
    });
    it('should throw when relativePaths.sourceRelativePath is missing', () => {
      delete dependencies.dependencies[0].relativePaths[0].sourceRelativePath;
      (0, _chai().expect)(validateFunc).to.throw('relativePaths.sourceRelativePath is missing');
    });
    it('should throw when relativePaths.destinationRelativePath is missing', () => {
      delete dependencies.dependencies[0].relativePaths[0].destinationRelativePath;
      (0, _chai().expect)(validateFunc).to.throw('relativePaths.destinationRelativePath is missing');
    });
    it('should throw when a relativePaths has an extra attribute', () => {
      dependencies.dependencies[0].relativePaths[0].extra = 'should not be there!';
      (0, _chai().expect)(validateFunc).to.throw('undetected property of relativePaths "extra"');
    });
    it('should throw when relativePaths.isCustomResolveUsed is true but importSource is missing', () => {
      delete dependencies.dependencies[0].relativePaths[0].importSource;
      (0, _chai().expect)(validateFunc).to.throw('missing relativePath.importSource');
    });
    it('should not throw when both relativePaths.isCustomResolveUsed and relativePaths.importSource are missing', () => {
      delete dependencies.dependencies[0].relativePaths[0].isCustomResolveUsed;
      delete dependencies.dependencies[0].relativePaths[0].importSource;
      (0, _chai().expect)(validateFunc).to.not.throw();
    });
    it('should throw when relativePaths.importSpecifiers is not an array', () => {
      dependencies.dependencies[0].relativePaths[0].importSpecifiers = {};
      (0, _chai().expect)(validateFunc).to.throw('to be array, got object');
    });
    it('should throw when importSpecifier is not an object', () => {
      dependencies.dependencies[0].relativePaths[0].importSpecifiers[0] = [];
      (0, _chai().expect)(validateFunc).to.throw('to be object, got array');
    });
    it('should throw when relativePaths.importSpecifiers has extra attributes', () => {
      dependencies.dependencies[0].relativePaths[0].importSpecifiers[0].extra = 'should not be there!';
      (0, _chai().expect)(validateFunc).to.throw('undetected property of importSpecifier "extra"');
    });
    it('should throw when importSpecifier.mainFile is missing', () => {
      delete dependencies.dependencies[0].relativePaths[0].importSpecifiers[0].mainFile;
      (0, _chai().expect)(validateFunc).to.throw('mainFile property is missing');
    });
    it('should throw when importSpecifier.mainFile.isDefault is missing', () => {
      delete dependencies.dependencies[0].relativePaths[0].importSpecifiers[0].mainFile.isDefault;
      (0, _chai().expect)(validateFunc).to.throw('expected properties of importSpecifier.mainFile "isDefault,name", got "name"');
    });
    it('should throw when importSpecifier.mainFile.name is missing', () => {
      delete dependencies.dependencies[0].relativePaths[0].importSpecifiers[0].mainFile.isDefault;
      (0, _chai().expect)(validateFunc).to.throw('expected properties of importSpecifier.mainFile "isDefault,name", got "name"');
    });
    it('should throw when importSpecifier.mainFile has an extra attribute', () => {
      dependencies.dependencies[0].relativePaths[0].importSpecifiers[0].mainFile.extra = 'invalid';
      (0, _chai().expect)(validateFunc).to.throw('expected properties of importSpecifier.mainFile "isDefault,name", got "extra,isDefault,name"');
    });
  });
});