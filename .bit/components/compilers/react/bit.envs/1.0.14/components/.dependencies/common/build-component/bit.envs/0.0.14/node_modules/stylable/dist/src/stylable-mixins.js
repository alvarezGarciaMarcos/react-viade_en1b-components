"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var postcss = require("postcss");
var functions_1 = require("./functions");
var parser_1 = require("./parser");
var stylable_utils_1 = require("./stylable-utils");
var stylable_value_parsers_1 = require("./stylable-value-parsers");
function appendMixins(transformer, rule, meta, variableOverride, path) {
    if (path === void 0) { path = []; }
    if (!rule.mixins || rule.mixins.length === 0) {
        return;
    }
    rule.mixins.forEach(function (mix) {
        appendMixin(mix, transformer, rule, meta, variableOverride, path);
    });
    rule.mixins.length = 0;
    rule.walkDecls(stylable_value_parsers_1.valueMapping.mixin, function (node) { return node.remove(); });
}
exports.appendMixins = appendMixins;
function appendMixin(mix, transformer, rule, meta, variableOverride, path) {
    if (path === void 0) { path = []; }
    if (checkRecursive(transformer, meta, mix, rule, path)) {
        return;
    }
    var local = meta.mappedSymbols[mix.ref.name];
    if (local && (local._kind === 'class' || local._kind === 'element')) {
        handleLocalClassMixin(mix, transformer, meta, variableOverride, path, rule);
    }
    else {
        var resolvedMixin = transformer.resolver.resolve(mix.ref);
        if (resolvedMixin) {
            if (resolvedMixin._kind === 'js') {
                if (typeof resolvedMixin.symbol === 'function') {
                    try {
                        handleJSMixin(transformer, mix.mixin, resolvedMixin.symbol, meta, rule, variableOverride);
                    }
                    catch (e) {
                        transformer.diagnostics.error(rule, 'could not apply mixin: ' + e, { word: mix.mixin.type });
                        return;
                    }
                }
                else {
                    transformer.diagnostics.error(rule, 'js mixin must be a function', { word: mix.mixin.type });
                }
            }
            else {
                handleImportedCSSMixin(transformer, mix, rule, meta, path, variableOverride);
            }
        }
        else {
            // TODO: error cannot resolve mixin
        }
    }
}
exports.appendMixin = appendMixin;
function checkRecursive(transformer, meta, mix, rule, path) {
    var isRecursive = path.indexOf(mix.ref.name + ' from ' + meta.source) !== -1;
    if (isRecursive) {
        transformer.diagnostics.warn(rule, "circular mixin found: " + path.join(' --> '), { word: mix.ref.name });
        // TODO: add warn
        return true;
    }
    return false;
}
function handleJSMixin(transformer, mixin, mixinFunction, meta, rule, variableOverride) {
    var res = mixinFunction(mixin.options.map(function (v) { return v.value; }));
    var mixinRoot = parser_1.cssObjectToAst(res).root;
    mixinRoot.walkDecls(function (decl) {
        if (!stylable_utils_1.isValidDeclaration(decl)) {
            decl.value = String(decl);
        }
    });
    transformer.transformAst(mixinRoot, meta, false, undefined, variableOverride);
    stylable_utils_1.mergeRules(mixinRoot, rule);
}
function createMixinRootFromCSSResolve(transformer, mix, meta, resolvedClass, path, variableOverride) {
    var isRootMixin = resolvedClass.symbol.name === resolvedClass.meta.root;
    var mixinRoot = stylable_utils_1.createSubsetAst(resolvedClass.meta.ast, (resolvedClass.symbol._kind === 'class' ? '.' : '') + resolvedClass.symbol.name, undefined, isRootMixin);
    var namedArgs = mix.mixin.options;
    var resolvedArgs = functions_1.resolveArgumentsValue(namedArgs, transformer, meta, variableOverride, path);
    var mixinMeta = isRootMixin ? resolvedClass.meta : createInheritedMeta(resolvedClass);
    transformer.transformAst(mixinRoot, mixinMeta, false, undefined, resolvedArgs, path.concat(mix.ref.name + ' from ' + meta.source));
    return mixinRoot;
}
function handleImportedCSSMixin(transformer, mix, rule, meta, path, variableOverride) {
    var resolvedClass = transformer.resolver.resolve(mix.ref);
    var roots = [];
    while (resolvedClass && resolvedClass.symbol && resolvedClass._kind === 'css') {
        roots.push(createMixinRootFromCSSResolve(transformer, mix, meta, resolvedClass, path, variableOverride));
        if ((resolvedClass.symbol._kind === 'class' || resolvedClass.symbol._kind === 'element') &&
            !resolvedClass.symbol[stylable_value_parsers_1.valueMapping.extends]) {
            resolvedClass = transformer.resolver.resolve(resolvedClass.symbol);
        }
        else {
            break;
        }
    }
    if (roots.length) {
        var mixinRoot_1 = postcss.root();
        roots.forEach(function (root) { return mixinRoot_1.prepend.apply(mixinRoot_1, root.nodes); });
        stylable_utils_1.mergeRules(mixinRoot_1, rule);
    }
    else {
        var importNode = stylable_utils_1.findDeclaration(mix.ref.import, function (node) { return node.prop === stylable_value_parsers_1.valueMapping.named; });
        transformer.diagnostics.error(importNode, 'import mixin does not exist', { word: importNode.value });
    }
}
function handleLocalClassMixin(mix, transformer, meta, variableOverride, path, rule) {
    var isRootMixin = mix.ref.name === meta.root;
    var namedArgs = mix.mixin.options;
    var resolvedArgs = functions_1.resolveArgumentsValue(namedArgs, transformer, meta, variableOverride, path);
    var mixinRoot = stylable_utils_1.createSubsetAst(meta.ast, '.' + mix.ref.name, undefined, isRootMixin);
    transformer.transformAst(mixinRoot, isRootMixin ? meta : createInheritedMeta({ meta: meta, symbol: mix.ref, _kind: 'css' }), false, undefined, resolvedArgs, path.concat(mix.ref.name + ' from ' + meta.source));
    stylable_utils_1.mergeRules(mixinRoot, rule);
}
function createInheritedMeta(resolvedClass) {
    var mixinMeta = Object.create(resolvedClass.meta);
    mixinMeta.mappedSymbols = Object.create(resolvedClass.meta.mappedSymbols);
    mixinMeta.mappedSymbols[resolvedClass.meta.root] = resolvedClass.meta.mappedSymbols[resolvedClass.symbol.name];
    return mixinMeta;
}
//# sourceMappingURL=stylable-mixins.js.map