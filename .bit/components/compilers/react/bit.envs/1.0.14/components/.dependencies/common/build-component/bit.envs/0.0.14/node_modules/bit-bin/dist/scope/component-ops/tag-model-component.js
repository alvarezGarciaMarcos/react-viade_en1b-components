"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function RA() {
  const data = _interopRequireWildcard(require("ramda-adjunct"));

  RA = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("../../consumer/exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _validationError() {
  const data = _interopRequireDefault(require("../../error/validation-error"));

  _validationError = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _autoTag() {
  const data = require("./auto-tag");

  _autoTag = function () {
    return data;
  };

  return data;
}

function _componentsGraph() {
  const data = require("../graph/components-graph");

  _componentsGraph = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

function _getFlattenedDependencies() {
  const data = require("./get-flattened-dependencies");

  _getFlattenedDependencies = function () {
    return data;
  };

  return data;
}

function updateDependenciesVersions(componentsToTag) {
  const updateDependencyVersion = dependency => {
    const foundDependency = componentsToTag.find(component => component.id.isEqualWithoutVersion(dependency.id));

    if (foundDependency) {
      dependency.id = dependency.id.changeVersion(foundDependency.version);
    }
  };

  componentsToTag.forEach(oneComponentToTag => {
    oneComponentToTag.getAllDependencies().forEach(dependency => updateDependencyVersion(dependency));
  });
}

function setFutureVersions(_x, _x2, _x3, _x4) {
  return _setFutureVersions.apply(this, arguments);
}
/**
 * make sure the originallySharedDir was added before saving the component. also, make sure it was
 * not added twice.
 * we need three objects for this:
 * 1) component.pendingVersion => version pending to be saved in the filesystem. we want to make sure it has the added sharedDir.
 * 2) component.componentFromModel => previous version of the component. it has the original sharedDir.
 * 3) component.componentMap => current paths in the filesystem, which don't have the sharedDir.
 *
 * The component may be changed from the componentFromModel. The files may be removed and added and
 * new files may added, so we can't compare the files of componentFromModel to component.
 *
 * What we can do is calculating the sharedDir from component.componentFromModel
 * then, make sure that calculatedSharedDir + pathFromComponentMap === component.pendingVersion
 *
 * Also, make sure that the wrapDir has been removed
 */


function _setFutureVersions() {
  _setFutureVersions = (0, _bluebird().coroutine)(function* (componentsToTag, scope, releaseType, exactVersion) {
    yield Promise.all(componentsToTag.map(
    /*#__PURE__*/
    function () {
      var _ref3 = (0, _bluebird().coroutine)(function* (componentToTag) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        const modelComponent = yield scope.sources.findOrAddComponent(componentToTag);
        const version = modelComponent.getVersionToAdd(releaseType, exactVersion); // @ts-ignore usedVersion is needed only for this, that's why it's not declared on the instance

        componentToTag.usedVersion = componentToTag.version;
        componentToTag.version = version;
      });

      return function (_x8) {
        return _ref3.apply(this, arguments);
      };
    }()));
  });
  return _setFutureVersions.apply(this, arguments);
}

function validateDirManipulation(components) {
  const throwOnError = (expectedPath, actualPath) => {
    if (expectedPath !== actualPath) {
      throw new (_validationError().default)(`failed validating the component paths with sharedDir, expected path ${expectedPath}, got ${actualPath}`);
    }
  };

  const validateComponent = component => {
    if (!component.componentMap) throw new Error(`componentMap is missing from ${component.id.toString()}`);
    if (!component.componentFromModel) return; // component.componentFromModel.setOriginallySharedDir();

    const sharedDir = component.componentFromModel.originallySharedDir;
    const wrapDir = component.componentFromModel.wrapDir;

    const pathWithSharedDir = pathStr => {
      // $FlowFixMe componentMap is set here
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      if (sharedDir && component.componentMap.origin === _constants().COMPONENT_ORIGINS.IMPORTED) {
        return (0, _utils().pathJoinLinux)(sharedDir, pathStr);
      }

      return pathStr;
    };

    const pathWithoutWrapDir = pathStr => {
      if (wrapDir) {
        return pathStr.replace(`${wrapDir}/`, '');
      }

      return pathStr;
    };

    const pathAfterDirManipulation = pathStr => {
      const withoutWrapDir = pathWithoutWrapDir(pathStr);
      return pathWithSharedDir(withoutWrapDir);
    };

    const expectedMainFile = pathAfterDirManipulation(component.componentMap.mainFile); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    throwOnError(expectedMainFile, component.pendingVersion.mainFile); // $FlowFixMe componentMap is set here

    const componentMapFiles = component.componentMap.getAllFilesPaths(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const componentFiles = component.pendingVersion.files.map(file => file.relativePath);
    componentMapFiles.forEach(file => {
      const expectedFile = pathAfterDirManipulation(file);

      if (!componentFiles.includes(expectedFile)) {
        throw new (_validationError().default)(`failed validating the component paths, expected a file ${expectedFile} to be in ${componentFiles.toString()} array`);
      }
    });
  };

  components.forEach(component => validateComponent(component));
}

var _default =
/*#__PURE__*/
function () {
  var _tagModelComponent = (0, _bluebird().coroutine)(function* ({
    consumerComponents,
    scope,
    message,
    exactVersion,
    releaseType,
    force,
    consumer,
    ignoreNewestVersion = false,
    skipTests = false,
    verbose = false,
    skipAutoTag
  }) {
    _loader().default.start(_loaderMessages().BEFORE_IMPORT_PUT_ON_SCOPE);

    const consumerComponentsIdsMap = {}; // Concat and unique all the dependencies from all the components so we will not import
    // the same dependency more then once, it's mainly for performance purpose

    consumerComponents.forEach(consumerComponent => {
      const componentIdString = consumerComponent.id.toString(); // Store it in a map so we can take it easily from the sorted array which contain only the id

      consumerComponentsIdsMap[componentIdString] = consumerComponent;
    });

    const componentsToTag = _ramda().default.values(consumerComponentsIdsMap); // consumerComponents unique


    const componentsToTagIds = componentsToTag.map(c => c.id);
    const componentsToTagIdsLatest = yield scope.latestVersions(componentsToTagIds, false);
    const autoTagCandidates = skipAutoTag ? new (_bitId().BitIds)() : consumer.potentialComponentsForAutoTagging(componentsToTagIdsLatest);
    const autoTagComponents = skipAutoTag ? [] : yield (0, _autoTag().getAutoTagPending)(scope, autoTagCandidates, componentsToTagIdsLatest); // scope.toConsumerComponents(autoTaggedCandidates); won't work as it doesn't have the paths according to bitmap
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const autoTagComponentsLoaded = yield consumer.loadComponents(autoTagComponents.map(c => c.toBitId()));
    const autoTagConsumerComponents = autoTagComponentsLoaded.components;
    const componentsToBuildAndTest = componentsToTag.concat(autoTagConsumerComponents); // check for each one of the components whether it is using an old version

    if (!ignoreNewestVersion) {
      const newestVersionsP = componentsToBuildAndTest.map(
      /*#__PURE__*/
      function () {
        var _ref = (0, _bluebird().coroutine)(function* (component) {
          if (component.componentFromModel) {
            // otherwise it's a new component, so this check is irrelevant
            const modelComponent = yield scope.getModelComponentIfExist(component.id);
            if (!modelComponent) throw new (_showDoctorError().default)(`component ${component.id} was not found in the model`);
            const latest = modelComponent.latest();

            if (latest !== component.version) {
              return {
                componentId: component.id.toStringWithoutVersion(),
                currentVersion: component.version,
                latestVersion: latest
              };
            }
          }

          return null;
        });

        return function (_x6) {
          return _ref.apply(this, arguments);
        };
      }());
      const newestVersions = yield Promise.all(newestVersionsP);
      const newestVersionsWithoutEmpty = newestVersions.filter(newest => newest);

      if (!RA().isNilOrEmpty(newestVersionsWithoutEmpty)) {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        throw new (_exceptions().NewerVersionFound)(newestVersionsWithoutEmpty);
      }
    }

    _logger().default.debug('scope.putMany: sequentially build all components');

    _analytics().Analytics.addBreadCrumb('scope.putMany', 'scope.putMany: sequentially build all components');

    yield scope.buildMultiple(componentsToBuildAndTest, consumer, false, verbose);

    _logger().default.debug('scope.putMany: sequentially test all components');

    let testsResults = [];

    if (!skipTests) {
      const testsResultsP = scope.testMultiple({
        components: componentsToBuildAndTest,
        consumer,
        verbose,
        rejectOnFailure: !force
      });

      try {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        testsResults = yield testsResultsP;
      } catch (err) {
        // if force is true, ignore the tests and continue
        if (!force) {
          // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
          if (!verbose) throw new (_exceptions().ComponentSpecsFailed)();
          throw err;
        }
      }
    }

    _logger().default.debug('scope.putMany: sequentially persist all components');

    _analytics().Analytics.addBreadCrumb('scope.putMany', 'scope.putMany: sequentially persist all components'); // go through all components and find the future versions for them


    yield setFutureVersions(componentsToTag, scope, releaseType, exactVersion); // go through all dependencies and update their versions

    updateDependenciesVersions(componentsToTag); // build the dependencies graph

    const allDependenciesGraphs = (0, _componentsGraph().buildComponentsGraph)(componentsToTag);
    const dependenciesCache = {};
    const notFoundDependencies = new (_bitId().BitIds)();

    const persistComponent =
    /*#__PURE__*/
    function () {
      var _ref2 = (0, _bluebird().coroutine)(function* (consumerComponent) {
        let testResult;

        if (!skipTests) {
          testResult = testsResults.find(result => {
            // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
            return consumerComponent.id.isEqualWithoutScopeAndVersion(result.componentId);
          });
        }

        const {
          flattenedDependencies,
          flattenedDevDependencies,
          flattenedCompilerDependencies,
          flattenedTesterDependencies
        } = yield (0, _getFlattenedDependencies().getAllFlattenedDependencies)(scope, consumerComponent.id, allDependenciesGraphs, dependenciesCache, notFoundDependencies);
        yield scope.sources.addSource({
          source: consumerComponent,
          consumer,
          flattenedDependencies,
          flattenedDevDependencies,
          flattenedCompilerDependencies,
          flattenedTesterDependencies,
          message,
          specsResults: testResult ? testResult.specs : undefined
        });
        return consumerComponent;
      });

      return function persistComponent(_x7) {
        return _ref2.apply(this, arguments);
      };
    }(); // Run the persistence one by one not in parallel!


    _loader().default.start(_loaderMessages().BEFORE_PERSISTING_PUT_ON_SCOPE);

    const taggedComponents = yield (0, _pMapSeries().default)(componentsToTag, consumerComponent => persistComponent(consumerComponent));
    const autoTaggedResults = yield (0, _autoTag().bumpDependenciesVersions)(scope, autoTagCandidates, taggedComponents);
    validateDirManipulation(taggedComponents);
    yield scope.objects.persist();
    return {
      taggedComponents,
      autoTaggedResults
    };
  });

  function tagModelComponent(_x5) {
    return _tagModelComponent.apply(this, arguments);
  }

  return tagModelComponent;
}();

exports.default = _default;