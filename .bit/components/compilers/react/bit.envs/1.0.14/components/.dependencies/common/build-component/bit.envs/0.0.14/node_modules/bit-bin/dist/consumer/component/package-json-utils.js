"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addComponentsToRoot = addComponentsToRoot;
exports.addComponentsWithVersionToRoot = addComponentsWithVersionToRoot;
exports.changeDependenciesToRelativeSyntax = changeDependenciesToRelativeSyntax;
exports.preparePackageJsonToWrite = preparePackageJsonToWrite;
exports.updateAttribute = updateAttribute;
exports.addWorkspacesToPackageJson = addWorkspacesToPackageJson;
exports.removeComponentsFromWorkspacesAndDependencies = removeComponentsFromWorkspacesAndDependencies;
exports.convertToValidPathForPackageManager = convertToValidPathForPackageManager;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = require("../../utils/path");

  _path = function () {
    return data;
  };

  return data;
}

function _componentNodeModulesPath() {
  const data = _interopRequireDefault(require("../../utils/bit/component-node-modules-path"));

  _componentNodeModulesPath = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _npmRegistryName() {
  const data = _interopRequireDefault(require("../../utils/bit/npm-registry-name"));

  _npmRegistryName = function () {
    return data;
  };

  return data;
}

function _componentIdToPackageName() {
  const data = _interopRequireDefault(require("../../utils/bit/component-id-to-package-name"));

  _componentIdToPackageName = function () {
    return data;
  };

  return data;
}

function _packageJsonFile() {
  const data = _interopRequireDefault(require("./package-json-file"));

  _packageJsonFile = function () {
    return data;
  };

  return data;
}

function _searchFilesIgnoreExt() {
  const data = _interopRequireDefault(require("../../utils/fs/search-files-ignore-ext"));

  _searchFilesIgnoreExt = function () {
    return data;
  };

  return data;
}

function _showDoctorError() {
  const data = _interopRequireDefault(require("../../error/show-doctor-error"));

  _showDoctorError = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

/**
 * Add components as dependencies to root package.json
 */
function addComponentsToRoot(_x, _x2) {
  return _addComponentsToRoot.apply(this, arguments);
}
/**
 * Add given components with their versions to root package.json
 */


function _addComponentsToRoot() {
  _addComponentsToRoot = (0, _bluebird().coroutine)(function* (consumer, components) {
    const componentsToAdd = components.reduce((acc, component) => {
      const componentMap = consumer.bitMap.getComponent(component.id);
      if (componentMap.origin !== _constants().COMPONENT_ORIGINS.IMPORTED) return acc;

      if (!componentMap.rootDir) {
        throw new (_showDoctorError().default)(`rootDir is missing from an imported component ${component.id.toString()}`);
      }

      const locationAsUnixFormat = convertToValidPathForPackageManager(componentMap.rootDir);
      const packageName = (0, _componentIdToPackageName().default)(component.id, component.bindingPrefix);
      acc[packageName] = locationAsUnixFormat;
      return acc;
    }, {});
    if (_ramda().default.isEmpty(componentsToAdd)) return;
    yield _addDependenciesPackagesIntoPackageJson(consumer.getPath(), componentsToAdd);
  });
  return _addComponentsToRoot.apply(this, arguments);
}

function addComponentsWithVersionToRoot(_x3, _x4) {
  return _addComponentsWithVersionToRoot.apply(this, arguments);
}

function _addComponentsWithVersionToRoot() {
  _addComponentsWithVersionToRoot = (0, _bluebird().coroutine)(function* (consumer, componentsVersions) {
    const componentsToAdd = _ramda().default.fromPairs(componentsVersions.map(({
      component,
      version
    }) => {
      const packageName = (0, _componentIdToPackageName().default)(component.toBitId(), component.bindingPrefix);
      return [packageName, version];
    }));

    yield _addDependenciesPackagesIntoPackageJson(consumer.getPath(), componentsToAdd);
  });
  return _addComponentsWithVersionToRoot.apply(this, arguments);
}

function changeDependenciesToRelativeSyntax(_x5, _x6, _x7) {
  return _changeDependenciesToRelativeSyntax.apply(this, arguments);
}

function _changeDependenciesToRelativeSyntax() {
  _changeDependenciesToRelativeSyntax = (0, _bluebird().coroutine)(function* (consumer, components, dependencies) {
    const dependenciesIds = _bitId().BitIds.fromArray(dependencies.map(dependency => dependency.id));

    const updateComponentPackageJson =
    /*#__PURE__*/
    function () {
      var _ref = (0, _bluebird().coroutine)(function* (component) {
        const componentMap = consumer.bitMap.getComponent(component.id);
        const componentRootDir = componentMap.rootDir;
        if (!componentRootDir) return null;
        const packageJsonFile = yield _packageJsonFile().default.load(consumer.getPath(), componentRootDir);
        if (!packageJsonFile.fileExist) return null; // if package.json doesn't exist no need to update anything

        const devDeps = getPackages(component.devDependencies, componentMap);
        const compilerDeps = getPackages(component.compilerDependencies, componentMap);
        const testerDeps = getPackages(component.testerDependencies, componentMap);
        packageJsonFile.addDependencies(getPackages(component.dependencies, componentMap));
        packageJsonFile.addDevDependencies(_objectSpread({}, devDeps, {}, compilerDeps, {}, testerDeps));
        return packageJsonFile.toVinylFile();
      });

      return function updateComponentPackageJson(_x20) {
        return _ref.apply(this, arguments);
      };
    }();

    const packageJsonFiles = yield Promise.all(components.map(component => updateComponentPackageJson(component))); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return packageJsonFiles.filter(file => file);

    function getPackages(deps, componentMap) {
      return deps.get().reduce((acc, dependency) => {
        const dependencyId = dependency.id.toStringWithoutVersion();

        if (dependenciesIds.searchWithoutVersion(dependency.id)) {
          const dependencyComponent = dependencies.find(d => d.id.isEqualWithoutVersion(dependency.id));

          if (!dependencyComponent) {
            throw new Error('getDependenciesAsPackages, dependencyComponent is missing');
          }

          const dependencyComponentMap = consumer.bitMap.getComponentIfExist(dependencyComponent.id); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

          const dependencyPackageValue = getPackageDependencyValue(dependencyId, componentMap, dependencyComponentMap);

          if (dependencyPackageValue) {
            const packageName = (0, _componentIdToPackageName().default)(dependency.id, dependencyComponent.bindingPrefix || (0, _npmRegistryName().default)());
            acc[packageName] = dependencyPackageValue;
          }
        }

        return acc;
      }, {});
    }
  });
  return _changeDependenciesToRelativeSyntax.apply(this, arguments);
}

function preparePackageJsonToWrite(bitMap, component, bitDir, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
override = true, writeBitDependencies = false, excludeRegistryPrefix) {
  _logger().default.debug(`package-json.preparePackageJsonToWrite. bitDir ${bitDir}. override ${override.toString()}`);

  const getBitDependencies = dependencies => {
    if (!writeBitDependencies) return {};
    return dependencies.get().reduce((acc, dep) => {
      const packageDependency = getPackageDependency(bitMap, dep.id, component.id);
      const packageName = (0, _componentIdToPackageName().default)(dep.id, component.bindingPrefix || (0, _npmRegistryName().default)());
      acc[packageName] = packageDependency;
      return acc;
    }, {});
  };

  const bitDependencies = getBitDependencies(component.dependencies);
  const bitDevDependencies = getBitDependencies(component.devDependencies);
  const bitCompilerDependencies = getBitDependencies(component.compilerDependencies);
  const bitTesterDependencies = getBitDependencies(component.testerDependencies);

  const packageJson = _packageJsonFile().default.createFromComponent(bitDir, component, excludeRegistryPrefix);

  const main = (0, _path().pathNormalizeToLinux)(component.dists.calculateMainDistFile(component.mainFile));
  packageJson.addOrUpdateProperty('main', main);

  const addDependencies = packageJsonFile => {
    packageJsonFile.addDependencies(bitDependencies);
    packageJsonFile.addDevDependencies(_objectSpread({}, bitDevDependencies, {}, bitCompilerDependencies, {}, bitTesterDependencies));
  };

  addDependencies(packageJson);
  let distPackageJson;

  if (!component.dists.isEmpty() && !component.dists.areDistsInsideComponentDir) {
    const distRootDir = component.dists.distsRootDir;
    if (!distRootDir) throw new Error('component.dists.distsRootDir is not defined yet');
    distPackageJson = _packageJsonFile().default.createFromComponent(distRootDir, component, excludeRegistryPrefix);
    const distMainFile = (0, _searchFilesIgnoreExt().default)(component.dists.get(), component.mainFile, 'relative');
    distPackageJson.addOrUpdateProperty('main', component.dists.getMainDistFile() || distMainFile);
    addDependencies(distPackageJson);
  }

  return {
    packageJson,
    distPackageJson
  };
}

function updateAttribute(_x8, _x9, _x10, _x11) {
  return _updateAttribute.apply(this, arguments);
}
/**
 * Adds workspace array to package.json - only if user wants to work with yarn workspaces
 */


function _updateAttribute() {
  _updateAttribute = (0, _bluebird().coroutine)(function* (consumer, componentDir, attributeName, attributeValue) {
    const packageJsonFile = yield _packageJsonFile().default.load(consumer.getPath(), componentDir);
    if (!packageJsonFile.fileExist) return; // package.json doesn't exist, that's fine, no need to update anything

    packageJsonFile.addOrUpdateProperty(attributeName, attributeValue);
    yield packageJsonFile.write();
  });
  return _updateAttribute.apply(this, arguments);
}

function addWorkspacesToPackageJson(_x12, _x13) {
  return _addWorkspacesToPackageJson.apply(this, arguments);
}

function _addWorkspacesToPackageJson() {
  _addWorkspacesToPackageJson = (0, _bluebird().coroutine)(function* (consumer, customImportPath) {
    if (consumer.config.manageWorkspaces && consumer.config.packageManager === 'yarn' && consumer.config.useWorkspaces) {
      const rootDir = consumer.getPath();
      const dependenciesDirectory = consumer.config.dependenciesDirectory;
      const {
        componentsDefaultDirectory
      } = consumer.dirStructure;
      const driver = consumer.driver.getDriver(false); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const PackageJson = driver.PackageJson;
      yield PackageJson.addWorkspacesToPackageJson(rootDir, componentsDefaultDirectory + _constants().SUB_DIRECTORIES_GLOB_PATTERN, dependenciesDirectory + _constants().SUB_DIRECTORIES_GLOB_PATTERN, customImportPath ? consumer.getPathRelativeToConsumer(customImportPath) : customImportPath);
    }
  });
  return _addWorkspacesToPackageJson.apply(this, arguments);
}

function removeComponentsFromWorkspacesAndDependencies(_x14, _x15) {
  return _removeComponentsFromWorkspacesAndDependencies.apply(this, arguments);
}

function _removeComponentsFromWorkspacesAndDependencies() {
  _removeComponentsFromWorkspacesAndDependencies = (0, _bluebird().coroutine)(function* (consumer, componentIds) {
    const rootDir = consumer.getPath();
    const driver = consumer.driver.getDriver(false); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    const PackageJson = driver.PackageJson;

    if (consumer.config.manageWorkspaces && consumer.config.packageManager === 'yarn' && consumer.config.useWorkspaces) {
      const dirsToRemove = componentIds.map(id => consumer.bitMap.getComponent(id, {
        ignoreVersion: true
      }).rootDir);
      yield PackageJson.removeComponentsFromWorkspaces(rootDir, dirsToRemove);
    }

    yield PackageJson.removeComponentsFromDependencies(rootDir, // @todo: fix. the registryPrefix should be retrieved from the component.
    consumer.config.bindingPrefix || (0, _npmRegistryName().default)(), componentIds.map(id => id.toStringWithoutVersion()));
    yield removeComponentsFromNodeModules(consumer, componentIds);
  });
  return _removeComponentsFromWorkspacesAndDependencies.apply(this, arguments);
}

function _addDependenciesPackagesIntoPackageJson(_x16, _x17) {
  return _addDependenciesPackagesIntoPackageJson2.apply(this, arguments);
}

function _addDependenciesPackagesIntoPackageJson2() {
  _addDependenciesPackagesIntoPackageJson2 = (0, _bluebird().coroutine)(function* (dir, dependencies) {
    const packageJsonFile = yield _packageJsonFile().default.load(dir);
    packageJsonFile.addDependencies(dependencies);
    yield packageJsonFile.write();
  });
  return _addDependenciesPackagesIntoPackageJson2.apply(this, arguments);
}

function removeComponentsFromNodeModules(_x18, _x19) {
  return _removeComponentsFromNodeModules.apply(this, arguments);
}

function _removeComponentsFromNodeModules() {
  _removeComponentsFromNodeModules = (0, _bluebird().coroutine)(function* (consumer, componentIds) {
    _logger().default.debug(`removeComponentsFromNodeModules: ${componentIds.map(c => c.toString()).join(', ')}`); // @todo: fix. the registryPrefix should be retrieved from the component.


    const registryPrefix = consumer.config.bindingPrefix || (0, _npmRegistryName().default)(); // paths without scope name, don't have a symlink in node-modules

    const pathsToRemove = componentIds.map(id => {
      return id.scope ? (0, _componentNodeModulesPath().default)(registryPrefix, id) : null;
    }).filter(a => a); // remove null

    _logger().default.debug(`deleting the following paths: ${pathsToRemove.join('\n')}`); // $FlowFixMe nulls were removed in the previous filter function
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


    return Promise.all(pathsToRemove.map(componentPath => _fsExtra().default.remove(consumer.toAbsolutePath(componentPath))));
  });
  return _removeComponentsFromNodeModules.apply(this, arguments);
}

function convertToValidPathForPackageManager(pathStr) {
  const prefix = 'file:'; // it works for both, Yarn and NPM

  return prefix + (pathStr.startsWith('.') ? pathStr : `./${pathStr}`);
}
/**
 * Only imported components should be saved with relative path in package.json
 * If a component is nested or imported as a package dependency, it should be saved with the version
 * If a component is authored, no need to save it as a dependency of the imported component because
 * the root package.json takes care of it already.
 */


function getPackageDependencyValue(dependencyId, parentComponentMap, dependencyComponentMap) {
  if (!dependencyComponentMap || dependencyComponentMap.origin === _constants().COMPONENT_ORIGINS.NESTED) {
    return dependencyId.version;
  }

  if (dependencyComponentMap.origin === _constants().COMPONENT_ORIGINS.AUTHORED) {
    return null;
  }

  const dependencyRootDir = dependencyComponentMap.rootDir;

  if (!dependencyRootDir) {
    throw new Error(`rootDir is missing from an imported component ${dependencyId.toString()}`);
  }

  if (!parentComponentMap.rootDir) throw new Error('rootDir is missing from an imported component');
  const rootDirRelative = (0, _utils().pathRelativeLinux)(parentComponentMap.rootDir, dependencyRootDir);
  return convertToValidPathForPackageManager(rootDirRelative);
}

function getPackageDependency(bitMap, dependencyId, parentId) {
  const parentComponentMap = bitMap.getComponent(parentId);
  const dependencyComponentMap = bitMap.getComponentIfExist(dependencyId);
  return getPackageDependencyValue(dependencyId, parentComponentMap, dependencyComponentMap);
}