"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _command() {
  const data = _interopRequireDefault(require("../../command"));

  _command = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _scope() {
  const data = require("../../../api/scope");

  _scope = function () {
    return data;
  };

  return data;
}

function _chalkBox() {
  const data = require("../../chalk-box");

  _chalkBox = function () {
    return data;
  };

  return data;
}

class CiUpdate extends _command().default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2().default)(this, "name", 'ci-update <id> [scopePath]');
    (0, _defineProperty2().default)(this, "description", 'run an update for build and test of a certain bit-component');
    (0, _defineProperty2().default)(this, "alias", '');
    (0, _defineProperty2().default)(this, "opts", [// ['v', 'verbose [boolean]', 'showing npm verbose output for inspection'],
    ['d', 'directory [file]', 'directory to run ci-update'], ['k', 'keep', 'keep test environment after run (default false)'], ['c', 'no-cache', 'ignore component cache when creating dist file'], ['o', 'output [file]', 'save ci results to file system']]);
    (0, _defineProperty2().default)(this, "private", false);
  }

  action([id, scopePath], {
    // verbose = true,
    directory,
    output,
    keep = false,
    noCache = false
  }) {
    const verbose = true; // During ci-update we always want to see verbose outputs

    return (0, _scope().ciUpdateAction)(id, scopePath || process.cwd(), verbose, directory, keep, noCache).then(({
      specsResults,
      dists,
      mainFile
    }) => ({
      specsResults,
      dists,
      mainFile,
      output,
      directory
    }));
  }

  report({
    specsResults,
    dists,
    output,
    directory
  }) {
    if (!specsResults && !dists) {
      return 'no results found';
    }

    if (specsResults instanceof Error) {
      return specsResults.message;
    } // TODO: this is really wierd.. is that possible?
    // TODO: if yes, we should change the flow type above


    if (dists instanceof Error) {
      return dists.message;
    } // check if there is build results


    if (output && dists) {
      const ci = {}; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      ci.specResults = specsResults; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      ci.cwd = directory || process.cwd; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      ci.buildResults = dists;
      (0, _utils().outputJsonFile)(output, ci);
    }

    return (0, _chalkBox().paintCiResults)({
      specsResults,
      dists
    });
  }

}

exports.default = CiUpdate;