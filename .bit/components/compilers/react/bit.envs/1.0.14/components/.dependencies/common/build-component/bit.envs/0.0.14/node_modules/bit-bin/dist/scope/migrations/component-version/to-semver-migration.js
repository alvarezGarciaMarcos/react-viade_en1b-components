"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _semver() {
  const data = _interopRequireDefault(require("semver"));

  _semver = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = _interopRequireDefault(require("../../../bit-id/bit-id"));

  _bitId = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

/**
 * Change the dependencies versions and the compiler / testers ids to semver
 * @param {*} versionModel - The parsed version model
 */
function changeVersionToSemVer(versionModel) {
  const getUpdatedDependency = dependency => {
    // Take care of very old models when the dependencies were strings
    // in this case we will keep it string but change it to contain semver
    // Those old model will still not work after this migration
    if (typeof dependency === 'string') {
      _logger().default.warn("The dependency dependency is stored with an old format, this version won't work properly");

      dependency = {
        id: _getUpdatedId(dependency),
        relativePaths: []
      };
      return dependency;
    }

    dependency.id = _getUpdatedId(dependency.id);
    return dependency;
  }; // Go over the versions array and update them
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  const dependencies = _ramda().default.map(getUpdatedDependency, versionModel.dependencies); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  const flattenedDependencies = _ramda().default.map(_getUpdatedId, versionModel.flattenedDependencies); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  versionModel.dependencies = dependencies; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  versionModel.flattenedDependencies = flattenedDependencies; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

  if (versionModel.tester) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    versionModel.tester = _getUpdatedId(versionModel.tester);
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  if (versionModel.compiler) {
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
    versionModel.compiler = _getUpdatedId(versionModel.compiler);
  }

  return versionModel;
}

function _getUpdatedId(id) {
  try {
    // Fix also old version seperator (::)
    if (id.includes('::')) {
      id = id.replace('::', _constants().VERSION_DELIMITER);
    }

    const parsedId = _bitId().default.parseBackwardCompatible(id); // Don't convert latest word


    if (parsedId.getVersion().latest) {
      return id;
    }

    let version = parsedId.getVersion().versionNum; // In case there is already a semver, do nothing

    if (!_semver().default.valid(version)) {
      version = `0.0.${version}`;
    }

    const newId = `${parsedId.toStringWithoutVersion()}${_constants().VERSION_DELIMITER}${version}`;
    return newId;
  } catch (err) {
    _logger().default.error(`couldn't parse the id ${id} in order to migrate it to semver`);

    throw err;
  }
}

const changeVersionToSemVerDeclartaion = {
  name: "change version's (deps & compiler / tester) to SemVer",
  migrate: changeVersionToSemVer
};
var _default = changeVersionToSemVerDeclartaion;
exports.default = _default;