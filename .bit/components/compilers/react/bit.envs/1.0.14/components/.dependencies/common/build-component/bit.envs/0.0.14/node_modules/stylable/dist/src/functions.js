"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var postcss = require("postcss");
var native_reserved_lists_1 = require("./native-reserved-lists");
var stylable_value_parsers_1 = require("./stylable-value-parsers");
var utils_1 = require("./utils");
var valueParser = require('postcss-value-parser');
/* tslint:disable:max-line-length */
var errors = {
    FAIL_TO_EXECUTE_FORMATTER: function (resolvedValue, message) { return "failed to execute formatter \"" + resolvedValue + "\" with error: \"" + message + "\""; },
    CYCLIC_VALUE: function (cyclicChain) { return "Cyclic value definition detected: \"" + cyclicChain.map(function (s, i) { return (i === cyclicChain.length - 1 ? '↻ ' : i === 0 ? '→ ' : '↪ ') + s; }).join('\n') + "\""; },
    CANNOT_USE_AS_VALUE: function (type, varName) { return type + " \"" + varName + "\" cannot be used as a variable"; },
    CANNOT_USE_JS_AS_VALUE: function (varName) { return "JavaScript import \"" + varName + "\" cannot be used as a variable"; },
    CANNOT_FIND_IMPORTED_VAR: function (varName, path) { return "cannot find export '" + varName + "' in '" + path + "'"; },
    MULTI_ARGS_IN_VALUE: function (args) { return "value function accepts only a single argument: \"value(" + args + ")\""; },
    UNKNOWN_FORMATTER: function (name) { return "cannot find formatter: " + name; },
    UNKNOWN_VAR: function (name) { return "unknown var \"" + name + "\""; }
};
/* tslint:enable:max-line-length */
function resolveArgumentsValue(options, transformer, meta, variableOverride, path) {
    var resolvedArgs = {};
    for (var k in options) {
        resolvedArgs[k] = evalDeclarationValue(transformer.resolver, options[k], meta, postcss.decl(), variableOverride, transformer.replaceValueHook, undefined, path);
    }
    return resolvedArgs;
}
exports.resolveArgumentsValue = resolveArgumentsValue;
function evalDeclarationValue(resolver, value, meta, node, variableOverride, valueHook, diagnostics, passedThrough) {
    if (passedThrough === void 0) { passedThrough = []; }
    var parsedValue = valueParser(value);
    parsedValue.walk(function (parsedNode) {
        var type = parsedNode.type, value = parsedNode.value;
        switch (type) {
            case 'function':
                if (value === 'value') {
                    var args = parsedNode.nodes.map(function (n) { return valueParser.stringify(n); });
                    if (args.length === 1) {
                        var varName = args[0];
                        if (variableOverride && variableOverride[varName]) {
                            return parsedNode.resolvedValue = variableOverride[varName];
                        }
                        var refUniqID = createUniqID(meta.source, varName);
                        if (passedThrough.indexOf(refUniqID) !== -1) {
                            // TODO: move diagnostic to original value usage instead of the end of the cyclic chain
                            var cyclicChain = passedThrough.map(function (variable) { return variable || ''; });
                            cyclicChain.push(refUniqID);
                            if (diagnostics) {
                                diagnostics.warn(node, errors.CYCLIC_VALUE(cyclicChain), { word: refUniqID });
                            }
                            return stringifyFunction(value, parsedNode);
                        }
                        var varSymbol = meta.mappedSymbols[varName];
                        if (varSymbol && varSymbol._kind === 'var') {
                            var resolvedValue = evalDeclarationValue(resolver, utils_1.stripQuotation(varSymbol.text), meta, varSymbol.node, variableOverride, valueHook, diagnostics, passedThrough.concat(createUniqID(meta.source, varName)));
                            parsedNode.resolvedValue = valueHook ?
                                valueHook(resolvedValue, varName, true, passedThrough) :
                                resolvedValue;
                        }
                        else if (varSymbol && varSymbol._kind === 'import') {
                            var resolvedVar = resolver.deepResolve(varSymbol);
                            if (resolvedVar && resolvedVar.symbol) {
                                var resolvedVarSymbol = resolvedVar.symbol;
                                if (resolvedVar._kind === 'css') {
                                    if (resolvedVarSymbol._kind === 'var') {
                                        var resolvedValue = evalDeclarationValue(resolver, utils_1.stripQuotation(resolvedVarSymbol.text), resolvedVar.meta, resolvedVarSymbol.node, variableOverride, valueHook, diagnostics, passedThrough.concat(createUniqID(meta.source, varName)));
                                        parsedNode.resolvedValue = valueHook ?
                                            valueHook(resolvedValue, varName, false, passedThrough) :
                                            resolvedValue;
                                    }
                                    else {
                                        var errorKind = (resolvedVarSymbol._kind === 'class'
                                            &&
                                                resolvedVarSymbol[stylable_value_parsers_1.valueMapping.root]) ?
                                            'stylesheet' : resolvedVarSymbol._kind;
                                        if (diagnostics) {
                                            diagnostics.warn(node, errors.CANNOT_USE_AS_VALUE(errorKind, varName), { word: varName });
                                        }
                                    }
                                }
                                else if (resolvedVar._kind === 'js' && diagnostics) {
                                    // ToDo: provide actual exported id (default/named as x)
                                    diagnostics.warn(node, errors.CANNOT_USE_JS_AS_VALUE(varName), { word: varName });
                                }
                            }
                            else {
                                // TODO: move this to a seperate mechanism to check imports unrelated to usage
                                var namedDecl = varSymbol.import.rule.nodes.find(function (node) {
                                    return node.type === 'decl' && node.prop === stylable_value_parsers_1.valueMapping.named;
                                });
                                if (namedDecl && diagnostics) {
                                    // ToDo: provide actual exported id (default/named as x)
                                    diagnostics.error(namedDecl, errors.CANNOT_FIND_IMPORTED_VAR(varName, varSymbol.import.fromRelative), { word: varName });
                                }
                            }
                        }
                        else if (diagnostics) {
                            diagnostics.warn(node, errors.UNKNOWN_VAR(varName), { word: varName });
                        }
                    }
                    else if (diagnostics) {
                        var argsAsString = args.filter(function (arg) { return arg !== ', '; }).join(', ');
                        diagnostics.warn(node, errors.MULTI_ARGS_IN_VALUE(argsAsString), { word: argsAsString });
                    }
                }
                else if (value === 'url') {
                    // postcss-value-parser treats url differently:
                    // https://github.com/TrySound/postcss-value-parser/issues/34
                }
                else {
                    var formatterRef = meta.mappedSymbols[value];
                    var formatter = resolver.deepResolve(formatterRef);
                    var args = getFormatterArgs(parsedNode);
                    if (formatter && formatter._kind === 'js') {
                        // TODO: Add try/catch, pipe error
                        try {
                            parsedNode.resolvedValue = formatter.symbol.apply(null, args);
                            if (valueHook) {
                                parsedNode.resolvedValue = valueHook(parsedNode.resolvedValue, { name: parsedNode.value, args: args }, true, passedThrough);
                            }
                        }
                        catch (error) {
                            // todo: issue diagnostic
                            parsedNode.resolvedValue = stringifyFunction(value, parsedNode);
                            if (diagnostics) {
                                diagnostics.warn(node, errors.FAIL_TO_EXECUTE_FORMATTER(parsedNode.resolvedValue, error.message), { word: node.value });
                            }
                        }
                    }
                    else if (native_reserved_lists_1.isCssNativeFunction(value)) {
                        parsedNode.resolvedValue = stringifyFunction(value, parsedNode);
                    }
                    else if (diagnostics) {
                        diagnostics.warn(node, errors.UNKNOWN_FORMATTER(value), { word: value });
                    }
                }
                break;
            default: {
                return valueParser.stringify(parsedNode);
            }
        }
    }, true);
    // TODO: handle calc (parse internals but maintain expression)
    // TODO: check this thing. native function that accent our function dose not work
    // e.g: calc(getVarName())
    return valueParser.stringify(parsedValue.nodes, function (node) {
        if (node.resolvedValue !== undefined) {
            return node.resolvedValue;
        }
        else {
            // TODO: warn
            return undefined;
        }
    });
}
exports.evalDeclarationValue = evalDeclarationValue;
function getFormatterArgs(node) {
    // TODO: revisit arguments split!!! e.g: , ro SPACE
    var argsResult = [];
    var currentArg = '';
    for (var _i = 0, _a = node.nodes; _i < _a.length; _i++) {
        var currentNode = _a[_i];
        if (currentNode.type === 'div' && currentNode.value === ',') {
            argsResult.push(currentArg.trim());
            currentArg = '';
        }
        else if (currentNode.type !== 'comment') {
            currentArg += (currentNode.resolvedValue || valueParser.stringify(currentNode));
        }
    }
    if (currentArg) {
        argsResult.push(currentArg.trim());
    }
    return argsResult;
}
function stringifyFunction(name, parsedNode) {
    return name + "(" + getFormatterArgs(parsedNode).join(', ') + ")";
}
function createUniqID(source, varName) {
    return source + ": " + varName;
}
//# sourceMappingURL=functions.js.map