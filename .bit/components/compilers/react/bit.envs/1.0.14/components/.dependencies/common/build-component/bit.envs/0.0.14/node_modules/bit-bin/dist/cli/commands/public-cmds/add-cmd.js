"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _command() {
  const data = _interopRequireDefault(require("../../command"));

  _command = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../api/consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _addTestsWithoutId() {
  const data = _interopRequireDefault(require("../exceptions/add-tests-without-id"));

  _addTestsWithoutId = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

class Add extends _command().default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2().default)(this, "name", 'add [path...]');
    (0, _defineProperty2().default)(this, "description", `add any subset of files to be tracked as a component(s)
  all flags support glob patterns and {PARENT} {FILE_NAME} annotations 
  https://${_constants().BASE_DOCS_DOMAIN}/docs/add-and-isolate-components`);
    (0, _defineProperty2().default)(this, "alias", 'a');
    (0, _defineProperty2().default)(this, "opts", [['i', 'id <name>', 'manually set component id'], ['m', 'main <file>', 'define entry point for the components'], ['t', 'tests <file>/"<file>,<file>"', 'specify test files to track. use quotation marks to list files or use a glob pattern'], ['n', 'namespace <namespace>', 'orginize component in a namespace'], ['e', 'exclude <file>/"<file>,<file>"', 'exclude file from being tracked. use quotation marks to list files or use a glob pattern'], ['o', 'override <boolean>', 'override existing component if exists (default = false)']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "migration", true);
  }

  action([paths], {
    id,
    main,
    tests,
    namespace,
    exclude,
    override = false
  }) {
    if (namespace && id) {
      throw new (_generalError().default)('please use either [id] or [namespace] to add a particular component');
    }

    const normalizedPaths = paths.map(p => path().normalize(p));
    const testsArray = tests ? this.splitList(tests).map(filePath => path().normalize(filePath.trim())) : [];
    const excludedFiles = exclude ? this.splitList(exclude).map(filePath => path().normalize(filePath.trim())) : []; // check if user is trying to add test files only without id

    if (!_ramda().default.isEmpty(tests) && !id && _ramda().default.isEmpty(normalizedPaths)) {
      throw new (_addTestsWithoutId().default)();
    }

    return (0, _consumer().add)({
      componentPaths: normalizedPaths,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      id,
      main: main ? path().normalize(main) : undefined,
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      namespace,
      tests: testsArray,
      exclude: excludedFiles,
      override
    });
  }

  report({
    addedComponents,
    warnings
  }) {
    const paintWarning = () => {
      const alreadyUsedOutput = () => {
        const alreadyUsedWarning = Object.keys(warnings.alreadyUsed).map(key => _chalk().default.yellow(`warning: files ${_chalk().default.bold(warnings.alreadyUsed[key].join(', '))} already used by component: ${key}`)).filter(x => x).join('\n');
        return _ramda().default.isEmpty(alreadyUsedWarning) ? '' : `${alreadyUsedWarning}\n`;
      };

      const emptyDirectoryOutput = () => {
        if (!warnings.emptyDirectory.length) return '';
        return _chalk().default.yellow(`warning: the following directories are empty or all their files were excluded\n${_chalk().default.bold(warnings.emptyDirectory.join('\n'))}\n`);
      };

      return alreadyUsedOutput() + emptyDirectoryOutput();
    };

    if (addedComponents.length > 1) {
      return paintWarning() + _chalk().default.green(`tracking ${addedComponents.length} new components`);
    }

    return paintWarning() + _ramda().default.flatten(addedComponents.map(result => {
      if (result.files.length === 0) {
        return _chalk().default.underline.red(`could not track component ${_chalk().default.bold(result.id)}: no files to track`);
      }

      const title = _chalk().default.underline(`tracking component ${_chalk().default.bold(result.id)}:\n`);

      const files = result.files.map(file => _chalk().default.green(`added ${file.relativePath}`));
      return title + files.join('\n');
    })).join('\n\n');
  }

}

exports.default = Add;