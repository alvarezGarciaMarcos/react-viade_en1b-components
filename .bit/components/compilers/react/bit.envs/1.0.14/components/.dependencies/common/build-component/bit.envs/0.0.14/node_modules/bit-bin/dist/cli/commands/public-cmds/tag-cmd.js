"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.AUTO_TAGGED_MSG = exports.NOTHING_TO_TAG_MSG = void 0;

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _chalk() {
  const data = _interopRequireDefault(require("chalk"));

  _chalk = function () {
    return data;
  };

  return data;
}

function _command() {
  const data = _interopRequireDefault(require("../../command"));

  _command = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../api/consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("../../../utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { (0, _defineProperty2().default)(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

const NOTHING_TO_TAG_MSG = 'nothing to tag';
exports.NOTHING_TO_TAG_MSG = NOTHING_TO_TAG_MSG;
const AUTO_TAGGED_MSG = 'auto-tagged dependents';
exports.AUTO_TAGGED_MSG = AUTO_TAGGED_MSG;

class Tag extends _command().default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2().default)(this, "name", 'tag [id] [version]');
    (0, _defineProperty2().default)(this, "description", `record component changes and lock versions.
  https://${_constants().BASE_DOCS_DOMAIN}/docs/tag-component-version
  ${(0, _constants().WILDCARD_HELP)('tag')}`);
    (0, _defineProperty2().default)(this, "alias", 't');
    (0, _defineProperty2().default)(this, "opts", [['m', 'message <message>', 'log message describing the user changes'], ['a', 'all [version]', 'tag all new and modified components'], ['s', 'scope <version>', 'tag all components of the current scope'], ['p', 'patch', 'increment the patch version number'], ['mi', 'minor', 'increment the minor version number'], ['ma', 'major', 'increment the major version number'], ['f', 'force', 'force-tag even if tests are failing and even when component has not changed'], ['v', 'verbose', 'show specs output on failure'], ['', 'ignore-missing-dependencies', 'DEPRECATED. use --ignore-unresolved-dependencies instead'], ['i', 'ignore-unresolved-dependencies', 'ignore missing dependencies (default = false)'], ['I', 'ignore-newest-version', 'ignore existing of newer versions (default = false)'], ['', 'skip-tests', 'skip running component tests during tag process'], ['', 'skip-auto-tag', 'EXPERIMENTAL. skip auto tagging dependents']]);
    (0, _defineProperty2().default)(this, "loader", true);
    (0, _defineProperty2().default)(this, "migration", true);
    (0, _defineProperty2().default)(this, "remoteOp", true);
  }

  // In case a compiler / tester is not installed
  action([id, version], {
    message = '',
    all,
    patch,
    minor,
    major,
    force,
    verbose,
    ignoreMissingDependencies = false,
    ignoreUnresolvedDependencies = false,
    ignoreNewestVersion = false,
    skipTests = false,
    skipAutoTag = false,
    scope
  }) {
    function getVersion() {
      if (scope) return scope;
      if (all && (0, _utils().isString)(all)) return all;
      return version;
    }

    if (!id && !all && !scope) {
      throw new (_generalError().default)('missing [id]. to tag all components, please use --all flag');
    }

    if (id && all) {
      throw new (_generalError().default)('you can use either a specific component [id] to tag a particular component or --all flag to tag them all');
    }

    const releaseFlags = [patch, minor, major].filter(x => x);

    if (releaseFlags.length > 1) {
      throw new (_generalError().default)('you can use only one of the following - patch, minor, major');
    }

    let releaseType = _constants().DEFAULT_BIT_RELEASE_TYPE;

    const includeImported = scope && all;
    if (major) releaseType = 'major';else if (minor) releaseType = 'minor';else if (patch) releaseType = 'patch';
    if (ignoreMissingDependencies) ignoreUnresolvedDependencies = true;
    const idHasWildcard = (0, _hasWildcard().default)(id);
    const params = {
      message,
      exactVersion: getVersion(),
      releaseType,
      force,
      verbose,
      ignoreUnresolvedDependencies,
      ignoreNewestVersion,
      skipTests,
      skipAutoTag
    };

    if (all || scope || idHasWildcard) {
      return (0, _consumer().tagAllAction)(_objectSpread({}, params, {
        scope,
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        includeImported,
        idWithWildcard: id
      }));
    }

    return (0, _consumer().tagAction)(_objectSpread({}, params, {
      id
    }));
  }

  report(results) {
    if (!results) return _chalk().default.yellow(NOTHING_TO_TAG_MSG);
    const {
      taggedComponents,
      autoTaggedResults,
      warnings,
      newComponents
    } = results;
    const changedComponents = taggedComponents.filter(component => !newComponents.searchWithoutVersion(component.id));
    const addedComponents = taggedComponents.filter(component => newComponents.searchWithoutVersion(component.id));
    const autoTaggedCount = autoTaggedResults ? autoTaggedResults.length : 0;
    const warningsOutput = warnings && warnings.length ? `${_chalk().default.yellow(warnings.join('\n'))}\n\n` : '';
    const tagExplanation = `\n(use "bit export [collection]" to push these components to a remote")
(use "bit untag" to unstage versions)\n`;

    const outputComponents = comps => {
      return comps.map(component => {
        let componentOutput = `     > ${component.id.toString()}`;
        const autoTag = autoTaggedResults.filter(result => result.triggeredBy.searchWithoutScopeAndVersion(component.id));

        if (autoTag.length) {
          const autoTagComp = autoTag.map(a => a.component.toBitIdWithLatestVersion().toString());
          componentOutput += `\n       ${AUTO_TAGGED_MSG}: ${autoTagComp.join(', ')}`;
        }

        return componentOutput;
      }).join('\n');
    };

    const outputIfExists = (label, explanation, components) => {
      if (!components.length) return '';
      return `\n${_chalk().default.underline(label)}\n(${explanation})\n${outputComponents(components)}\n`;
    };

    return warningsOutput + _chalk().default.green(`${taggedComponents.length + autoTaggedCount} component(s) tagged`) + tagExplanation + outputIfExists('new components', 'first version for components', addedComponents) + outputIfExists('changed components', 'components that got a version bump', changedComponents);
  }

}

exports.default = Tag;