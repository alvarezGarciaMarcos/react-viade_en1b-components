"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

function _assert() {
  const data = _interopRequireDefault(require("assert"));

  _assert = function () {
    return data;
  };

  return data;
}

function _sinon() {
  const data = _interopRequireDefault(require("sinon"));

  _sinon = function () {
    return data;
  };

  return data;
}

function _mockFs() {
  const data = _interopRequireDefault(require("mock-fs"));

  _mockFs = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _rewire() {
  const data = _interopRequireDefault(require("rewire"));

  _rewire = function () {
    return data;
  };

  return data;
}

const expect = require('chai').expect;

const precinct = require('../precinct');

const Config = require('./Config'); // needed for the lazy loading.


require('module-definition');

require('detective-stylus');

require('../../constants');

require('../../utils');

require('../../utils/is-relative-import');

require('../../dependency-builder/detectives/detective-css-and-preprocessors');

require('../../dependency-builder/detectives/detective-typescript');

require('../../dependency-builder/detectives/parser-helper');

const dependencyTree = (0, _rewire().default)('./');

const fixtures = _path().default.resolve(`${__dirname}/../../../fixtures/dependency-tree`);

describe('dependencyTree', function () {
  this.timeout(8000);

  function testTreesForFormat(format, ext = '.js') {
    it('returns an object form of the dependency tree for a file', () => {
      const root = `${fixtures}/${format}`;

      const filename = _path().default.normalize(`${root}/a${ext}`);

      const tree = dependencyTree({
        filename,
        root
      });
      (0, _assert().default)(tree instanceof Object);
      const aSubTree = tree[filename];

      _assert().default.ok(aSubTree instanceof Object);

      const filesInSubTree = Object.keys(aSubTree);

      _assert().default.equal(filesInSubTree.length, 2);
    });
  }

  function mockStylus() {
    (0, _mockFs().default)({
      [`${fixtures}/stylus`]: {
        'a.styl': `
          @import "b"
          @require "c.styl"
        `,
        'b.styl': '@import "c"',
        'c.styl': ''
      }
    });
  }

  function mockSass() {
    (0, _mockFs().default)({
      [`${fixtures}/sass`]: {
        'a.scss': `
          @import "_b";
          @import "_c.scss";
        `,
        '_b.scss': 'body { color: blue; }',
        '_c.scss': 'body { color: pink; }'
      }
    });
  }

  function mockLess() {
    (0, _mockFs().default)({
      [`${fixtures}/less`]: {
        'a.less': `
          @import "b.css";
          @import "c.less";
        `,
        'b.css': 'body { color: blue; }',
        'c.less': 'body { color: pink; }'
      }
    });
  }

  function mockes6() {
    (0, _mockFs().default)({
      [`${fixtures}/es6`]: {
        'a.js': `
          import b from './b';
          import c from './c';
        `,
        'b.js': 'export default () => {};',
        'c.js': 'export default () => {};',
        'jsx.js': "import c from './c';\n export default <jsx />;",
        'foo.jsx': "import React from 'react';\n import b from './b';\n export default <jsx />;",
        'es7.js': "import c from './c';\n export default async function foo() {};"
      }
    });
  }

  function mockTS() {
    (0, _mockFs().default)({
      [`${fixtures}/ts`]: {
        'a.ts': `
          import b from './b';
          import c from './c';
        `,
        'b.ts': 'export default () => {};',
        'c.ts': 'export default () => {};'
      }
    });
  }

  afterEach(() => {
    _mockFs().default.restore();
  });
  it('returns an empty object for a non-existent filename', () => {
    (0, _mockFs().default)({
      imaginary: {}
    });
    const root = `${__dirname}/imaginary`;
    const filename = `${root}/notafile.js`;
    const tree = dependencyTree({
      filename,
      root
    });
    (0, _assert().default)(tree instanceof Object);
    (0, _assert().default)(!Object.keys(tree).length);
  });
  it('handles nested tree structures', () => {
    (0, _mockFs().default)({
      [`${__dirname}/extended`]: {
        'a.js': `var b = require('./b');
                 var c = require('./c');`,
        'b.js': `var d = require('./d');
                 var e = require('./e');`,
        'c.js': `var f = require('./f');
                 var g = require('./g');`,
        'd.js': '',
        'e.js': '',
        'f.js': '',
        'g.js': ''
      }
    });
    const directory = `${__dirname}/extended`;

    const filename = _path().default.normalize(`${directory}/a.js`);

    const tree = dependencyTree({
      filename,
      directory
    });
    (0, _assert().default)(tree[filename] instanceof Object); // b and c

    const subTree = tree[filename];

    _assert().default.equal(subTree.length, 2);

    const bTree = tree[_path().default.normalize(`${directory}/b.js`)];

    const cTree = tree[_path().default.normalize(`${directory}/c.js`)]; // d and e


    _assert().default.equal(bTree.length, 2); // f ang g


    _assert().default.equal(cTree.length, 2);
  });
  it('does not include files that are not real (#13)', () => {
    (0, _mockFs().default)({
      [`${__dirname}/onlyRealDeps`]: {
        'a.js': 'var notReal = require("./notReal");'
      }
    });
    const directory = `${__dirname}/onlyRealDeps`;

    const filename = _path().default.normalize(`${directory}/a.js`);

    const tree = dependencyTree({
      filename,
      directory
    });
    const subTree = tree[filename];

    _assert().default.ok(!Object.keys(subTree).some(dep => dep.indexOf('notReal') !== -1));
  });
  it('does not choke on cyclic dependencies', () => {
    (0, _mockFs().default)({
      [`${__dirname}/cyclic`]: {
        'a.js': 'var b = require("./b");',
        'b.js': 'var a = require("./a");'
      }
    });
    const directory = `${__dirname}/cyclic`;

    const filename = _path().default.normalize(`${directory}/a.js`);

    const spy = _sinon().default.spy(dependencyTree, '_getDependencies');

    const tree = dependencyTree({
      filename,
      directory
    });
    (0, _assert().default)(spy.callCount === 2);
    (0, _assert().default)(Object.keys(tree[filename]).length);

    dependencyTree._getDependencies.restore();
  });
  it('excludes Nodejs core modules by default', () => {
    const directory = `${fixtures}/commonjs`;

    const filename = _path().default.normalize(`${directory}/b.js`);

    const tree = dependencyTree({
      filename,
      directory
    });
    (0, _assert().default)(Object.keys(tree[filename]).length === 0);
    (0, _assert().default)(Object.keys(tree)[0].indexOf('b.js') !== -1);
  });
  it('traverses installed 3rd party node modules', () => {
    const directory = `${fixtures}/onlyRealDeps`;

    const filename = _path().default.normalize(`${directory}/a.js`);

    const tree = dependencyTree({
      filename,
      directory
    });
    const subTree = tree[filename];
    (0, _assert().default)(subTree.includes(require.resolve('debug')));
  });
  it('returns a list of absolutely pathed files', () => {
    const directory = `${fixtures}/commonjs`;
    const filename = `${directory}/b.js`;
    const tree = dependencyTree({
      filename,
      directory
    }); // eslint-disable-next-line

    for (const node in tree.nodes) {
      (0, _assert().default)(node.indexOf(process.cwd()) !== -1);
    }
  });
  describe('when given a detective configuration', () => {
    it('passes it through to precinct', () => {
      const spy = _sinon().default.spy(precinct, 'paperwork');

      const directory = _path().default.normalize(`${fixtures}/onlyRealDeps`);

      const filename = _path().default.normalize(`${directory}/a.js`);

      const detectiveConfig = {
        amd: {
          skipLazyLoaded: true
        }
      };
      dependencyTree({
        filename,
        directory,
        detective: detectiveConfig
      });

      _assert().default.ok(spy.calledWith(filename, detectiveConfig));

      spy.restore();
    });
  });
  describe('when given a list to store non existent partials', () => {
    describe('and the file contains no valid partials', () => {
      it('stores the invalid partials', () => {
        (0, _mockFs().default)({
          [`${__dirname}/onlyRealDeps`]: {
            'a.js': 'var notReal = require("./notReal");'
          }
        });

        const directory = _path().default.normalize(`${__dirname}/onlyRealDeps`);

        const filename = _path().default.normalize(`${directory}/a.js`);

        const nonExistent = [];
        dependencyTree({
          filename,
          directory,
          nonExistent
        });

        _assert().default.equal(Object.keys(nonExistent).length, 1);

        _assert().default.equal(nonExistent[filename][0], './notReal');
      });
    });
    describe('and the file contains all valid partials', () => {
      it('does not store anything', () => {
        (0, _mockFs().default)({
          [`${__dirname}/onlyRealDeps`]: {
            'a.js': 'var b = require("./b");',
            'b.js': 'export default 1;'
          }
        });
        const directory = `${__dirname}/onlyRealDeps`;
        const filename = `${directory}/a.js`;
        const nonExistent = [];
        dependencyTree({
          filename,
          directory,
          nonExistent
        });

        _assert().default.equal(nonExistent.length, 0);
      });
    });
    describe('and the file contains a mix of invalid and valid partials', () => {
      it('stores the invalid ones', () => {
        (0, _mockFs().default)({
          [`${__dirname}/onlyRealDeps`]: {
            'a.js': 'var b = require("./b");',
            'b.js': 'var c = require("./c"); export default 1;',
            'c.js': 'var crap = require("./notRealMan");'
          }
        });

        const directory = _path().default.normalize(`${__dirname}/onlyRealDeps`);

        const filename = _path().default.normalize(`${directory}/a.js`);

        const nonExistent = [];
        dependencyTree({
          filename,
          directory,
          nonExistent
        });

        _assert().default.equal(Object.keys(nonExistent).length, 1);

        _assert().default.equal(nonExistent[_path().default.normalize(`${directory}/c.js`)][0], './notRealMan');
      });
    });
    describe('and there is more than one reference to the invalid partial', () => {
      it('should include the non-existent partial per file', () => {
        (0, _mockFs().default)({
          [`${__dirname}/onlyRealDeps`]: {
            'a.js': 'var b = require("./b");\nvar crap = require("./notRealMan");',
            'b.js': 'var c = require("./c"); export default 1;',
            'c.js': 'var crap = require("./notRealMan");'
          }
        });

        const directory = _path().default.normalize(`${__dirname}/onlyRealDeps`);

        const filename = _path().default.normalize(`${directory}/a.js`);

        const nonExistent = [];
        dependencyTree({
          filename,
          directory,
          nonExistent
        });

        _assert().default.equal(Object.keys(nonExistent).length, 2);

        _assert().default.equal(nonExistent[filename][0], './notRealMan');

        _assert().default.equal(nonExistent[_path().default.normalize(`${directory}/c.js`)][0], './notRealMan');
      });
    });
  });
  describe('throws', () => {
    beforeEach(() => {
      // @ts-ignore
      this._directory = `${fixtures}/commonjs`; // @ts-ignore

      this._revert = dependencyTree.__set__('traverse', () => []);
    });
    afterEach(() => {
      // @ts-ignore
      this._revert();
    });
    it('throws if the filename is missing', () => {
      _assert().default.throws(() => {
        dependencyTree({
          filename: undefined,
          // @ts-ignore
          directory: this._directory
        });
      });
    });
    it('throws if the root is missing', () => {
      _assert().default.throws(() => {
        dependencyTree({
          filename: undefined
        });
      });
    });
    it('throws if a supplied filter is not a function', () => {
      _assert().default.throws(() => {
        const directory = `${fixtures}/onlyRealDeps`;
        const filename = `${directory}/a.js`;
        dependencyTree({
          filename,
          directory,
          filter: 'foobar'
        });
      });
    });
    it('does not throw on the legacy `root` option', () => {
      _assert().default.doesNotThrow(() => {
        const directory = `${fixtures}/onlyRealDeps`;
        const filename = `${directory}/a.js`;
        dependencyTree({
          filename,
          root: directory
        });
      });
    });
  });
  describe('on file error', () => {
    beforeEach(() => {
      // @ts-ignore
      this._directory = `${fixtures}/commonjs`;
    });
    it('does not throw', () => {
      _assert().default.doesNotThrow(() => {
        dependencyTree({
          filename: 'foo',
          // @ts-ignore
          directory: this._directory
        });
      });
    });
    it('returns no dependencies', () => {
      // @ts-ignore
      const tree = dependencyTree({
        filename: 'foo',
        directory: this._directory
      });
      (0, _assert().default)(!tree.length);
    });
  });
  describe('memoization (#2)', () => {
    beforeEach(() => {
      // @ts-ignore
      this._spy = _sinon().default.spy(dependencyTree, '_getDependencies');
    });
    afterEach(() => {
      dependencyTree._getDependencies.restore();
    });
    it('accepts a cache object for memoization (#2)', () => {
      const filename = _path().default.normalize(`${fixtures}/amd/a.js`);

      const directory = _path().default.normalize(`${fixtures}/amd`);

      const cache = {};
      cache[_path().default.normalize(`${fixtures}/amd/b.js`)] = {
        pathMap: {
          dependencies: [_path().default.normalize(`${fixtures}/amd/b.js`), _path().default.normalize(`${fixtures}/amd/c.js`)]
        }
      };
      const tree = dependencyTree({
        filename,
        directory,
        visited: cache
      });

      _assert().default.equal(Object.keys(tree[filename]).length, 2); // @ts-ignore


      (0, _assert().default)(this._spy.neverCalledWith(_path().default.normalize(`${fixtures}/amd/b.js`)));
    });
    it('returns the precomputed list of a cached entry point', () => {
      const filename = `${fixtures}/amd/a.js`;
      const directory = `${fixtures}/amd`;
      const cache = {
        // Shouldn't process the first file's tree
        [filename]: {
          pathMap: {
            dependencies: []
          }
        }
      };
      const tree = dependencyTree({
        filename,
        directory,
        visited: cache
      });
      (0, _assert().default)(!tree.length);
    });
  });
  describe('module formats', () => {
    describe('amd', () => {
      testTreesForFormat('amd');
    });
    describe('commonjs', () => {
      testTreesForFormat('commonjs');
    });
    describe('es6', () => {
      beforeEach(() => {
        // @ts-ignore
        this._directory = _path().default.normalize(`${fixtures}/es6`);
        mockes6();
      });
      testTreesForFormat('es6');
      it('resolves files that have jsx', () => {
        // @ts-ignore
        const filename = _path().default.normalize(`${this._directory}/jsx.js`);

        const tree = dependencyTree({
          filename,
          // @ts-ignore
          directory: this._directory
        }); // @ts-ignore

        _assert().default.ok(tree[filename].includes(_path().default.normalize(`${this._directory}/c.js`)));
      });
      it('resolves files with a jsx extension', () => {
        // @ts-ignore
        const filename = _path().default.normalize(`${this._directory}/foo.jsx`);

        const tree = dependencyTree({
          filename,
          // @ts-ignore
          directory: this._directory
        }); // @ts-ignore

        _assert().default.ok(tree[filename].includes(_path().default.normalize(`${this._directory}/b.js`)));
      });
      it('resolves files that have es7', () => {
        // @ts-ignore
        const filename = _path().default.normalize(`${this._directory}/es7.js`);

        const tree = dependencyTree({
          filename,
          // @ts-ignore
          directory: this._directory
        }); // @ts-ignore

        _assert().default.ok(tree[filename].includes(_path().default.normalize(`${this._directory}/c.js`)));
      });
    });
    describe('sass', () => {
      beforeEach(() => {
        mockSass();
      });
      testTreesForFormat('sass', '.scss');
    });
    describe('stylus', () => {
      beforeEach(() => {
        mockStylus();
      });
      testTreesForFormat('stylus', '.styl');
    });
    describe('less', () => {
      beforeEach(() => {
        mockLess();
      });
      testTreesForFormat('less', '.less');
    });
    describe('typescript', () => {
      beforeEach(() => {
        mockTS();
      });
      testTreesForFormat('ts', '.ts');
    });
  }); // skipping the webpack unit tests for now as it's not easy to wire up all the files together.
  // originally, in dependency-tree, the webpack.config.js is in the same directory of the index.js.
  // doing the same here will be confusing. instead, we have already e2e-tests in bit-bin of custom
  // module resolution, which takes advantage of the webpack config.

  describe.skip('webpack', () => {
    beforeEach(() => {
      // Note: not mocking because webpack's resolver needs a real project with dependencies;
      // otherwise, we'd have to mock a ton of files.
      // @ts-ignore
      this._root = _path().default.join(__dirname, '../'); // @ts-ignore

      this._webpackConfig = `${this._root}/webpack.config.js`; // @ts-ignore

      this._testResolution = name => {
        const results = dependencyTree.toList({
          filename: `${fixtures}/webpack/${name}.js`,
          // @ts-ignore
          directory: this._root,
          // @ts-ignore
          webpackConfig: this._webpackConfig,
          filter: filename => filename.indexOf('filing-cabinet') !== -1
        });

        _assert().default.ok(results.some(filename => filename.indexOf('node_modules/filing-cabinet') !== -1));
      };
    });
    it('resolves aliased modules', () => {
      this.timeout(5000); // @ts-ignore

      this._testResolution('aliased');
    });
    it('resolves unaliased modules', () => {
      this.timeout(5000); // @ts-ignore

      this._testResolution('unaliased');
    });
  });
  describe('requirejs', () => {
    beforeEach(() => {
      (0, _mockFs().default)({
        root: {
          'lodizzle.js': 'define({})',
          'require.config.js': `
            requirejs.config({
              baseUrl: './',
              paths: {
                F: './lodizzle.js'
              }
            });
          `,
          'a.js': `
            define([
              'F'
            ], function(F) {

            });
          `,
          'b.js': `
            define([
              './lodizzle'
            ], function(F) {

            });
          `
        }
      });
    });
    it('resolves aliased modules', () => {
      const tree = dependencyTree({
        filename: 'root/a.js',
        directory: 'root',
        config: 'root/require.config.js'
      });

      const filename = _path().default.resolve(process.cwd(), 'root/a.js');

      (0, _assert().default)(tree[filename].includes(_path().default.normalize('root/lodizzle.js')));
    });
    it('resolves non-aliased paths', () => {
      const tree = dependencyTree({
        filename: 'root/b.js',
        directory: 'root',
        config: 'root/require.config.js'
      });

      const filename = _path().default.resolve(process.cwd(), 'root/b.js');

      _assert().default.ok(tree[filename].includes(_path().default.normalize('root/lodizzle.js')));
    });
  });
  describe('when a filter function is supplied', () => {
    it('uses the filter to determine if a file should be included in the results', () => {
      const directory = _path().default.normalize(`${fixtures}/onlyRealDeps`);

      const filename = _path().default.normalize(`${directory}/a.js`);

      const tree = dependencyTree({
        filename,
        directory,
        // Skip all 3rd party deps
        filter: (filePath, moduleFile) => {
          _assert().default.ok(require.resolve('debug'));

          _assert().default.ok(moduleFile.includes(_path().default.normalize('onlyRealDeps/a.js')));

          return filePath.indexOf('node_modules') === -1;
        }
      });
      const subTree = tree[filename];

      _assert().default.ok(Object.keys(tree).length);

      const has3rdPartyDep = Object.keys(subTree).some(dep => dep === require.resolve('debug'));

      _assert().default.ok(!has3rdPartyDep);
    });
  });
  describe('when given a CJS file with lazy requires', () => {
    beforeEach(() => {
      (0, _mockFs().default)({
        [`${__dirname}/cjs`]: {
          'foo.js': 'module.exports = function(bar = require("./bar")) {};',
          'bar.js': 'module.exports = 1;'
        }
      });
    });
    it('includes the lazy dependency', () => {
      const directory = `${__dirname}/cjs`;

      const filename = _path().default.normalize(`${directory}/foo.js`);

      const tree = dependencyTree({
        filename,
        directory
      });

      _assert().default.ok(tree[filename].includes(_path().default.normalize(`${directory}/bar.js`)));
    });
  });
  describe('when given an es6 file using CJS lazy requires', () => {
    beforeEach(() => {
      (0, _mockFs().default)({
        [`${__dirname}/es6`]: {
          'foo.js': 'export default function(bar = require("./bar")) {};',
          'bar.js': 'export default 1;'
        }
      });
    });
    describe('and mixedImport mode is turned on', () => {
      it('includes the lazy dependency', () => {
        const directory = `${__dirname}/es6`;

        const filename = _path().default.normalize(`${directory}/foo.js`);

        const tree = dependencyTree({
          filename,
          directory,
          detective: {
            es6: {
              mixedImports: true
            }
          }
        });

        _assert().default.ok(tree[filename].includes(_path().default.normalize(`${directory}/bar.js`)));
      });
    });
  });
  describe('when given an es6 file using dynamic imports', () => {
    beforeEach(() => {
      (0, _mockFs().default)({
        [`${__dirname}/es6`]: {
          'foo.js': 'import("./bar");',
          'bar.js': 'export default 1;'
        }
      });
    });
    it('includes the dynamic import', () => {
      const directory = _path().default.normalize(`${__dirname}/es6`);

      const filename = _path().default.normalize(`${directory}/foo.js`);

      const tree = dependencyTree({
        filename,
        directory
      });
      const subTree = tree[filename];

      _assert().default.ok(!(`${directory}/bar.js` in subTree));
    });
  });
  describe('when a dependency of the main file is not supported', () => {
    beforeEach(() => {
      (0, _mockFs().default)({
        [`${__dirname}/baz`]: {
          'foo.js': 'require("./bar.json");',
          'bar.json': '{ "main": "I\'m a simple JSON object" }'
        }
      });
    });
    it('should include it as a dependency and not throw an error', () => {
      const directory = _path().default.normalize(`${__dirname}/baz`);

      const filename = _path().default.normalize(`${directory}/foo.js`);

      const tree = dependencyTree({
        filename,
        directory
      });

      _assert().default.ok(`${directory}/bar.json` in tree);
    });
  }); // nodeModulesConfig is a feature added to dependency-tree and filing-cabinet to support
  // "module" attribute of package.json, see here what this attribute is good for:
  // https://github.com/rollup/rollup/wiki/pkg.module
  // the commit of supporting it in filing-cabinet is here: https://github.com/dependents/node-filing-cabinet/commit/abef861a5a725b29c2342d01de94c6e2dd881aa0

  describe.skip('when given a CJS file with module property in package.json', () => {
    beforeEach(() => {
      (0, _mockFs().default)({
        [`${__dirname}/es6`]: {
          'module.entry.js': 'import * as module from "module.entry"',
          node_modules: {
            'module.entry': {
              'index.main.js': 'module.exports = () => {};',
              'index.module.js': 'module.exports = () => {};',
              'package.json': '{ "main": "index.main.js", "module": "index.module.js" }'
            }
          }
        }
      });
    });
    it('it includes the module entry as dependency', () => {
      const directory = `${__dirname}/es6`;
      const filename = `${directory}/module.entry.js`;
      const tree = dependencyTree({
        filename,
        directory,
        nodeModulesConfig: {
          entry: 'module'
        }
      });
      const subTree = tree[filename];

      _assert().default.ok(`${directory}/node_modules/module.entry/index.module.js` in subTree);
    });
  });
  describe('Config', () => {
    describe('when cloning', () => {
      describe('and a detective config was set', () => {
        it('retains the detective config in the clone', () => {
          const detectiveConfig = {
            es6: {
              mixedImports: true
            }
          };
          const config = new Config({
            detectiveConfig,
            filename: 'foo',
            directory: 'bar'
          });
          const clone = config.clone();

          _assert().default.deepEqual(clone.detectiveConfig, detectiveConfig);
        });
      });
    });
  });
  describe('when a dependency has missing packages and is retrieved from the cache (visited)', () => {
    beforeEach(() => {
      (0, _mockFs().default)({
        [`${__dirname}/baz`]: {
          'foo.js': 'require("non-exist-foo-pkg");',
          'bar.js': 'require("./foo"); require("non-exist-bar-pkg")',
          'baz.js': 'require("./foo"); require("./bar"); require("non-exist-baz-pkg")'
        }
      });
    });
    it('should not override the cache with wrong packages', () => {
      const directory = _path().default.normalize(`${__dirname}/baz`);

      const fooFile = _path().default.normalize(`${directory}/foo.js`);

      const barFile = _path().default.normalize(`${directory}/bar.js`);

      const bazFile = _path().default.normalize(`${directory}/baz.js`);

      const nonExistent = {};
      const config = {
        directory,
        nonExistent,
        visited: {}
      }; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      config.filename = fooFile;
      dependencyTree(config);
      expect(nonExistent[fooFile]).to.deep.equal(['non-exist-foo-pkg']); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      config.filename = barFile;
      dependencyTree(config);
      expect(nonExistent[fooFile]).to.deep.equal(['non-exist-foo-pkg']);
      expect(nonExistent[barFile]).to.deep.equal(['non-exist-bar-pkg']); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      config.filename = bazFile;
      dependencyTree(config);
      expect(nonExistent[fooFile]).to.deep.equal(['non-exist-foo-pkg']);
      expect(nonExistent[barFile]).to.deep.equal(['non-exist-bar-pkg']);
      expect(nonExistent[bazFile]).to.deep.equal(['non-exist-baz-pkg']);
    });
  });
  describe('passing css files and then javascript files', () => {
    beforeEach(() => {
      (0, _mockFs().default)({
        [`${__dirname}/baz`]: {
          'base.scss': 'li {} a {}',
          // don't change the content. it crash only with this for some reason
          'index.jsx': "require('some-module');"
        }
      });
    });
    it('should not crash with "RangeError: Maximum call stack size exceeded" error', () => {
      const directory = _path().default.normalize(`${__dirname}/baz`);

      const baseFile = _path().default.normalize(`${directory}/base.scss`);

      const indexFile = _path().default.normalize(`${directory}/index.jsx`);

      const config = {
        directory
      }; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      config.filename = baseFile;
      dependencyTree(config); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      config.filename = indexFile;
      const dependencies = dependencyTree(config);
      expect(dependencies).to.be.ok;
    });
  });
  describe('files with dynamic import', () => {
    it('should not show missing dependencies', () => {
      (0, _mockFs().default)({
        [`${__dirname}/dynamic`]: {
          'foo.js': 'const a = "./b"; import(a); require(a);'
        }
      });

      const directory = _path().default.normalize(`${__dirname}/dynamic`);

      const filename = _path().default.normalize(`${directory}/foo.js`);

      const visited = {};
      dependencyTree({
        filename,
        directory,
        visited
      });
      expect(visited[filename].missing).to.be.undefined;
    });
  });
  describe('files with import from cdn (http, https)', () => {
    it('should not show missing dependencies when importing from https', () => {
      (0, _mockFs().default)({
        [`${__dirname}/cdn`]: {
          'foo.js': 'import { a } from "https://unpkg.com";'
        }
      });

      const directory = _path().default.normalize(`${__dirname}/cdn`);

      const filename = _path().default.normalize(`${directory}/foo.js`);

      const visited = {};
      dependencyTree({
        filename,
        directory,
        visited
      });
      expect(visited[filename].missing).to.be.undefined;
    });
    it('should not show missing dependencies when importing from http', () => {
      (0, _mockFs().default)({
        [`${__dirname}/cdn`]: {
          'bar.js': 'const b = require("http://pkg.com");'
        }
      });

      const directory = _path().default.normalize(`${__dirname}/cdn`);

      const filename = _path().default.normalize(`${directory}/bar.js`);

      const visited = {};
      dependencyTree({
        filename,
        directory,
        visited
      });
      expect(visited[filename].missing).to.be.undefined;
    });
  });
  describe('resolve config when the dependency is "."', () => {
    it('should not set the dependency with isCustomResolveUsed=true', () => {
      (0, _mockFs().default)({
        [`${__dirname}/src`]: {
          'foo.js': "require('.');",
          'index.js': 'module.exports = {}'
        }
      });

      const directory = _path().default.normalize(`${__dirname}/src`);

      const filename = _path().default.normalize(`${directory}/foo.js`);

      const config = {
        filename,
        directory,
        pathMap: [],
        resolveConfig: {
          aliases: {
            something: 'anything'
          }
        }
      };
      dependencyTree(config); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const pathMapRecord = config.pathMap.find(f => f.file === filename); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      expect(pathMapRecord.dependencies).to.have.lengthOf(1); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const dependency = pathMapRecord.dependencies[0];
      expect(dependency).to.not.have.property('isCustomResolveUsed');
    });
  });
  describe('resolve config when the dependency is ".."', () => {
    it('should not set the dependency with isCustomResolveUsed=true', () => {
      (0, _mockFs().default)({
        [`${__dirname}/src`]: {
          'index.js': 'module.exports = {}',
          bar: {
            'foo.js': "require('..');"
          }
        }
      });

      const directory = _path().default.normalize(`${__dirname}/src`);

      const filename = _path().default.normalize(`${directory}/bar/foo.js`);

      const config = {
        filename,
        directory,
        pathMap: [],
        resolveConfig: {
          aliases: {
            something: 'anything'
          }
        }
      };
      dependencyTree(config); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const pathMapRecord = config.pathMap.find(f => f.file === filename); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      expect(pathMapRecord.dependencies).to.have.lengthOf(1); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const dependency = pathMapRecord.dependencies[0];
      expect(dependency).to.not.have.property('isCustomResolveUsed');
    });
  });
});