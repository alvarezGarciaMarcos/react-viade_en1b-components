"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _utils() {
  const data = require("../../utils");

  _utils = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

class BitRawObject {
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  constructor(buffer, ref, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  types, type, content, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  parsedContent) {
    (0, _defineProperty2().default)(this, "headers", void 0);
    (0, _defineProperty2().default)(this, "type", void 0);
    (0, _defineProperty2().default)(this, "content", void 0);
    (0, _defineProperty2().default)(this, "parsedContent", void 0);
    (0, _defineProperty2().default)(this, "types", void 0);
    (0, _defineProperty2().default)(this, "_ref", void 0);
    let headers;
    let contentFromBuffer;

    if (buffer) {
      const firstNullByteLocation = buffer.indexOf(_constants().NULL_BYTE);
      headers = buffer.slice(0, firstNullByteLocation).toString();
      contentFromBuffer = buffer.slice(firstNullByteLocation + 1, buffer.length);
    }

    this.content = content || contentFromBuffer;
    this.headers = headers ? headers.split(_constants().SPACE_DELIMITER) : undefined;
    const typeFromHeader = this.headers ? this.headers[0] : undefined; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    this.type = type || typeFromHeader; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    this._ref = ref; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    this.types = types;
    this.parsedContent = parsedContent || this.getParsedContent();
  }

  getParsedContent() {
    if (this.parsedContent) return this.parsedContent;
    let parsedContent;

    switch (this.type) {
      case 'Version':
      case 'Component':
      case 'Symlink':
      case 'ScopeMeta':
        parsedContent = JSON.parse(this.content.toString());
        break;

      default:
        parsedContent = this.content;
    }

    return parsedContent;
  }

  getString(pretty) {
    const args = (0, _utils().getStringifyArgs)(pretty);

    switch (this.type) {
      case 'Version':
      case 'Component':
      case 'Symlink':
      case 'ScopeMeta':
        return JSON.stringify(this.parsedContent, ...args);

      default:
        return this.content;
    }
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  set ref(ref) {
    this._ref = ref;
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get ref() {
    return this._ref;
  } // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!


  get id() {
    switch (this.type) {
      case 'Version':
        return 'component version';

      case 'Component':
        return this.parsedContent.scope ? [this.parsedContent.scope, this.parsedContent.name].join('/') : this.parsedContent.name;

      case 'Symlink':
        return this.parsedContent.name;

      case 'ScopeMeta':
        return this.parsedContent.name;

      default:
        return 'component source file';
    }
  }

  refs() {
    if (this.type === 'Component') {
      return _ramda().default.values(this.parsedContent.versions);
    }

    if (this.type === 'Version') {
      const files = this.parsedContent.files ? this.parsedContent.files.map(file => file.file) : [];
      const dists = this.parsedContent.dists ? this.parsedContent.dists.map(dist => dist.file) : [];
      return [...dists, ...files].filter(ref => ref);
    }

    return [];
  }

  static fromDeflatedBuffer(fileContents, ref, // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
  types) {
    return (0, _bluebird().coroutine)(function* () {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      return (0, _utils().inflate)(fileContents).then(buffer => new BitRawObject(buffer, ref, types));
    })();
  }
  /**
   * Build a real object (model) from a parsed content (can be the original parsed conents or a provided one)
   * We use the provided version during the migration process when we change the parsed content outside
   * @param {Any} parsedContent
   */


  toRealObject() {
    // @ts-ignore
    return this.types[this.type].from(this.parsedContent || this.getParsedContent());
  }

  clone() {
    const types = this.types ? _ramda().default.clone(this.types) : undefined;
    const parsedContent = this.parsedContent ? _ramda().default.clone(this.parsedContent) : undefined; // TODO: Should also clone the buffers (content)
    // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return new BitRawObject(undefined, this._ref, types, this.type, this.content, parsedContent);
  }

}

exports.default = BitRawObject;