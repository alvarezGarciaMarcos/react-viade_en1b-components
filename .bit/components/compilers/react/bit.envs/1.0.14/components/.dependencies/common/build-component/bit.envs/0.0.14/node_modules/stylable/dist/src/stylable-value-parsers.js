"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var pseudo_states_1 = require("./pseudo-states");
var selector_utils_1 = require("./selector-utils");
var valueParser = require('postcss-value-parser');
exports.valueMapping = {
    from: '-st-from',
    named: '-st-named',
    default: '-st-default',
    root: '-st-root',
    states: '-st-states',
    extends: '-st-extends',
    mixin: '-st-mixin',
    variant: '-st-variant',
    compose: '-st-compose',
    theme: '-st-theme',
    global: '-st-global'
};
exports.stValues = Object.keys(exports.valueMapping).map(function (key) { return exports.valueMapping[key]; });
exports.stValuesMap = Object.keys(exports.valueMapping).reduce(function (acc, key) {
    acc[exports.valueMapping[key]] = true;
    return acc;
}, {});
exports.STYLABLE_VALUE_MATCHER = /^-st-/;
exports.STYLABLE_NAMED_MATCHER = new RegExp("^" + exports.valueMapping.named + "-(.+)");
exports.SBTypesParsers = {
    '-st-root': function (value) {
        return value === 'false' ? false : true;
    },
    '-st-variant': function (value) {
        return value === 'false' ? false : true;
    },
    '-st-theme': function (value) {
        return value === 'false' ? false : true;
    },
    '-st-global': function (decl, _diagnostics) {
        // Experimental
        var selector = selector_utils_1.parseSelector(decl.value.replace(/^['"]/, '').replace(/['"]$/, ''));
        return selector.nodes[0].nodes;
    },
    '-st-states': function (value, decl, diagnostics) {
        if (!value) {
            return {};
        }
        var mappedStates = {};
        return pseudo_states_1.processPseudoStates(value, decl, diagnostics);
    },
    '-st-extends': function (value) {
        var ast = valueParser(value);
        var types = [];
        ast.walk(function (node) {
            if (node.type === 'function') {
                var args = getNamedArgs(node);
                types.push({
                    symbolName: node.value,
                    args: args
                });
                return false;
            }
            else if (node.type === 'word') {
                types.push({
                    symbolName: node.value,
                    args: null
                });
            }
            return undefined;
        }, false);
        return {
            ast: ast,
            types: types
        };
    },
    '-st-named': function (value) {
        var namedMap = {};
        if (value) {
            value.split(',').forEach(function (name) {
                var parts = name.trim().split(/\s+as\s+/);
                if (parts.length === 1) {
                    namedMap[parts[0]] = parts[0];
                }
                else if (parts.length === 2) {
                    namedMap[parts[1]] = parts[0];
                }
            });
        }
        return namedMap;
    },
    '-st-mixin': function (mixinNode, strategy, diagnostics) {
        var ast = valueParser(mixinNode.value);
        var mixins = [];
        ast.nodes.forEach(function (node) {
            // const symbol = m[node.value];
            // if (symbol.)
            var strat = strategy(node.value);
            if (node.type === 'function') {
                mixins.push({
                    type: node.value,
                    options: strategies[strat](node)
                });
            }
            else if (node.type === 'word') {
                mixins.push({
                    type: node.value,
                    options: strat === 'named' ? {} : []
                });
            }
            else if (node.type === 'string' && diagnostics) {
                diagnostics.error(mixinNode, "value can not be a string (remove quotes?)", { word: mixinNode.value });
            }
        });
        return mixins;
    },
    '-st-compose': function (composeNode, diagnostics) {
        var ast = valueParser(composeNode.value);
        var composes = [];
        ast.walk(function (node) {
            if (node.type === 'function') {
                // TODO
            }
            else if (node.type === 'word') {
                composes.push(node.value);
            }
            else if (node.type === 'string') {
                diagnostics.error(composeNode, "value can not be a string (remove quotes?)", { word: composeNode.value });
            }
        });
        return composes;
    }
};
function getNamedArgs(node) {
    var args = [];
    if (node.nodes.length) {
        args.push([]);
        node.nodes.forEach(function (node) {
            if (node.type === 'div') {
                args.push([]);
            }
            else {
                var sourceIndex = node.sourceIndex, clone = __rest(node, ["sourceIndex"]);
                args[args.length - 1].push(clone);
            }
        });
    }
    return args;
}
function groupValues(nodes, divType) {
    if (divType === void 0) { divType = 'div'; }
    var grouped = [];
    var current = [];
    nodes.forEach(function (n) {
        if (n.type === divType) {
            grouped.push(current);
            current = [];
        }
        else {
            current.push(n);
        }
    });
    var last = grouped[grouped.length - 1];
    if ((last && last !== current && current.length) || !last && current.length) {
        grouped.push(current);
    }
    return grouped;
}
exports.groupValues = groupValues;
var strategies = {
    named: function (node) {
        var named = {};
        getNamedArgs(node).forEach(function (_) {
            if (_[1].type !== 'space') {
                // TODO: maybe warn
            }
            named[_[0].value] = stringifyParam(_.slice(2));
        });
        return named;
    },
    args: function (node) {
        return groupValues(node.nodes, 'div').map(function (nodes) { return valueParser.stringify(nodes, function (n) {
            if (n.type === 'div') {
                return null;
            }
            else if (n.type === 'string') {
                return n.value;
            }
            else {
                return undefined;
            }
        }); }).filter(function (x) { return typeof x === 'string'; }).map(function (value) { return ({ value: value }); });
    }
};
function stringifyParam(nodes) {
    return valueParser.stringify(nodes, function (n) {
        if (n.type === 'div') {
            return null;
        }
        else if (n.type === 'string') {
            return n.value;
        }
        else {
            return undefined;
        }
    });
}
function listOptions(node) {
    return groupValues(node.nodes).map(function (nodes) { return valueParser.stringify(nodes, function (n) {
        if (n.type === 'div') {
            return null;
        }
        else if (n.type === 'string') {
            return n.value;
        }
        else {
            return undefined;
        }
    }); }).filter(function (x) { return typeof x === 'string'; });
}
exports.listOptions = listOptions;
//# sourceMappingURL=stylable-value-parsers.js.map