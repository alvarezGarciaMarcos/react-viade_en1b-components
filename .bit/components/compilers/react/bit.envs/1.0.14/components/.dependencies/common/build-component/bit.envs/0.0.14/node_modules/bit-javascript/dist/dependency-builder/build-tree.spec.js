"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _path() {
  const data = _interopRequireDefault(require("path"));

  _path = function () {
    return data;
  };

  return data;
}

function _chai() {
  const data = require("chai");

  _chai = function () {
    return data;
  };

  return data;
}

function buildTree() {
  const data = _interopRequireWildcard(require("./build-tree"));

  buildTree = function () {
    return data;
  };

  return data;
}

const fixtures = `${__dirname}/../../fixtures`;

const precinctFixtures = _path().default.join(fixtures, 'precinct');

const buildTreeFixtures = _path().default.join(fixtures, 'build-tree');

describe('buildTree', () => {
  describe('getDependencyTree', () => {
    const dependencyTreeParams = {
      baseDir: '.',
      consumerPath: __dirname,
      filePaths: [],
      bindingPrefix: '@bit',
      resolveModulesConfig: undefined
    };
    it('when no files are passed should return an empty tree',
    /*#__PURE__*/
    (0, _bluebird().coroutine)(function* () {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      const results = yield buildTree().getDependencyTree(dependencyTreeParams);
      (0, _chai().expect)(results).to.deep.equal({
        tree: {}
      });
    }));
    it('when unsupported files are passed should return them with no dependencies',
    /*#__PURE__*/
    (0, _bluebird().coroutine)(function* () {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      dependencyTreeParams.filePaths = [`${fixtures}/unsupported-file.pdf`]; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const results = yield buildTree().getDependencyTree(dependencyTreeParams);
      (0, _chai().expect)(results.tree).to.deep.equal({
        'fixtures/unsupported-file.pdf': {}
      });
    }));
    it('when supported and unsupported files are passed should return them all',
    /*#__PURE__*/
    (0, _bluebird().coroutine)(function* () {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      dependencyTreeParams.filePaths = [`${fixtures}/unsupported-file.pdf`, `${precinctFixtures}/es6.js`]; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const results = yield buildTree().getDependencyTree(dependencyTreeParams);
      (0, _chai().expect)(results.tree).to.have.property('fixtures/unsupported-file.pdf');
      (0, _chai().expect)(results.tree).to.have.property('fixtures/precinct/es6.js');
    }));
    it('when a js file has parsing error it should add the file to the tree with the error instance',
    /*#__PURE__*/
    (0, _bluebird().coroutine)(function* () {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      dependencyTreeParams.filePaths = [`${precinctFixtures}/unparseable.js`]; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const results = yield buildTree().getDependencyTree(dependencyTreeParams);
      const unParsedFile = 'fixtures/precinct/unparseable.js';
      (0, _chai().expect)(results.tree).to.have.property(unParsedFile);
      (0, _chai().expect)(results.tree[unParsedFile]).to.have.property('error');
      (0, _chai().expect)(results.tree[unParsedFile].error).to.be.instanceof(Error);
    }));
    it('when a js file has parsing error and it retrieved from the cache it should add the file to the tree with the error instance',
    /*#__PURE__*/
    (0, _bluebird().coroutine)(function* () {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      dependencyTreeParams.filePaths = [`${precinctFixtures}/unparseable.js`]; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      dependencyTreeParams.visited = {}; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const results = yield buildTree().getDependencyTree(dependencyTreeParams);
      const unParsedFile = 'fixtures/precinct/unparseable.js';
      (0, _chai().expect)(results.tree).to.have.property(unParsedFile);
      (0, _chai().expect)(results.tree[unParsedFile]).to.have.property('error');
      (0, _chai().expect)(results.tree[unParsedFile].error).to.be.instanceof(Error); // second time, this time it fetches from the cache (visited object)
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const resultsCached = yield buildTree().getDependencyTree(dependencyTreeParams);
      (0, _chai().expect)(resultsCached.tree).to.have.property(unParsedFile);
      (0, _chai().expect)(resultsCached.tree[unParsedFile]).to.have.property('error');
      (0, _chai().expect)(resultsCached.tree[unParsedFile].error).to.be.instanceof(Error);
    }));
    it.skip('when a css file has parsing error it should add the file to the tree with the error instance',
    /*#__PURE__*/
    (0, _bluebird().coroutine)(function* () {
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      dependencyTreeParams.filePaths = [`${buildTreeFixtures}/unparsed.css`]; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

      const results = yield buildTree().getDependencyTree(dependencyTreeParams);
      const unParsedFile = 'fixtures/build-tree/unparsed.css';
      (0, _chai().expect)(results.tree).to.have.property(unParsedFile);
      (0, _chai().expect)(results.tree[unParsedFile]).to.have.property('error');
      (0, _chai().expect)(results.tree[unParsedFile].error).to.be.instanceof(Error);
    }));
    describe('when a dependency of dependency has parsing error', () => {
      let results;
      before(
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        dependencyTreeParams.filePaths = [`${buildTreeFixtures}/a.js`, `${buildTreeFixtures}/b.js`]; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        results = yield buildTree().getDependencyTree(dependencyTreeParams);
      }));
      it('should add all the files to the tree',
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        (0, _chai().expect)(results.tree).to.have.property('fixtures/build-tree/a.js');
        (0, _chai().expect)(results.tree).to.have.property('fixtures/build-tree/b.js');
        (0, _chai().expect)(results.tree).to.have.property('fixtures/build-tree/unparsed.js');
      }));
      it('should not add the error to the files without parsing error', () => {
        (0, _chai().expect)(results.tree['fixtures/build-tree/a.js']).to.not.have.property('error');
        (0, _chai().expect)(results.tree['fixtures/build-tree/b.js']).to.not.have.property('error');
      });
      it('should add the parsing error to the un-parsed file', () => {
        (0, _chai().expect)(results.tree['fixtures/build-tree/unparsed.js']).to.have.property('error');
        (0, _chai().expect)(results.tree['fixtures/build-tree/unparsed.js'].error).to.be.instanceof(Error);
      });
    });
    describe('missing dependencies', () => {
      let results;
      const missingDepsFile = 'fixtures/missing-deps.js';
      before(
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        dependencyTreeParams.filePaths = [`${fixtures}/missing-deps.js`]; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        results = yield buildTree().getDependencyTree(dependencyTreeParams);
        (0, _chai().expect)(results.tree).to.have.property(missingDepsFile);
        (0, _chai().expect)(results.tree[missingDepsFile]).to.have.property('missing');
      }));
      it('it should add the missing dependency to the missing section in the tree',
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        (0, _chai().expect)(results.tree[missingDepsFile].missing).to.have.property('files');
        (0, _chai().expect)(results.tree[missingDepsFile].missing.files[0]).to.equal('../non-exist-dep');
      }));
      it('it should add the missing package to the missing section in the tree',
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        (0, _chai().expect)(results.tree[missingDepsFile].missing).to.have.property('packages');
        (0, _chai().expect)(results.tree[missingDepsFile].missing.packages[0]).to.equal('non-exist-package');
      }));
    });
    describe('tree shaking with cycle', () => {
      describe('when a file imports from itself', () => {
        let results;
        before(
        /*#__PURE__*/
        (0, _bluebird().coroutine)(function* () {
          // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
          dependencyTreeParams.filePaths = [`${buildTreeFixtures}/tree-shaking-cycle/self-cycle.js`]; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

          results = yield buildTree().getDependencyTree(dependencyTreeParams);
        }));
        it('should not throw an error and should remove itself from the dependencies files', () => {
          const file = 'fixtures/build-tree/tree-shaking-cycle/self-cycle.js';
          (0, _chai().expect)(results.tree[file].files).to.be.an('array').and.empty;
        });
      });
      describe('cycle with multiple files', () => {
        let results;
        before(
        /*#__PURE__*/
        (0, _bluebird().coroutine)(function* () {
          // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
          dependencyTreeParams.filePaths = [`${buildTreeFixtures}/tree-shaking-cycle/foo.js`]; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

          results = yield buildTree().getDependencyTree(dependencyTreeParams);
        }));
        it('should not recognize the cycle dependencies as link files', () => {
          const file = 'fixtures/build-tree/tree-shaking-cycle/foo.js';
          (0, _chai().expect)(results.tree[file].files).to.be.an('array').and.have.lengthOf(1);
          const indexDep = results.tree[file].files[0];
          (0, _chai().expect)(indexDep.file).to.equal('fixtures/build-tree/tree-shaking-cycle/index.js');
          (0, _chai().expect)(indexDep).to.not.have.property('isLink');
          (0, _chai().expect)(indexDep).to.not.have.property('linkDependencies');
        });
      });
    });
    describe('fileA imports varX from fileB, fileB imports varX from fileC but not export it', () => {
      let results;
      before(
      /*#__PURE__*/
      (0, _bluebird().coroutine)(function* () {
        // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
        dependencyTreeParams.filePaths = [`${buildTreeFixtures}/not-link-file/file-a.js`]; // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        results = yield buildTree().getDependencyTree(dependencyTreeParams);
      }));
      it('should not mark fileB as a link file', () => {
        const fileA = 'fixtures/build-tree/not-link-file/file-a.js';
        (0, _chai().expect)(results.tree[fileA].files).to.be.an('array').with.lengthOf(1);
        const fileBDep = results.tree[fileA].files[0];
        (0, _chai().expect)(fileBDep).to.not.have.property('isLink');
      });
    });
  });
});