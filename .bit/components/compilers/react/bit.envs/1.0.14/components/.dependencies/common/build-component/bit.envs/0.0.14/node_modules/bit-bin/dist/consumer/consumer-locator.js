"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.pathHasBitJson = pathHasBitJson;
exports.pathHasLocalScope = pathHasLocalScope;
exports.getConsumerInfo = getConsumerInfo;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function pathlib() {
  const data = _interopRequireWildcard(require("path"));

  pathlib = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _workspaceConfig() {
  const data = _interopRequireDefault(require("./config/workspace-config"));

  _workspaceConfig = function () {
    return data;
  };

  return data;
}

function _exceptions() {
  const data = require("./config/exceptions");

  _exceptions = function () {
    return data;
  };

  return data;
}

/**
 * @flow
 * @deprecated
 * @TODO deprecated and should be removed from here and use fs-propogate-until instead...
 */
function composeBitHiddenDirPath(path) {
  return pathlib().join(path, _constants().BIT_HIDDEN_DIR);
}

function composeBitGitHiddenDirPath(path) {
  return pathlib().join(path, _constants().DOT_GIT_DIR, _constants().BIT_GIT_DIR);
}

function composeBitJsonPath(path) {
  return pathlib().join(path, _constants().BIT_JSON);
}
/**
 * determine whether given path has a bit.Json
 */


function pathHasBitJson(path) {
  return _fsExtra().default.existsSync(composeBitJsonPath(path));
}
/**
 * determine whether given path has .bit
 */


function pathHasLocalScope(path) {
  return _fsExtra().default.existsSync(composeBitHiddenDirPath(path));
}
/**
 * propagate from the given directory up to the root to find the consumer
 */


function getConsumerInfo(_x) {
  return _getConsumerInfo.apply(this, arguments);
}

function _getConsumerInfo() {
  _getConsumerInfo = (0, _bluebird().coroutine)(function* (absPath) {
    const searchPaths = buildPropagationPaths();
    searchPaths.unshift(absPath);

    for (let i = 0; i < searchPaths.length; i += 1) {
      const path = searchPaths[i];
      const hasScope = yield pathHasScopeDir(path); // eslint-disable-line no-await-in-loop

      const consumerConfig = yield getConsumerConfigIfExists(path); // eslint-disable-line no-await-in-loop

      const hasBitMap = yield pathHasBitMap(path); // eslint-disable-line no-await-in-loop

      const consumerExists = hasScope && consumerConfig || hasBitMap;

      if (consumerExists) {
        return {
          path,
          hasScope,
          consumerConfig,
          hasBitMap
        };
      }
    }

    return null;

    function buildPropagationPaths() {
      const paths = [];
      const pathParts = absPath.split(pathlib().sep);
      pathParts.forEach((val, index) => {
        const part = pathParts.slice(0, index).join('/');
        if (!part) return;
        paths.push(part);
      });
      return paths.reverse();
    }

    function pathHasBitMap(_x2) {
      return _pathHasBitMap.apply(this, arguments);
    }

    function _pathHasBitMap() {
      _pathHasBitMap = (0, _bluebird().coroutine)(function* (path) {
        return (yield _fsExtra().default.pathExists(pathlib().join(path, _constants().BIT_MAP))) || _fsExtra().default.pathExists(pathlib().join(path, _constants().OLD_BIT_MAP));
      });
      return _pathHasBitMap.apply(this, arguments);
    }

    function pathHasScopeDir(_x3) {
      return _pathHasScopeDir.apply(this, arguments);
    }

    function _pathHasScopeDir() {
      _pathHasScopeDir = (0, _bluebird().coroutine)(function* (path) {
        return (yield _fsExtra().default.pathExists(composeBitHiddenDirPath(path))) || _fsExtra().default.pathExists(composeBitGitHiddenDirPath(path));
      });
      return _pathHasScopeDir.apply(this, arguments);
    }

    function getConsumerConfigIfExists(_x4) {
      return _getConsumerConfigIfExists.apply(this, arguments);
    }

    function _getConsumerConfigIfExists() {
      _getConsumerConfigIfExists = (0, _bluebird().coroutine)(function* (path) {
        try {
          return yield _workspaceConfig().default.load(path);
        } catch (err) {
          if (err instanceof _exceptions().BitConfigNotFound) {
            return null;
          }

          throw err;
        }
      });
      return _getConsumerConfigIfExists.apply(this, arguments);
    }
  });
  return _getConsumerInfo.apply(this, arguments);
}