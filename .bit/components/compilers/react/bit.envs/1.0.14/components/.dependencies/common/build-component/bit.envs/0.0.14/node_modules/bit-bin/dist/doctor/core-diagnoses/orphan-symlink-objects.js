"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.DIAGNOSIS_NAME = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _defineProperty2() {
  const data = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

  _defineProperty2 = function () {
    return data;
  };

  return data;
}

function _diagnosis() {
  const data = _interopRequireDefault(require("../diagnosis"));

  _diagnosis = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _models() {
  const data = require("../../scope/models");

  _models = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

const DIAGNOSIS_NAME = 'check orphan refs';
exports.DIAGNOSIS_NAME = DIAGNOSIS_NAME;

class OrphanSymlinkObjects extends _diagnosis().default {
  constructor(...args) {
    super(...args);
    (0, _defineProperty2().default)(this, "name", DIAGNOSIS_NAME);
    (0, _defineProperty2().default)(this, "description", 'checks for empty internal refs in local workspace');
    (0, _defineProperty2().default)(this, "category", 'internal store');
  }

  _formatSymptoms(bareResult) {
    if (!bareResult.data) throw new Error('OrphanSymlinkObjects, bareResult.data is missing'); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return `the following refs points to non-existing components "${bareResult.data.orphanSymlinks.toString()}"`;
  }

  _formatManualTreat(bareResult) {
    if (!bareResult.data) throw new Error('OrphanSymlinkObjects, bareResult.data is missing'); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    return `please delete the following paths:\n${bareResult.data.objectsToDelete.join('\n')}`;
  }

  _runExamine() {
    return (0, _bluebird().coroutine)(function* () {
      const consumer = yield (0, _consumer().loadConsumer)();
      const bitObjects = yield consumer.scope.objects.list();
      const symlinks = bitObjects.filter(object => object instanceof _models().Symlink);
      const orphanSymlinks = new (_bitId().BitIds)();
      const objectsToDelete = [];
      yield Promise.all(symlinks.map(
      /*#__PURE__*/
      function () {
        var _ref = (0, _bluebird().coroutine)(function* (symlink) {
          // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
          const realComponentId = symlink.getRealComponentId();

          const realModelComponent = _models().ModelComponent.fromBitId(realComponentId);

          const foundComponent = yield consumer.scope.objects.load(realModelComponent.hash());

          if (!foundComponent) {
            orphanSymlinks.push(realComponentId); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

            objectsToDelete.push(consumer.scope.objects.objectPath(symlink.hash()));
          }
        });

        return function (_x) {
          return _ref.apply(this, arguments);
        };
      }()));
      return {
        valid: orphanSymlinks.length === 0,
        data: {
          orphanSymlinks,
          objectsToDelete
        }
      };
    })();
  }

}

exports.default = OrphanSymlinkObjects;