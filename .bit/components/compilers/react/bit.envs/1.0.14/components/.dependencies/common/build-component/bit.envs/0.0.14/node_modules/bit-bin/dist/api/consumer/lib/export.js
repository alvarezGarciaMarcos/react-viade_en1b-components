"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

function _bluebird() {
  const data = require("bluebird");

  _bluebird = function () {
    return data;
  };

  return data;
}

function _ramda() {
  const data = _interopRequireDefault(require("ramda"));

  _ramda = function () {
    return data;
  };

  return data;
}

function _yn() {
  const data = _interopRequireDefault(require("yn"));

  _yn = function () {
    return data;
  };

  return data;
}

function _pMapSeries() {
  const data = _interopRequireDefault(require("p-map-series"));

  _pMapSeries = function () {
    return data;
  };

  return data;
}

function path() {
  const data = _interopRequireWildcard(require("path"));

  path = function () {
    return data;
  };

  return data;
}

function _fsExtra() {
  const data = _interopRequireDefault(require("fs-extra"));

  _fsExtra = function () {
    return data;
  };

  return data;
}

function _consumer() {
  const data = require("../../../consumer");

  _consumer = function () {
    return data;
  };

  return data;
}

function _componentsList() {
  const data = _interopRequireDefault(require("../../../consumer/component/components-list"));

  _componentsList = function () {
    return data;
  };

  return data;
}

function _loader() {
  const data = _interopRequireDefault(require("../../../cli/loader"));

  _loader = function () {
    return data;
  };

  return data;
}

function _hooks() {
  const data = _interopRequireDefault(require("../../../hooks"));

  _hooks = function () {
    return data;
  };

  return data;
}

function _loaderMessages() {
  const data = require("../../../cli/loader/loader-messages");

  _loaderMessages = function () {
    return data;
  };

  return data;
}

function _bitId() {
  const data = require("../../../bit-id");

  _bitId = function () {
    return data;
  };

  return data;
}

function _idExportedAlready() {
  const data = _interopRequireDefault(require("./exceptions/id-exported-already"));

  _idExportedAlready = function () {
    return data;
  };

  return data;
}

function _logger() {
  const data = _interopRequireDefault(require("../../../logger/logger"));

  _logger = function () {
    return data;
  };

  return data;
}

function _analytics() {
  const data = require("../../../analytics/analytics");

  _analytics = function () {
    return data;
  };

  return data;
}

function _ejectComponents() {
  const data = _interopRequireDefault(require("../../../consumer/component-ops/eject-components"));

  _ejectComponents = function () {
    return data;
  };

  return data;
}

function _hasWildcard() {
  const data = _interopRequireDefault(require("../../../utils/string/has-wildcard"));

  _hasWildcard = function () {
    return data;
  };

  return data;
}

function _exportScopeComponents() {
  const data = require("../../../scope/component-ops/export-scope-components");

  _exportScopeComponents = function () {
    return data;
  };

  return data;
}

function _links() {
  const data = require("../../../links");

  _links = function () {
    return data;
  };

  return data;
}

function _generalError() {
  const data = _interopRequireDefault(require("../../../error/general-error"));

  _generalError = function () {
    return data;
  };

  return data;
}

function _constants() {
  const data = require("../../../constants");

  _constants = function () {
    return data;
  };

  return data;
}

function _manyComponentsWriter() {
  const data = _interopRequireDefault(require("../../../consumer/component-ops/many-components-writer"));

  _manyComponentsWriter = function () {
    return data;
  };

  return data;
}

function packageJsonUtils() {
  const data = _interopRequireWildcard(require("../../../consumer/component/package-json-utils"));

  packageJsonUtils = function () {
    return data;
  };

  return data;
}

function _prompts() {
  const data = require("../../../prompts");

  _prompts = function () {
    return data;
  };

  return data;
}

const HooksManagerInstance = _hooks().default.getInstance();

var _default =
/*#__PURE__*/
function () {
  var _exportAction = (0, _bluebird().coroutine)(function* (params) {
    HooksManagerInstance.triggerHook(_constants().PRE_EXPORT_HOOK, params);
    const {
      updatedIds,
      nonExistOnBitMap,
      missingScope,
      exported
    } = yield exportComponents(params);
    let ejectResults;
    if (params.eject) ejectResults = yield ejectExportedComponents(updatedIds);
    const exportResults = {
      componentsIds: exported,
      nonExistOnBitMap,
      missingScope,
      ejectResults
    };
    HooksManagerInstance.triggerHook(_constants().POST_EXPORT_HOOK, exportResults);
    return exportResults;
  });

  function exportAction(_x) {
    return _exportAction.apply(this, arguments);
  }

  return exportAction;
}();

exports.default = _default;

function exportComponents(_x2) {
  return _exportComponents.apply(this, arguments);
}

function _exportComponents() {
  _exportComponents = (0, _bluebird().coroutine)(function* ({
    ids,
    remote,
    includeDependencies,
    setCurrentScope,
    includeNonStaged,
    codemod,
    force
  }) {
    const consumer = yield (0, _consumer().loadConsumer)();
    const defaultScope = consumer.config.defaultScope;
    const {
      idsToExport,
      missingScope
    } = yield getComponentsToExport(ids, consumer, remote, includeNonStaged, defaultScope, force);
    if (_ramda().default.isEmpty(idsToExport)) return {
      updatedIds: [],
      nonExistOnBitMap: [],
      missingScope,
      exported: []
    };
    if (codemod) _throwForModified(consumer, idsToExport);
    const {
      exported,
      updatedLocally
    } = yield (0, _exportScopeComponents().exportMany)({
      scope: consumer.scope,
      ids: idsToExport,
      remoteName: remote,
      includeDependencies,
      changeLocallyAlthoughRemoteIsDifferent: setCurrentScope,
      codemod,
      defaultScope
    });

    const {
      updatedIds,
      nonExistOnBitMap
    } = _updateIdsOnBitMap(consumer.bitMap, updatedLocally);

    yield linkComponents(updatedIds, consumer);

    _analytics().Analytics.setExtraData('num_components', exported.length);

    if (codemod) {
      yield reImportComponents(consumer, updatedIds);
      yield cleanOldComponents(consumer, _bitId().BitIds.fromArray(updatedIds), idsToExport);
    } // it is important to have consumer.onDestroy() before running the eject operation, we want the
    // export and eject operations to function independently. we don't want to lose the changes to
    // .bitmap file done by the export action in case the eject action has failed.


    yield consumer.onDestroy();
    return {
      updatedIds,
      nonExistOnBitMap,
      missingScope,
      exported
    };
  });
  return _exportComponents.apply(this, arguments);
}

function _updateIdsOnBitMap(bitMap, componentsIds) {
  const updatedIds = [];
  const nonExistOnBitMap = new (_bitId().BitIds)();
  componentsIds.forEach(componentsId => {
    const resultId = bitMap.updateComponentId(componentsId, true); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

    if (resultId.hasVersion()) updatedIds.push(resultId);else nonExistOnBitMap.push(resultId);
  });
  return {
    updatedIds,
    nonExistOnBitMap
  };
}

function getComponentsToExport(_x3, _x4, _x5, _x6, _x7, _x8) {
  return _getComponentsToExport.apply(this, arguments);
}

function _getComponentsToExport() {
  _getComponentsToExport = (0, _bluebird().coroutine)(function* (ids, consumer, remote, includeNonStaged, defaultScope, force) {
    const componentsList = new (_componentsList().default)(consumer);
    const idsHaveWildcard = (0, _hasWildcard().default)(ids);

    const filterNonScopeIfNeeded = bitIds => {
      if (remote) return {
        idsToExport: bitIds,
        missingScope: []
      };

      const [idsToExport, missingScope] = _ramda().default.partition(id => id.hasScope() || defaultScope, bitIds);

      return {
        idsToExport: _bitId().BitIds.fromArray(idsToExport),
        missingScope
      };
    };

    const promptForFork =
    /*#__PURE__*/
    function () {
      var _ref = (0, _bluebird().coroutine)(function* (bitIds) {
        if (force || !remote) return;
        const idsToFork = bitIds.filter(id => id.scope && id.scope !== remote);
        if (!idsToFork.length) return;
        const forkPromptResult = yield (0, _prompts().forkComponentsPrompt)(idsToFork, remote)(); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        if (!(0, _yn().default)(forkPromptResult.shouldFork)) {
          throw new (_generalError().default)('the operation has been canceled');
        }
      });

      return function promptForFork(_x23) {
        return _ref.apply(this, arguments);
      };
    }();

    if (!ids.length || idsHaveWildcard) {
      _loader().default.start(_loaderMessages().BEFORE_LOADING_COMPONENTS);

      const exportPendingComponents = includeNonStaged ? yield componentsList.listNonNewComponentsIds() : yield componentsList.listExportPendingComponentsIds();
      const componentsToExport = idsHaveWildcard ? _componentsList().default.filterComponentsByWildcard(exportPendingComponents, ids) : exportPendingComponents;
      yield promptForFork(componentsToExport);
      const loaderMsg = componentsToExport.length > 1 ? _loaderMessages().BEFORE_EXPORTS : _loaderMessages().BEFORE_EXPORT;

      _loader().default.start(loaderMsg);

      return filterNonScopeIfNeeded(componentsToExport);
    }

    const idsToExportP = ids.map(
    /*#__PURE__*/
    function () {
      var _ref2 = (0, _bluebird().coroutine)(function* (id) {
        const parsedId = yield getParsedId(consumer, id);
        const status = yield consumer.getComponentStatusById(parsedId);

        if (status.nested) {
          throw new (_generalError().default)(`unable to export "${parsedId.toString()}", the component is not fully available. please use "bit import" first`);
        } // don't allow to re-export an exported component unless it's being exported to another scope


        if (remote && !status.staged && parsedId.scope === remote) {
          throw new (_idExportedAlready().default)(parsedId.toString(), remote);
        }

        return parsedId;
      });

      return function (_x24) {
        return _ref2.apply(this, arguments);
      };
    }());

    _loader().default.start(_loaderMessages().BEFORE_EXPORT); // show single export


    const idsToExport = yield Promise.all(idsToExportP);
    yield promptForFork(idsToExport);
    return filterNonScopeIfNeeded(_bitId().BitIds.fromArray(idsToExport));
  });
  return _getComponentsToExport.apply(this, arguments);
}

function getParsedId(_x9, _x10) {
  return _getParsedId.apply(this, arguments);
}

function _getParsedId() {
  _getParsedId = (0, _bluebird().coroutine)(function* (consumer, id) {
    // reason why not calling `consumer.getParsedId()` first is because a component might not be on
    // .bitmap and only in the scope. we support this case and enable to export
    const parsedId = yield consumer.scope.getParsedId(id);
    if (parsedId.hasScope()) return parsedId; // parsing id from the scope, doesn't provide the scope-name in case it's missing, in this case
    // get the id including the scope from the consumer.

    try {
      return consumer.getParsedId(id);
    } catch (err) {
      // not in the consumer, just return the one parsed without the scope name
      return parsedId;
    }
  });
  return _getParsedId.apply(this, arguments);
}

function linkComponents(_x11, _x12) {
  return _linkComponents.apply(this, arguments);
}

function _linkComponents() {
  _linkComponents = (0, _bluebird().coroutine)(function* (ids, consumer) {
    // we don't have much of a choice here, we have to load all the exported components in order to link them
    // some of the components might be authored, some might be imported.
    // when a component has dists, we need the consumer-component object to retrieve the dists info.
    const components = yield Promise.all(ids.map(id => consumer.loadComponentFromModel(id)));
    const nodeModuleLinker = new (_links().NodeModuleLinker)(components, consumer, consumer.bitMap);
    yield nodeModuleLinker.link();
  });
  return _linkComponents.apply(this, arguments);
}

function ejectExportedComponents(_x13) {
  return _ejectExportedComponents.apply(this, arguments);
}

function _ejectExportedComponents() {
  _ejectExportedComponents = (0, _bluebird().coroutine)(function* (componentsIds) {
    const consumer = yield (0, _consumer().loadConsumer)(undefined, true);
    let ejectResults;

    try {
      const ejectComponents = new (_ejectComponents().default)(consumer, componentsIds);
      ejectResults = yield ejectComponents.eject();
    } catch (err) {
      const ejectErr = `The components ${componentsIds.map(c => c.toString()).join(', ')} were exported successfully.
    However, the eject operation has failed due to an error: ${err.msg || err}`;

      _logger().default.error(ejectErr, err);

      throw new Error(ejectErr);
    } // run the consumer.onDestroy() again, to write the changes done by the eject action to .bitmap


    yield consumer.onDestroy();
    return ejectResults;
  });
  return _ejectExportedComponents.apply(this, arguments);
}

function reImportComponents(_x14, _x15) {
  return _reImportComponents.apply(this, arguments);
}

function _reImportComponents() {
  _reImportComponents = (0, _bluebird().coroutine)(function* (consumer, ids) {
    yield (0, _pMapSeries().default)(ids, id => reImportComponent(consumer, id));
  });
  return _reImportComponents.apply(this, arguments);
}

function reImportComponent(_x16, _x17) {
  return _reImportComponent.apply(this, arguments);
}
/**
 * remove the components with the old scope from package.json and from node_modules
 */


function _reImportComponent() {
  _reImportComponent = (0, _bluebird().coroutine)(function* (consumer, id) {
    const componentWithDependencies = yield consumer.loadComponentWithDependenciesFromModel(id);
    const componentMap = consumer.bitMap.getComponent(id);
    const rootDir = componentMap.rootDir;

    const shouldWritePackageJson =
    /*#__PURE__*/
    function () {
      var _ref3 = (0, _bluebird().coroutine)(function* () {
        if (!rootDir) return false;
        const packageJsonPath = path().join(consumer.getPath(), rootDir, 'package.json');
        return _fsExtra().default.pathExists(packageJsonPath);
      });

      return function shouldWritePackageJson() {
        return _ref3.apply(this, arguments);
      };
    }();

    const shouldInstallNpmPackages = () => {
      return componentMap.origin !== _constants().COMPONENT_ORIGINS.AUTHORED;
    };

    const writePackageJson = yield shouldWritePackageJson();
    const shouldDependenciesSaveAsComponents = yield consumer.shouldDependenciesSavedAsComponents([id]);
    componentWithDependencies.component.dependenciesSavedAsComponents = shouldDependenciesSaveAsComponents[0].saveDependenciesAsComponents;
    const manyComponentsWriter = new (_manyComponentsWriter().default)({
      consumer,
      componentsWithDependencies: [componentWithDependencies],
      installNpmPackages: shouldInstallNpmPackages(),
      override: true,
      writeConfig: Boolean(componentMap.configDir),
      // write bit.json and config files only if it was there before
      // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!
      configDir: componentMap.configDir,
      writePackageJson
    });
    yield manyComponentsWriter.writeAll();
  });
  return _reImportComponent.apply(this, arguments);
}

function cleanOldComponents(_x18, _x19, _x20) {
  return _cleanOldComponents.apply(this, arguments);
}

function _cleanOldComponents() {
  _cleanOldComponents = (0, _bluebird().coroutine)(function* (consumer, updatedIds, idsToExport) {
    const idsToClean = idsToExport.filter(id => updatedIds.hasWithoutScopeAndVersion(id));
    yield packageJsonUtils().removeComponentsFromWorkspacesAndDependencies(consumer, _bitId().BitIds.fromArray(idsToClean));
  });
  return _cleanOldComponents.apply(this, arguments);
}

function _throwForModified(_x21, _x22) {
  return _throwForModified2.apply(this, arguments);
}

function _throwForModified2() {
  _throwForModified2 = (0, _bluebird().coroutine)(function* (consumer, ids) {
    yield (0, _pMapSeries().default)(ids,
    /*#__PURE__*/
    function () {
      var _ref4 = (0, _bluebird().coroutine)(function* (id) {
        const status = consumer.getComponentStatusById(id); // @ts-ignore AUTO-ADDED-AFTER-MIGRATION-PLEASE-FIX!

        if (status.modified) {
          throw new (_generalError().default)(`unable to perform rewire on "${id.toString()}" because it is modified, please tag or discard your changes before re-trying`);
        }
      });

      return function (_x25) {
        return _ref4.apply(this, arguments);
      };
    }());
  });
  return _throwForModified2.apply(this, arguments);
}